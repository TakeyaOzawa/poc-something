# 🛠️ プロジェクト開発・品質基準 (Development Standards)

Amazon Q Developerは、**クリーンアーキテクチャ**、**ドメイン駆動設計 (DDD)**、および**ヘキサゴナルアーキテクチャ（ポートとアダプター）**の原則に厳密に準拠してコード生成、レビュー、および提案を行うこと。

---

## 🏛️ アーキテクチャと階層構造のルール

### 1. 命名規則の遵守
以下の命名規則をすべてのファイルとディレクトリに厳密に適用すること。

| 項目 | 命名規則 | 例 |
| :--- | :--- | :--- |
| **ファイル名 (全般)** | **PascalCase** | `User.ts`, `CreateUserUsecase.ts`, `Background.ts` |
| **ディレクトリ名** | **kebab-case** | `value-objects`, `worker-scripts`, `external-service` |
| **インターフェース名** | PascalCase（`I`を付けない）| `UserRepository`, `Logger` |

### 2. 厳格な階層構造（ツリー形式）

依存関係は必ず**内側**（`domain`層）に向かって流れること。

project-root/ 
├── src/ 
│ ├── domain/ (💎 コアビジネスルール層 - 依存性なし) 
│ │ ├── entities/ 
│ │ │ ├── User.ts // class User 
│ │ │ └── __tests__ 
│ │ │   └── User.test.ts // class User 
│ │ ├── value-objects/ // ディレクトリ名はkebab-case 
│ │ │ └── Email.ts //tsファイル名はパスケルケース
│ │ ├── services/ // ドメインサービス 
│ │ │ └── UserDomainService.ts 
│ │ ├── factories/ 
│ │ │ └── UserFactory.ts
│ │ └── ports/ // 外部依存の抽象化インターフェース (リポジトリ, 外部サービス) 
│ │   ├── repositories/ //エンティティの永続化と検索の抽象化
│ │   | └── UserRepository.ts
│ │   ├── gateways/ //外部システムやAPIへの連携の抽象化
│ │   | ├── PaymentGateway.ts
│ │   | ├── Logger.ts
│ │   | ├── BrowserMessageSender.ts
│ │   | ├── TabManager.ts // TabManager { openNewTab(url: string): Promise<void> }
│ │   | └── EmailClient.ts
│ │   ├── publishers/ //ドメインイベントやメッセージの発行・通知の抽象化
│ │   │ ├── DomainEventPublisher.ts //publish(event: DomainEvent): Promise<void>
│ │   │ └── MessageQueue.ts //enqueue(message: Message): Promise<void>
│ │   └── environmental/ //テストが難しい環境依存機能の抽象化
│ │     ├── Clock.ts //now():Date (現在の時刻を取得する)
│ │     └── IdGenerator.ts //nextId(): string (一意のIDを生成する)
│ │ 
│ ├── application/ (⚙️ ユースケース層 - domainに依存) 
│ │ ├── use-cases/ 
│ │ │ ├── CreateUserUsecase.ts 
│ │ │ └─- OpenNewTabUsecase.ts // TabManagerポートを介してタブを開く
│ │ ├── dtos/ //DTOの型定義（interface）の場所
│ │ │ ├── UserCreateInputDto.ts // interface UserCreateInputDto
│ │ │ └── UserOutputDto.ts // interface UserOutputDto
│ │ └── mappers/
│ │   └── UserMapper.ts // toOutputDto(), toEntity()の実装
│ │
│ ├── presentation/ (🖥️ プレゼンテーション層 - applicationに依存) 
│ │ ├── components/ 
│ │ │ └── Button.tsx 
│ │ ├── pages/ 
│ │ │ └── popup/ // 画面ごとのディレクトリ 
│ │ │  ├── PopupContainer.tsx // 💡 Input DTOの実装 (ユーザー入力をDTOに変換し、ユースケースに渡す)
│ │ │  └── PopupView.tsx 
│ │ └── hooks/ // UI固有のカスタムフック
│ │ 
│ ├── infrastructure/ (🔌 インフラストラクチャ層 - domain/applicationに依存) 
│ │ ├── adapters/ // ドメイン層のポートの具体的な実装（ドリブンアダプター） 
│ │ │ ├── repositories/ // UserBrowserLocalStorage.ts (UserRepositoryなどの実装) 
│ │ │ ├── gateways/
│ │ │ │ ├── AirPayGateway.ts
│ │ │ │ ├── ConsoleLogger.ts
│ │ │ │ ├── BrowserTabManager.ts // TabManagerポートの実装。内部でTabWrapperを利用
│ │ │ │ └── BackgroundLogger.ts // 全ての画面のログを
│ │ │ ├── publishers/
│ │ │ └── environmental/
│ │ ├── chrome-wrappers/ // ブラウザリソースへの低レベルアクセス 
│ │ │ ├── LocalStorage.ts // chrome.storage.local.get/set の直接的な呼び出し
│ │ │ ├── Messaging.ts // chrome.runtime.sendMessage の呼び出しロジック
│ │ │ └── Tab.ts // chrome.tabs.create({ url: ... }) などの直接的なAPI呼び出しロジック
│ │ ├── worker-scripts/ // Service Workerのエントリーポイント。メッセージ送信リスナー登録と発火の処理
│ │ │ └── Background.ts // chrome.runtime.onMessage.addListener(処理) の登録
│ │ └── content-script/ // DOM操作のエントリーポイント 
│ │   └── ContentScript.ts //リスナー登録。DOMイベントからのメッセージ発火など
│ │ 
│ ├── i18n/ (🌐 多言語対応) 
│ │ └── locales/ // 翻訳ファイル (例: en.json, ja.json)
│ │ 
│ └── types/ (📚 共通型定義) 
│   ├── common/ 
│   ├── browser-messaging/ 
│   │ ├── AppMessage.ts // メッセージの基本構造（type, payload）
│   │ └── UserMessagePayload.ts // 特定のメッセージのペイロード構造
│   └── utility/ 
│ 
└── tests/ (🧪 結合テスト以降) 
  ├── integration/
  └── e2e/

### 3. DTO (Data Transfer Object) 実装の原則

DTOは、データの構造（型定義）を `application/dtos/` に定義しますが、その具体的な**実装（インスタンス化と値の代入）**は、アプリケーション層と外部層との境界線でのみ行うこと。

#### 1. 入力 DTO (Input DTO) の実装
* **目的**: 外部からの生データをユースケースが処理できる形式に変換すること。
* **実装場所**: **プレゼンテーション層** (`src/presentation/`) または**インフラストラクチャ層** (`src/infrastructure/`)。
    * 例: `PopupContainer.tsx` がフォーム入力値を集約し、`UserCreateInputDto` としてインスタンス化して、ユースケースを呼び出す直前。
    * 例: `worker-scripts/Background.ts` がメッセージを受信し、`Input DTO` に変換してユースケースに渡す直前。

#### 2. 出力 DTO (Output DTO) の実装
* **目的**: **ドメインエンティティの機密情報**や**不必要なロジック**を外部に漏らさず、UIや外部サービスが必要とする形式に整形すること。
* **実装場所**: **アプリケーション層** (`src/application/use-cases/`) の**実行メソッドの内部（最後）**。
    * **処理**: ユースケースが操作したドメインエンティティのデータ（例: `User`）から、表示に必要なプロパティのみを抽出し、`UserOutputDto` をインスタンス化して呼び出し元（`presentation`層など）に返すこと。
* **厳守事項**: ドメインエンティティを直接、プレゼンテーション層やインフラストラクチャ層に渡すことは**禁止**とする。

### 4. Chromeメッセージングの管理
Chrome拡張機能のメッセージングは、インフラストラクチャに依存する機能として以下のルールに従うこと。

* **メッセージ送信の抽象化**: ドメイン層は**`domain/ports/gateways/MessageSender.ts`**インターフェースを通じてメッセージ送信を抽象化すること。
* **リスナーの登録と発火**: メッセージのリスナー登録（`chrome.runtime.onMessage.addListener`）とメッセージの発火（`chrome.tabs.sendMessage`など）は、**`infrastructure`層**（例: `worker-scripts/Background.ts`, `content-script/Content.ts`）が責任を持つこと。
* **メッセージ内容の型管理**: メッセージの**一覧とペイロードの型定義**は、**`types/messaging/`** ディレクトリで一元管理すること。
* **処理委譲**: メッセージを受信した際、インフラストラクチャ層（Service Workerなど）は、メッセージの生データを**DTOに変換**した後、必ず**`application`層のユースケース**を呼び出し、ビジネスロジックを処理させること。

### 5. Presentation Hooks の実装ルール (新規追加)

`presentation/hooks/` ディレクトリに配置されるカスタムフックは、以下の原則を厳守すること。

* **責務の限定**: カスタムフックは、**UI固有のロジック、状態管理、および副作用**に限定すること。
    * 例: フォームの状態管理、リアルタイムな UI バリデーション、データ取得状態 (`isLoading`, `error`) の管理、DOM操作、アニメーション管理。
* **ビジネスロジックの排除**: **ドメイン層**や**アプリケーション層**に属する**コアビジネスロジック**（例: ユーザーの認証処理、料金計算、データベースへの直接的なデータ操作ロジックなど）をカスタムフック内に直接実装することは**禁止**とする。
* **データの取得**: データ取得が必要なカスタムフックは、必ず**`application/use-cases/`**を呼び出すことを通じて間接的に行うこと。
* **再利用性の確保**: 複数のコンポーネントで共有されるべきロジックのみをカスタムフックとして定義し、コンポーネントのロジックをスリム化することを目指す。

#### 💡 Hooksの具体的な責務例

* `useFormState.ts`: 複数の入力フィールドの状態と UI バリデーションロジックの管理。
* `useFetchUser.ts`: `application`層のユースケースを呼び出し、`{ data, isLoading, error }` の状態を UI に提供する。
* `usePopupPosition.ts`: ウィンドウサイズや要素の位置に基づいた表示位置の計算（DOM依存ロジック）。

---

## 🧪 テストと品質保証のルール

### 1. コードカバレッジの目標設定
* すべてのコード変更において、**コードカバレッジが90%以上**となるようにテストケースを作成・維持すること。
* **`domain`層**は最高水準の品質保証を目的とし、**95%以上のカバレッジ**を厳守すること。
* 他の層に関しても1ファイル毎に**90%以上のカバレッジ**を目指し、カバレッジが90%未満となる場合は、現在のカバレッジ率と具体的な理由をテスト対象ファイル上部に**Markdownコメント**で記載すること。

### 2. テストコードの配置とモック
* **単体テストコード**：
    * **`src`内の各フォルダ直下**に**`__tests__`**ディレクトリを設け、対象ファイルのテストを配置する。
    * 例: `src/domain/entities/__tests__/User.test.ts`
* **結合テストコード以降**：
    * **`src`ディレクトリと並ぶトップレベル**に**`__tests__`**ディレクトリを設け、統合テストやE2Eテストを配置する。
* **モック (Mock) の作成場所**:
    * モックコードは、テスト対象のファイルが依存する**インターフェース**（`domain/ports`）を実装するものとし、**テストコードと同じ`__tests__`ディレクトリ内**に配置する。
* **テストケースタイトルと言語**:
    * テストコードのケースタイトルは、そのクラスの**仕様書**となることを目指し、すべて**日本語の文章**で記述すること。
    * 形式：「**`[対象メソッド]で[条件]の場合、[期待値]となること`**」

### 3. 静的解析
* 静的解析（Lint）の結果、**`warn`（警告）以上の指摘が0件**となることを保証すること。


## 🤝 作業プロセスとドキュメンテーションのルール

### 1. 新規機能/品質改善のためのドキュメント作成（Markdown形式）
複数フェーズを必要とする**新規機能追加や品質改善**の作業に着手する前に、以下の設計ファイルをNotion移行を想定した**Markdown形式**で作成し、一度**ユーザーに判断を求める**こと。

1.  **外部仕様**:
    * **機能仕様**: ユーザーから見た機能の振る舞いを明確化。
    * **非機能仕様**: 性能、セキュリティ、保守性などの要件を明確化。
2.  **内部仕様**:
    * アーキテクチャ上の変更点、クラス図、シーケンス図、主要なアルゴリズムの概要。
3.  **影響範囲・修正方針**:
    * 既存コードベースで変更が必要なファイル、コンポーネント、および修正の具体的なアプローチ。
4.  **タスクリスト**:
    * 作業を完了するために必要なWBS（作業分解構造）および担当者/所要時間（想定）のリスト。

作業時は、これらのファイルを**参照**し、進捗や設計変更があった場合は**随時更新**すること。

### 2. 作業時間の明記と完了報告
* **作業開始時**: `docs`ファイルまたは関連ログに**作業の開始日時**を明記すること。
* **作業完了時**:
    1.  `docs`ファイルまたは関連ログに**作業の終了日時**を明記すること。
    2.  作業完了報告として、所定の`slack_notify.sh`スクリプトを実行し、関係者に通知すること。

## 🔔 ユーザー通知ルール

**IMPORTANT**: Amazon Qがユーザーに選択や指示を求める前に、必ずSlack通知を送信してください。

### 通知を送るべき状況

以下のいずれかの状況では、**必ず`slack-notification.sh`を実行してからユーザーに問い合わせを行う**こと：

1. **AskUserQuestionツールを使用する前**
   - 実装方法の選択肢を提示する場合
   - アーキテクチャやライブラリの選択を求める場合
   - 仕様の不明点について確認が必要な場合

2. **次の指示を待つ必要がある場合**
   - 作業が完了し、次のタスクの指示を待つ時
   - エラーや問題が発生し、ユーザーの判断が必要な時
   - 長時間実行されるコマンド（ビルド、テスト等）が完了した時

3. **重要な意思決定が必要な場合**
   - 破壊的な変更を行う前の確認
   - データの削除や大規模なリファクタリングの承認
   - セキュリティに関わる変更の確認

4. **ファイルアクセスやコマンド実行の許可が必要な場合**
   - ユーザー承認が必要なファイルへのアクセスを行う前
   - ユーザー承認が必要なコマンドを実行する前
   - セキュリティ上重要なツール使用の承認を求める場合

### 通知スクリプトの実行方法

```bash
bash slack-notification.sh "[$$]実施中のタスク要約" "状況詳細"
```

**引数の説明:**
- 第1引数（必須）: 実施中のタスク要約（何を行っているか）
  - **IMPORTANT**: タスク要約の先頭に`[$$]`プレフィックスを付けて、プロセスIDを含めること
  - 形式: `[$$]タスクの説明`
  - 例: `[$$]ユーザー認証機能の実装`
  - `$$`はシェルスクリプト内で自動的に実行中のプロセスIDに展開されます
- 第2引数（オプション）: 状況詳細（なぜ通知が必要か、次に何をすべきか）
  - 省略時のデフォルト: "確認が必要です"

**通知形式:**
Slackブロック形式で以下の構造で送信されます：
```
実施中のタスク:
[12345]タスク要約

状況:
<状況詳細>
```
※ `[12345]` の部分は実際のプロセスIDに置き換えられます

### 実行例

```typescript
// 例1: ユーザーに選択肢を提示する前
// 1. まずSlack通知を送信
Bash: bash slack-notification.sh \
  "[$$]認証機能の実装" \
  "認証方式の選択が必要です。Claudeからの質問を確認してください。"

// 2. その後、AskUserQuestionツールを使用
AskUserQuestion: {
  questions: [{
    question: "認証方式を選択してください",
    header: "Auth method",
    options: [...]
  }]
}

// 例2: 作業完了後の報告前
// 1. Slack通知を送信
Bash: bash slack-notification.sh \
  "[$$]変数名のリネーム作業" \
  "リネーム作業が完了しました。次のタスクの指示をお願いします。"

// 2. 完了報告とともに次の指示を依頼
Output: "リネーム作業が完了しました。次のタスクについてご指示ください。"

// 例3: 長時間コマンドの完了通知
Bash: bash slack-notification.sh \
  "[$$]プロジェクトのビルド" \
  "ビルドが完了しました。3件のwarningがあります。結果を確認してください。"

// 例4: エラー発生時
Bash: bash slack-notification.sh \
  "[$$]テストの実行" \
  "5件のテストが失敗しています。エラーログの確認とユーザーの判断が必要です。"

// 例5: ユーザーによるリクエスト中断時
Bash: bash slack-notification.sh \
  "[$$][Request interrupted by user] データベーススキーマの変更" \
  "作業が中断されました。再開するには指示をお願いします。"

// 例6: ファイルアクセス・コマンド実行の許可を求める前
// 1. Slack通知を送信
Bash: bash slack-notification.sh \
  "[$$]システムファイルの編集" \
  "/etc/hostsファイルへの書き込み許可が必要です。Claudeからの承認リクエストを確認してください。"

// 2. ユーザーに承認を求める（Claude Codeの許可システム経由）
// ユーザーが許可を与えるまで待機

// 例7: 複数行のメッセージ（改行を含む）
Bash: bash slack-notification.sh \
  "[$$]依存パッケージの更新" \
  "以下のパッケージの更新確認が必要です:
- react: 18.2.0 → 18.3.0
- typescript: 5.0.4 → 5.3.0
承認をお願いします。"
```

### メッセージのガイドライン

通知メッセージは**簡潔で具体的**に記述してください：

#### タスク要約（第1引数）の書き方

**✅ 良い例:**
- "[$$]ユーザー認証機能の実装"
- "[$$]テストカバレッジの改善"
- "[$$]データベーススキーマの変更"
- "[$$]依存パッケージの更新"
- "[$$]リファクタリング: ファイル構造の整理"

**❌ 悪い例:**
- "作業中" （PIDプレフィックスなし、何の作業か不明）
- "実装" （PIDプレフィックスなし、何を実装しているか不明）
- "[$$]修正" （内容が不明確）
- "ユーザー認証機能の実装" （PIDプレフィックスなし）

#### 状況詳細（第2引数）の書き方

**✅ 良い例:**
- "認証方式（JWT/OAuth/Session）の選択が必要です。質問を確認してください。"
- "テストが完了しました。3件のエラーがあります。確認をお願いします。"
- "/etc/hostsファイルへの書き込み許可が必要です。承認をお願いします。"
- "ビルドが完了しました。5件のwarningがあります。結果を確認してください。"
- "エラーが発生しました:
TypeError: Cannot read property 'name' of undefined
修正方針の確認が必要です。"

**❌ 悪い例:**
- "確認してください。" （何を確認するか不明）
- "許可が必要です。" （何の許可か不明）
- "エラーです。" （どんなエラーか不明）
- "完了しました。" （結果や次のアクションが不明）

#### ベストプラクティス

1. **PIDプレフィックスは必須**: タスク要約の先頭に必ず`[$$]`を付ける
2. **タスク要約は名詞形で**: "[$$]〜の実装"、"[$$]〜の修正"、"[$$]〜の更新"
3. **状況詳細は具体的に**: 数値、エラーメッセージ、次のアクションを含める
4. **長い情報は改行を活用**: 複数の項目は箇条書きで
5. **緊急度を示す**: 必要に応じて絵文字（⚠️、✅、❌）を使用可能

### 注意事項

- **PIDプレフィックスは必須**: タスク要約の先頭に必ず`[$$]`を付けること。`$$`はシェルスクリプト内でプロセスIDに自動展開されます
- スクリプトはプロジェクトルート（`auto-fill-tool/`）に配置されています
- 通知は非同期で送信されるため、実行後すぐにユーザーへの問い合わせを続行できます
- スクリプトの実行エラーは無視して構いません（通知の失敗で作業を止めないこと）
- 第2引数（状況詳細）を省略した場合、デフォルトで"確認が必要です"が設定されます
- 改行を含むメッセージも正しく送信されます（JSONエスケープ処理済み）

### 環境変数の設定（初回のみ）

スクリプトを使用するには、以下の環境変数が必要です：

```bash
export AMAZON_Q_SLACK_OAUTH_TOKEN='xoxb-your-bot-token'
export AMAZON_Q_SLACK_USER_ID='U1234567890'
```

**使用例（環境変数設定済み）:**
```bash
# シンプルな通知（第2引数省略）
bash slack-notification.sh "[$$]テストの実行"

# 詳細を含む通知
bash slack-notification.sh "[$$]テストの実行" "5件のテストが失敗しました。確認してください。"
```

環境変数が未設定の場合、スクリプトはエラーメッセージを表示しますが、**Amazpn Qの作業は継続してください**（通知機能は補助機能のため）。
