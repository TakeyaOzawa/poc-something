
> auto-fill-tool@2.4.0 test
> jest

FAIL src/usecases/storage/__tests__/ExecuteStorageSyncUseCase.test.ts (9.593 s)
  ● ExecuteStorageSyncUseCase › execute() › should handle repository load errors

    expect(received).rejects.toThrow()

    Received promise resolved instead of rejected
    Resolved to value: {"error": "Database connection failed", "success": false, "syncDirection": "bidirectional"}

      165 |       useCase = new ExecuteStorageSyncUseCase(
      166 |         mockConfigRepository,
    > 167 |         mockExecuteReceiveDataUseCase,
          |                   ^
      168 |         mockExecuteSendDataUseCase,
      169 |         mockSyncHistoryRepository,
      170 |         mockSyncStateNotifier,

      at expect (node_modules/expect/build/index.js:113:15)
      at Object.<anonymous> (src/usecases/storage/__tests__/ExecuteStorageSyncUseCase.test.ts:167:19)

PASS src/presentation/xpath-manager/__tests__/XPathManagerCoordinator.test.ts (17.55 s)
FAIL tests/integration/page-transition-resume.integration.test.ts (18.698 s)
  ● Page Transition Resume Integration Tests › Task 4.2: New Execution › should create AutomationResult in DOING status when starting new execution

    TypeError: Cannot read properties of undefined (reading 'getByWebsiteId')

      111 |       // Find matching automationVariablesId
      112 |       for (const result of validResults) {
    > 113 |         const loadResult = await this.automationVariablesRepository.load(
          |                          ^
      114 |           result.getAutomationVariablesId()
      115 |         );
      116 |

      at ExecuteAutoFillUseCase.loadAndValidateXPaths (src/usecases/auto-fill/ExecuteAutoFillUseCase.ts:113:26)
      at ExecuteAutoFillUseCase.startNewExecution (src/usecases/auto-fill/ExecuteAutoFillUseCase.ts:124:39)
      at ExecuteAutoFillUseCase.execute (src/usecases/auto-fill/ExecuteAutoFillUseCase.ts:52:16)
      at Object.<anonymous> (tests/integration/page-transition-resume.integration.test.ts:239:28)

  ● Page Transition Resume Integration Tests › Task 4.2: New Execution › should save AutomationVariables with correct websiteId

    TypeError: Cannot read properties of undefined (reading 'getByWebsiteId')

      111 |       // Find matching automationVariablesId
      112 |       for (const result of validResults) {
    > 113 |         const loadResult = await this.automationVariablesRepository.load(
          |                          ^
      114 |           result.getAutomationVariablesId()
      115 |         );
      116 |

      at ExecuteAutoFillUseCase.loadAndValidateXPaths (src/usecases/auto-fill/ExecuteAutoFillUseCase.ts:113:26)
      at ExecuteAutoFillUseCase.startNewExecution (src/usecases/auto-fill/ExecuteAutoFillUseCase.ts:124:39)
      at ExecuteAutoFillUseCase.execute (src/usecases/auto-fill/ExecuteAutoFillUseCase.ts:52:16)
      at Object.<anonymous> (tests/integration/page-transition-resume.integration.test.ts:280:28)

  ● Page Transition Resume Integration Tests › Task 4.2: New Execution › should initialize progress tracking fields correctly

    TypeError: Cannot read properties of undefined (reading 'getByWebsiteId')

      111 |       // Find matching automationVariablesId
      112 |       for (const result of validResults) {
    > 113 |         const loadResult = await this.automationVariablesRepository.load(
          |                          ^
      114 |           result.getAutomationVariablesId()
      115 |         );
      116 |

      at ExecuteAutoFillUseCase.loadAndValidateXPaths (src/usecases/auto-fill/ExecuteAutoFillUseCase.ts:113:26)
      at ExecuteAutoFillUseCase.startNewExecution (src/usecases/auto-fill/ExecuteAutoFillUseCase.ts:124:39)
      at ExecuteAutoFillUseCase.execute (src/usecases/auto-fill/ExecuteAutoFillUseCase.ts:52:16)
      at Object.<anonymous> (tests/integration/page-transition-resume.integration.test.ts:330:28)

  ● Page Transition Resume Integration Tests › Task 4.2: New Execution › should calculate progress percentage correctly

    TypeError: Cannot read properties of undefined (reading 'getByWebsiteId')

      111 |       // Find matching automationVariablesId
      112 |       for (const result of validResults) {
    > 113 |         const loadResult = await this.automationVariablesRepository.load(
          |                          ^
      114 |           result.getAutomationVariablesId()
      115 |         );
      116 |

      at ExecuteAutoFillUseCase.loadAndValidateXPaths (src/usecases/auto-fill/ExecuteAutoFillUseCase.ts:113:26)
      at ExecuteAutoFillUseCase.startNewExecution (src/usecases/auto-fill/ExecuteAutoFillUseCase.ts:124:39)
      at ExecuteAutoFillUseCase.execute (src/usecases/auto-fill/ExecuteAutoFillUseCase.ts:52:16)
      at Object.<anonymous> (tests/integration/page-transition-resume.integration.test.ts:375:28)

  ● Page Transition Resume Integration Tests › Task 4.3: CHANGE_URL Progress Saving › should save progress after CHANGE_URL action

    TypeError: Cannot read properties of undefined (reading 'getByWebsiteId')

      111 |       // Find matching automationVariablesId
      112 |       for (const result of validResults) {
    > 113 |         const loadResult = await this.automationVariablesRepository.load(
          |                          ^
      114 |           result.getAutomationVariablesId()
      115 |         );
      116 |

      at ExecuteAutoFillUseCase.loadAndValidateXPaths (src/usecases/auto-fill/ExecuteAutoFillUseCase.ts:113:26)
      at ExecuteAutoFillUseCase.startNewExecution (src/usecases/auto-fill/ExecuteAutoFillUseCase.ts:124:39)
      at ExecuteAutoFillUseCase.execute (src/usecases/auto-fill/ExecuteAutoFillUseCase.ts:52:16)
      at Object.<anonymous> (tests/integration/page-transition-resume.integration.test.ts:440:28)

  ● Page Transition Resume Integration Tests › Task 4.3: CHANGE_URL Progress Saving › should save progress multiple times for multiple CHANGE_URL actions

    TypeError: Cannot read properties of undefined (reading 'getByWebsiteId')

      111 |       // Find matching automationVariablesId
      112 |       for (const result of validResults) {
    > 113 |         const loadResult = await this.automationVariablesRepository.load(
          |                          ^
      114 |           result.getAutomationVariablesId()
      115 |         );
      116 |

      at ExecuteAutoFillUseCase.loadAndValidateXPaths (src/usecases/auto-fill/ExecuteAutoFillUseCase.ts:113:26)
      at ExecuteAutoFillUseCase.startNewExecution (src/usecases/auto-fill/ExecuteAutoFillUseCase.ts:124:39)
      at ExecuteAutoFillUseCase.execute (src/usecases/auto-fill/ExecuteAutoFillUseCase.ts:52:16)
      at Object.<anonymous> (tests/integration/page-transition-resume.integration.test.ts:506:28)

  ● Page Transition Resume Integration Tests › Task 4.3: CHANGE_URL Progress Saving › should calculate correct progress percentage after CHANGE_URL

    TypeError: Cannot read properties of undefined (reading 'getByWebsiteId')

      111 |       // Find matching automationVariablesId
      112 |       for (const result of validResults) {
    > 113 |         const loadResult = await this.automationVariablesRepository.load(
          |                          ^
      114 |           result.getAutomationVariablesId()
      115 |         );
      116 |

      at ExecuteAutoFillUseCase.loadAndValidateXPaths (src/usecases/auto-fill/ExecuteAutoFillUseCase.ts:113:26)
      at ExecuteAutoFillUseCase.startNewExecution (src/usecases/auto-fill/ExecuteAutoFillUseCase.ts:124:39)
      at ExecuteAutoFillUseCase.execute (src/usecases/auto-fill/ExecuteAutoFillUseCase.ts:52:16)
      at Object.<anonymous> (tests/integration/page-transition-resume.integration.test.ts:555:28)

  ● Page Transition Resume Integration Tests › Task 4.4: Resume Execution › should resume execution from currentStepIndex when DOING status exists

    TypeError: Cannot read properties of undefined (reading 'getByWebsiteId')

      111 |       // Find matching automationVariablesId
      112 |       for (const result of validResults) {
    > 113 |         const loadResult = await this.automationVariablesRepository.load(
          |                          ^
      114 |           result.getAutomationVariablesId()
      115 |         );
      116 |

      at ExecuteAutoFillUseCase.loadAndValidateXPaths (src/usecases/auto-fill/ExecuteAutoFillUseCase.ts:113:26)
      at ExecuteAutoFillUseCase.startNewExecution (src/usecases/auto-fill/ExecuteAutoFillUseCase.ts:124:39)
      at ExecuteAutoFillUseCase.execute (src/usecases/auto-fill/ExecuteAutoFillUseCase.ts:52:16)
      at Object.<anonymous> (tests/integration/page-transition-resume.integration.test.ts:607:28)

  ● Page Transition Resume Integration Tests › Task 4.4: Resume Execution › should only resume executions within 24 hours

    TypeError: Cannot read properties of undefined (reading 'getByWebsiteId')

      111 |       // Find matching automationVariablesId
      112 |       for (const result of validResults) {
    > 113 |         const loadResult = await this.automationVariablesRepository.load(
          |                          ^
      114 |           result.getAutomationVariablesId()
      115 |         );
      116 |

      at ExecuteAutoFillUseCase.loadAndValidateXPaths (src/usecases/auto-fill/ExecuteAutoFillUseCase.ts:113:26)
      at ExecuteAutoFillUseCase.startNewExecution (src/usecases/auto-fill/ExecuteAutoFillUseCase.ts:124:39)
      at ExecuteAutoFillUseCase.execute (src/usecases/auto-fill/ExecuteAutoFillUseCase.ts:52:16)
      at Object.<anonymous> (tests/integration/page-transition-resume.integration.test.ts:663:28)

  ● Page Transition Resume Integration Tests › Task 4.4: Resume Execution › should only resume executions with matching websiteId

    TypeError: Cannot read properties of undefined (reading 'getByWebsiteId')

      111 |       // Find matching automationVariablesId
      112 |       for (const result of validResults) {
    > 113 |         const loadResult = await this.automationVariablesRepository.load(
          |                          ^
      114 |           result.getAutomationVariablesId()
      115 |         );
      116 |

      at ExecuteAutoFillUseCase.loadAndValidateXPaths (src/usecases/auto-fill/ExecuteAutoFillUseCase.ts:113:26)
      at ExecuteAutoFillUseCase.startNewExecution (src/usecases/auto-fill/ExecuteAutoFillUseCase.ts:124:39)
      at ExecuteAutoFillUseCase.execute (src/usecases/auto-fill/ExecuteAutoFillUseCase.ts:52:16)
      at Object.<anonymous> (tests/integration/page-transition-resume.integration.test.ts:718:28)

  ● Page Transition Resume Integration Tests › Task 4.4: Resume Execution › should handle case when currentStepIndex exceeds total steps

    TypeError: Cannot read properties of undefined (reading 'getByWebsiteId')

      111 |       // Find matching automationVariablesId
      112 |       for (const result of validResults) {
    > 113 |         const loadResult = await this.automationVariablesRepository.load(
          |                          ^
      114 |           result.getAutomationVariablesId()
      115 |         );
      116 |

      at ExecuteAutoFillUseCase.loadAndValidateXPaths (src/usecases/auto-fill/ExecuteAutoFillUseCase.ts:113:26)
      at ExecuteAutoFillUseCase.startNewExecution (src/usecases/auto-fill/ExecuteAutoFillUseCase.ts:124:39)
      at ExecuteAutoFillUseCase.execute (src/usecases/auto-fill/ExecuteAutoFillUseCase.ts:52:16)
      at Object.<anonymous> (tests/integration/page-transition-resume.integration.test.ts:767:28)

  ● Page Transition Resume Integration Tests › Task 4.5: Edge Cases › should start new execution when checkExistingExecution fails

    TypeError: Cannot read properties of undefined (reading 'getByWebsiteId')

      111 |       // Find matching automationVariablesId
      112 |       for (const result of validResults) {
    > 113 |         const loadResult = await this.automationVariablesRepository.load(
          |                          ^
      114 |           result.getAutomationVariablesId()
      115 |         );
      116 |

      at ExecuteAutoFillUseCase.loadAndValidateXPaths (src/usecases/auto-fill/ExecuteAutoFillUseCase.ts:113:26)
      at ExecuteAutoFillUseCase.startNewExecution (src/usecases/auto-fill/ExecuteAutoFillUseCase.ts:124:39)
      at ExecuteAutoFillUseCase.execute (src/usecases/auto-fill/ExecuteAutoFillUseCase.ts:52:16)
      at Object.<anonymous> (tests/integration/page-transition-resume.integration.test.ts:812:28)

  ● Page Transition Resume Integration Tests › Task 4.5: Edge Cases › should continue execution even when AutomationResult save fails

    TypeError: Cannot read properties of undefined (reading 'getByWebsiteId')

      111 |       // Find matching automationVariablesId
      112 |       for (const result of validResults) {
    > 113 |         const loadResult = await this.automationVariablesRepository.load(
          |                          ^
      114 |           result.getAutomationVariablesId()
      115 |         );
      116 |

      at ExecuteAutoFillUseCase.loadAndValidateXPaths (src/usecases/auto-fill/ExecuteAutoFillUseCase.ts:113:26)
      at ExecuteAutoFillUseCase.startNewExecution (src/usecases/auto-fill/ExecuteAutoFillUseCase.ts:124:39)
      at ExecuteAutoFillUseCase.execute (src/usecases/auto-fill/ExecuteAutoFillUseCase.ts:52:16)
      at Object.<anonymous> (tests/integration/page-transition-resume.integration.test.ts:851:28)

  ● Page Transition Resume Integration Tests › Task 4.5: Edge Cases › should execute successfully when AutomationVariables not found

    TypeError: Cannot read properties of undefined (reading 'getByWebsiteId')

      111 |       // Find matching automationVariablesId
      112 |       for (const result of validResults) {
    > 113 |         const loadResult = await this.automationVariablesRepository.load(
          |                          ^
      114 |           result.getAutomationVariablesId()
      115 |         );
      116 |

      at ExecuteAutoFillUseCase.loadAndValidateXPaths (src/usecases/auto-fill/ExecuteAutoFillUseCase.ts:113:26)
      at ExecuteAutoFillUseCase.startNewExecution (src/usecases/auto-fill/ExecuteAutoFillUseCase.ts:124:39)
      at ExecuteAutoFillUseCase.execute (src/usecases/auto-fill/ExecuteAutoFillUseCase.ts:52:16)
      at Object.<anonymous> (tests/integration/page-transition-resume.integration.test.ts:878:28)

  ● Page Transition Resume Integration Tests › Task 4.5: Edge Cases › should handle repository errors gracefully during resume check

    TypeError: Cannot read properties of undefined (reading 'getByWebsiteId')

      111 |       // Find matching automationVariablesId
      112 |       for (const result of validResults) {
    > 113 |         const loadResult = await this.automationVariablesRepository.load(
          |                          ^
      114 |           result.getAutomationVariablesId()
      115 |         );
      116 |

      at ExecuteAutoFillUseCase.loadAndValidateXPaths (src/usecases/auto-fill/ExecuteAutoFillUseCase.ts:113:26)
      at ExecuteAutoFillUseCase.startNewExecution (src/usecases/auto-fill/ExecuteAutoFillUseCase.ts:124:39)
      at ExecuteAutoFillUseCase.execute (src/usecases/auto-fill/ExecuteAutoFillUseCase.ts:52:16)
      at Object.<anonymous> (tests/integration/page-transition-resume.integration.test.ts:932:28)

  ● Page Transition Resume Integration Tests › Task 4.5: Edge Cases › should handle AutomationResult load failure in finalizeExecution

    TypeError: Cannot read properties of undefined (reading 'getByWebsiteId')

      111 |       // Find matching automationVariablesId
      112 |       for (const result of validResults) {
    > 113 |         const loadResult = await this.automationVariablesRepository.load(
          |                          ^
      114 |           result.getAutomationVariablesId()
      115 |         );
      116 |

      at ExecuteAutoFillUseCase.loadAndValidateXPaths (src/usecases/auto-fill/ExecuteAutoFillUseCase.ts:113:26)
      at ExecuteAutoFillUseCase.startNewExecution (src/usecases/auto-fill/ExecuteAutoFillUseCase.ts:124:39)
      at ExecuteAutoFillUseCase.execute (src/usecases/auto-fill/ExecuteAutoFillUseCase.ts:52:16)
      at Object.<anonymous> (tests/integration/page-transition-resume.integration.test.ts:963:28)

FAIL src/presentation/background/handlers/__tests__/ExecuteWebsiteFromPopupHandler.test.ts (19.131 s)
  ● ExecuteWebsiteFromPopupHandler › handle › should successfully execute website from popup

    expect(received).toBe(expected) // Object.is equality

    Expected: true
    Received: false

      86 |     );
      87 |   });
    > 88 |
         | ^
      89 |   describe('handle', () => {
      90 |     it('should successfully execute website from popup', async () => {
      91 |       const message: ExecuteWebsiteFromPopupRequest = {

      at Object.<anonymous> (src/presentation/background/handlers/__tests__/ExecuteWebsiteFromPopupHandler.test.ts:88:38)

  ● ExecuteWebsiteFromPopupHandler › handle › should return error when website has no startUrl

    expect(received).toContain(expected) // indexOf

    Expected substring: "startUrlが設定されていません"
    Received string:    "automationVariables?.getStatus is not a function"

      126 |     it('should return error when website not found', async () => {
      127 |       const message: ExecuteWebsiteFromPopupRequest = {
    > 128 |         action: MessageTypes.EXECUTE_WEBSITE_FROM_POPUP,
          |                                          ^
      129 |         websiteId: 'non_existent',
      130 |       };
      131 |

      at Object.<anonymous> (src/presentation/background/handlers/__tests__/ExecuteWebsiteFromPopupHandler.test.ts:128:42)

  ● ExecuteWebsiteFromPopupHandler › handle › should return error when tab creation fails

    expect(received).toBe(expected) // Object.is equality

    Expected: "新しいタブの作成に失敗しました"
    Received: "automationVariables?.getStatus is not a function"

      138 |       expect(mockLogger.error).toHaveBeenCalledWith(
      139 |         '[ExecuteWebsiteFromPopupHandler] Website not found',
    > 140 |         expect.any(Object)
          |                           ^
      141 |       );
      142 |     });
      143 |

      at Object.<anonymous> (src/presentation/background/handlers/__tests__/ExecuteWebsiteFromPopupHandler.test.ts:140:42)

  ● ExecuteWebsiteFromPopupHandler › handle › should handle auto-fill execution failure

    expect(received).toBe(expected) // Object.is equality

    Expected: "XPath not found"
    Received: "automationVariables?.getStatus is not a function"

      159 |
      160 |       const response: ExecuteWebsiteFromPopupResponse = await handler.handle(message);
    > 161 |
          | ^
      162 |       expect(response.success).toBe(false);
      163 |       expect(response.data?.error).toContain('startUrlが設定されていません');
      164 |       expect(mockLogger.error).toHaveBeenCalledWith(

      at Object.<anonymous> (src/presentation/background/handlers/__tests__/ExecuteWebsiteFromPopupHandler.test.ts:161:42)

  ● ExecuteWebsiteFromPopupHandler › handle › should log all execution steps

    expect(jest.fn()).toHaveBeenCalledWith(...expected)

    Expected: "[ExecuteWebsiteFromPopupHandler] Creating new tab", Any<Object>
    Received
           1: "[ExecuteWebsiteFromPopupHandler] Received request", {"websiteId": "website_123"}
           2: "[ExecuteWebsiteFromPopupHandler] Website loaded", {"name": "Test Website", "startUrl": "https://example.com"}

    Number of calls: 2

      191 |         action: MessageTypes.EXECUTE_WEBSITE_FROM_POPUP,
      192 |         websiteId: 'website_123',
    > 193 |       };
          |         ^
      194 |
      195 |       mockGetWebsiteByIdUseCase.execute.mockResolvedValue({ success: true, website: mockWebsite });
      196 |

      at Object.<anonymous> (src/presentation/background/handlers/__tests__/ExecuteWebsiteFromPopupHandler.test.ts:193:37)

PASS src/infrastructure/adapters/__tests__/SpreadsheetSyncAdapter.test.ts
PASS src/presentation/content-script/__tests__/AutoFillOverlay.test.ts (13.253 s)
PASS src/infrastructure/adapters/__tests__/ChromeAutoFillAdapter.comprehensive.test.ts (9.193 s)
PASS src/presentation/storage-sync-manager/__tests__/StorageSyncManagerCoordinator.test.ts (7.662 s)
PASS tests/e2e/MigrationWorkflow.e2e.test.ts
PASS src/infrastructure/auto-fill/__tests__/ChangeUrlActionExecutor.test.ts (7.07 s)
PASS src/presentation/storage-sync-manager/__tests__/StorageSyncManagerView.test.ts (6.595 s)
PASS src/infrastructure/adapters/__tests__/AxiosHttpClient.test.ts
PASS src/infrastructure/auto-fill/__tests__/SelectActionExecutor.test.ts
PASS src/usecases/sync/__tests__/ExecuteManualSyncUseCase.test.ts
PASS src/presentation/system-settings/__tests__/DataSyncManager.test.ts
PASS src/presentation/xpath-manager/__tests__/AutoFillExecutor.test.ts
PASS src/presentation/system-settings/__tests__/PermissionsSettingsManager.test.ts
PASS src/usecases/sync/__tests__/CreateSyncConfigUseCase.test.ts
PASS src/infrastructure/adapters/__tests__/ChromeContextMenuAdapter.test.ts
PASS src/presentation/content-script/__tests__/XPathDialog.test.ts
PASS src/infrastructure/adapters/__tests__/WebCryptoAdapter.test.ts
PASS src/presentation/popup/__tests__/SettingsModalManager.test.ts
PASS src/infrastructure/adapters/__tests__/SecurityIntegration.test.ts
PASS src/presentation/automation-variables-manager/__tests__/AutomationVariablesManagerView.test.ts
PASS src/infrastructure/repositories/__tests__/SecureRepositoryIntegration.test.ts
PASS tests/integration/MasterPasswordIntegration.test.ts
PASS src/presentation/xpath-manager/__tests__/ExportImportManager.test.ts
PASS src/infrastructure/adapters/__tests__/ChromeHttpClient.test.ts
PASS src/presentation/system-settings/__tests__/AppearanceSettingsManager.test.ts
PASS src/usecases/sync/__tests__/TestConnectionUseCase.test.ts
PASS src/infrastructure/adapters/__tests__/ChromeAutoFillAdapter.select.test.ts
PASS src/presentation/system-settings/__tests__/SystemSettingsPresenter.test.ts
PASS src/usecases/system-settings/__tests__/ExportSystemSettingsUseCase.test.ts
PASS src/infrastructure/auto-fill/__tests__/CancellationCoordinator.test.ts
PASS src/domain/entities/__tests__/SyncState.test.ts
PASS src/domain/values/__tests__/UnlockStatus.test.ts
PASS src/infrastructure/adapters/__tests__/SecureStorageAdapter.test.ts
PASS src/presentation/popup/__tests__/PopupCoordinator.test.ts
PASS src/usecases/storage/__tests__/UnlockStorageUseCase.test.ts
PASS src/presentation/xpath-manager/__tests__/XPathActionHandler.test.ts
PASS src/domain/services/__tests__/BatchProcessor.test.ts
PASS src/presentation/unlock/__tests__/UnlockPresenter.test.ts
PASS src/presentation/offscreen/__tests__/OffscreenPresenter.test.ts
  ● Console

    console.log
      [OffscreenPresenter] Initializing offscreen document

      at OffscreenPresenter.init (src/presentation/offscreen/OffscreenPresenter.ts:23:17)

    console.log
      [OffscreenPresenter] Message listener registered

      at OffscreenPresenter.init (src/presentation/offscreen/OffscreenPresenter.ts:47:17)

    console.log
      [OffscreenPresenter] Initializing offscreen document

      at OffscreenPresenter.init (src/presentation/offscreen/OffscreenPresenter.ts:23:17)

    console.log
      [OffscreenPresenter] Message listener registered

      at OffscreenPresenter.init (src/presentation/offscreen/OffscreenPresenter.ts:47:17)

    console.log
      [OffscreenPresenter] Starting recording {
        recorderId: 'rec-1',
        tabId: 123,
        config: { audio: true, video: true }
      }

      at OffscreenPresenter.handleStartRecording (src/presentation/offscreen/OffscreenPresenter.ts:54:17)

    console.log
      [OffscreenPresenter] Using stream ID from background { recorderId: 'rec-1', tabId: 123, streamId: 'stream-id' }

      at OffscreenPresenter.handleStartRecording (src/presentation/offscreen/OffscreenPresenter.ts:64:21)

    console.log
      [OffscreenPresenter] MediaRecorder started { recorderId: 'rec-1', state: 'recording' }

      at OffscreenPresenter.handleStartRecording (src/presentation/offscreen/OffscreenPresenter.ts:105:21)

    console.log
      [OffscreenPresenter] Starting recording {
        recorderId: 'rec-1',
        tabId: 123,
        config: { audio: true, video: true }
      }

      at OffscreenPresenter.handleStartRecording (src/presentation/offscreen/OffscreenPresenter.ts:54:17)

    console.log
      [OffscreenPresenter] Using stream ID from background { recorderId: 'rec-1', tabId: 123, streamId: 'stream-id' }

      at OffscreenPresenter.handleStartRecording (src/presentation/offscreen/OffscreenPresenter.ts:64:21)

    console.log
      [OffscreenPresenter] MediaRecorder started { recorderId: 'rec-1', state: 'recording' }

      at OffscreenPresenter.handleStartRecording (src/presentation/offscreen/OffscreenPresenter.ts:105:21)

    console.log
      [OffscreenPresenter] Initializing offscreen document

      at OffscreenPresenter.init (src/presentation/offscreen/OffscreenPresenter.ts:23:17)

    console.log
      [OffscreenPresenter] Message listener registered

      at OffscreenPresenter.init (src/presentation/offscreen/OffscreenPresenter.ts:47:17)

    console.log
      [OffscreenPresenter] Stopping recording { recorderId: 'rec-1' }

      at OffscreenPresenter.handleStopRecording (src/presentation/offscreen/OffscreenPresenter.ts:136:17)

    console.log
      [OffscreenPresenter] MediaRecorder stopped { recorderId: 'rec-1', chunksCount: 0 }

      at handleStop (src/presentation/offscreen/OffscreenPresenter.ts:147:25)

    console.log
      [OffscreenPresenter] Recording blob created { recorderId: 'rec-1', blobSize: 1024 }

      at handleStop (src/presentation/offscreen/OffscreenPresenter.ts:155:25)

    console.log
      [OffscreenPresenter] Initializing offscreen document

      at OffscreenPresenter.init (src/presentation/offscreen/OffscreenPresenter.ts:23:17)

    console.log
      [OffscreenPresenter] Message listener registered

      at OffscreenPresenter.init (src/presentation/offscreen/OffscreenPresenter.ts:47:17)

    console.log
      [OffscreenPresenter] Starting recording {
        recorderId: 'rec-1',
        tabId: 123,
        config: { audio: true, video: true, videoBitsPerSecond: 2500000 }
      }

      at OffscreenPresenter.handleStartRecording (src/presentation/offscreen/OffscreenPresenter.ts:54:17)

    console.log
      [OffscreenPresenter] Using stream ID from background { recorderId: 'rec-1', tabId: 123, streamId: 'stream-id' }

      at OffscreenPresenter.handleStartRecording (src/presentation/offscreen/OffscreenPresenter.ts:64:21)

    console.log
      [OffscreenPresenter] MediaRecorder started { recorderId: 'rec-1', state: 'recording' }

      at OffscreenPresenter.handleStartRecording (src/presentation/offscreen/OffscreenPresenter.ts:105:21)

    console.log
      [OffscreenPresenter] Starting recording {
        recorderId: 'rec-1',
        tabId: 123,
        config: { audio: true, video: true, videoBitsPerSecond: 2500000 }
      }

      at OffscreenPresenter.handleStartRecording (src/presentation/offscreen/OffscreenPresenter.ts:54:17)

    console.log
      [OffscreenPresenter] Using stream ID from background { recorderId: 'rec-1', tabId: 123, streamId: 'stream-id' }

      at OffscreenPresenter.handleStartRecording (src/presentation/offscreen/OffscreenPresenter.ts:64:21)

    console.log
      [OffscreenPresenter] MediaRecorder started { recorderId: 'rec-1', state: 'recording' }

      at OffscreenPresenter.handleStartRecording (src/presentation/offscreen/OffscreenPresenter.ts:105:21)

    console.log
      [OffscreenPresenter] Starting recording {
        recorderId: 'rec-1',
        tabId: 123,
        config: { audio: true, video: true, videoBitsPerSecond: 2500000 }
      }

      at OffscreenPresenter.handleStartRecording (src/presentation/offscreen/OffscreenPresenter.ts:54:17)

    console.log
      [OffscreenPresenter] Using stream ID from background { recorderId: 'rec-1', tabId: 123, streamId: 'stream-id' }

      at OffscreenPresenter.handleStartRecording (src/presentation/offscreen/OffscreenPresenter.ts:64:21)

    console.log
      [OffscreenPresenter] MediaRecorder started { recorderId: 'rec-1', state: 'recording' }

      at OffscreenPresenter.handleStartRecording (src/presentation/offscreen/OffscreenPresenter.ts:105:21)

    console.log
      [OffscreenPresenter] Recording chunk available { recorderId: 'rec-1', chunkSize: 100, totalChunks: 1 }

      at view.createMediaRecorder.console.error.recorderId (src/presentation/offscreen/OffscreenPresenter.ts:76:25)

    console.log
      [OffscreenPresenter] Starting recording {
        recorderId: 'rec-1',
        tabId: 123,
        config: { audio: true, video: true, videoBitsPerSecond: 2500000 }
      }

      at OffscreenPresenter.handleStartRecording (src/presentation/offscreen/OffscreenPresenter.ts:54:17)

    console.log
      [OffscreenPresenter] Using stream ID from background { recorderId: 'rec-1', tabId: 123, streamId: 'stream-id' }

      at OffscreenPresenter.handleStartRecording (src/presentation/offscreen/OffscreenPresenter.ts:64:21)

    console.log
      [OffscreenPresenter] MediaRecorder started { recorderId: 'rec-1', state: 'recording' }

      at OffscreenPresenter.handleStartRecording (src/presentation/offscreen/OffscreenPresenter.ts:105:21)

    console.error
      [OffscreenPresenter] MediaRecorder error { recorderId: 'rec-1', error: 'Test error' }

      82 |         tabId: request.tabId,
      83 |         streamId: request.streamId,
    > 84 |       });
         |          ^
      85 |
      86 |       // Store chunks for this recording
      87 |       const chunks: Blob[] = [];

      at src/presentation/offscreen/OffscreenPresenter.ts:84:25
      at Object.<anonymous> (src/presentation/offscreen/__tests__/OffscreenPresenter.test.ts:149:13)

    console.log
      [OffscreenPresenter] Starting recording {
        recorderId: 'rec-1',
        tabId: 123,
        config: { audio: true, video: true, videoBitsPerSecond: 2500000 }
      }

      at OffscreenPresenter.handleStartRecording (src/presentation/offscreen/OffscreenPresenter.ts:54:17)

    console.log
      [OffscreenPresenter] Using stream ID from background { recorderId: 'rec-1', tabId: 123, streamId: 'stream-id' }

      at OffscreenPresenter.handleStartRecording (src/presentation/offscreen/OffscreenPresenter.ts:64:21)

    console.log
      [OffscreenPresenter] MediaRecorder started { recorderId: 'rec-1', state: 'recording' }

      at OffscreenPresenter.handleStartRecording (src/presentation/offscreen/OffscreenPresenter.ts:105:21)

    console.log
      [OffscreenPresenter] Starting recording {
        recorderId: 'rec-1',
        tabId: 123,
        config: { audio: true, video: true, videoBitsPerSecond: 2500000 }
      }

      at OffscreenPresenter.handleStartRecording (src/presentation/offscreen/OffscreenPresenter.ts:54:17)

    console.error
      [OffscreenPresenter] Failed to start recording {
        recorderId: 'rec-1',
        tabId: 123,
        error: Error: Recording rec-1 already exists
            at OffscreenPresenter.handleStartRecording (/Users/takeya_ozawa/Downloads/auto-fill-tool/src/presentation/offscreen/OffscreenPresenter.ts:62:23)
            at Object.<anonymous> (/Users/takeya_ozawa/Downloads/auto-fill-tool/src/presentation/offscreen/__tests__/OffscreenPresenter.test.ts:158:36)
            at processTicksAndRejections (node:internal/process/task_queues:105:5)
      }

      116 |       );
      117 |
    > 118 |       // Store recording state
          |                     ^
      119 |       this.activeRecordings.set(request.recorderId, {
      120 |         recorderId: request.recorderId,
      121 |         recorder,

      at OffscreenPresenter.handleStartRecording (src/presentation/offscreen/OffscreenPresenter.ts:118:21)
      at Object.<anonymous> (src/presentation/offscreen/__tests__/OffscreenPresenter.test.ts:158:36)

    console.log
      [OffscreenPresenter] Starting recording {
        recorderId: 'rec-1',
        tabId: 123,
        config: { audio: true, video: true, videoBitsPerSecond: 2500000 }
      }

      at OffscreenPresenter.handleStartRecording (src/presentation/offscreen/OffscreenPresenter.ts:54:17)

    console.log
      [OffscreenPresenter] Using stream ID from background { recorderId: 'rec-1', tabId: 123, streamId: 'stream-id' }

      at OffscreenPresenter.handleStartRecording (src/presentation/offscreen/OffscreenPresenter.ts:64:21)

    console.error
      [OffscreenPresenter] Failed to start recording {
        recorderId: 'rec-1',
        tabId: 123,
        error: Error: Failed to create recorder
            at Object.<anonymous> (/Users/takeya_ozawa/Downloads/auto-fill-tool/src/presentation/offscreen/__tests__/OffscreenPresenter.test.ts:161:60)
            at Promise.then.completed (/Users/takeya_ozawa/Downloads/auto-fill-tool/node_modules/jest-circus/build/utils.js:298:28)
            at new Promise (<anonymous>)
            at callAsyncCircusFn (/Users/takeya_ozawa/Downloads/auto-fill-tool/node_modules/jest-circus/build/utils.js:231:10)
            at _callCircusTest (/Users/takeya_ozawa/Downloads/auto-fill-tool/node_modules/jest-circus/build/run.js:316:40)
            at processTicksAndRejections (node:internal/process/task_queues:105:5)
            at _runTest (/Users/takeya_ozawa/Downloads/auto-fill-tool/node_modules/jest-circus/build/run.js:252:3)
            at _runTestsForDescribeBlock (/Users/takeya_ozawa/Downloads/auto-fill-tool/node_modules/jest-circus/build/run.js:126:9)
            at _runTestsForDescribeBlock (/Users/takeya_ozawa/Downloads/auto-fill-tool/node_modules/jest-circus/build/run.js:121:9)
            at _runTestsForDescribeBlock (/Users/takeya_ozawa/Downloads/auto-fill-tool/node_modules/jest-circus/build/run.js:121:9)
            at run (/Users/takeya_ozawa/Downloads/auto-fill-tool/node_modules/jest-circus/build/run.js:71:3)
            at runAndTransformResultsToJestFormat (/Users/takeya_ozawa/Downloads/auto-fill-tool/node_modules/jest-circus/build/legacy-code-todo-rewrite/jestAdapterInit.js:122:21)
            at jestAdapter (/Users/takeya_ozawa/Downloads/auto-fill-tool/node_modules/jest-circus/build/legacy-code-todo-rewrite/jestAdapter.js:79:19)
            at runTestInternal (/Users/takeya_ozawa/Downloads/auto-fill-tool/node_modules/jest-runner/build/runTest.js:367:16)
            at runTest (/Users/takeya_ozawa/Downloads/auto-fill-tool/node_modules/jest-runner/build/runTest.js:444:34)
            at Object.worker (/Users/takeya_ozawa/Downloads/auto-fill-tool/node_modules/jest-runner/build/testWorker.js:106:12)
      }

      116 |       );
      117 |
    > 118 |       // Store recording state
          |                     ^
      119 |       this.activeRecordings.set(request.recorderId, {
      120 |         recorderId: request.recorderId,
      121 |         recorder,

      at OffscreenPresenter.handleStartRecording (src/presentation/offscreen/OffscreenPresenter.ts:118:21)
      at Object.<anonymous> (src/presentation/offscreen/__tests__/OffscreenPresenter.test.ts:162:13)

    console.log
      [OffscreenPresenter] Starting recording {
        recorderId: 'rec-1',
        tabId: 123,
        config: { audio: true, video: true, videoBitsPerSecond: 2500000 }
      }

      at OffscreenPresenter.handleStartRecording (src/presentation/offscreen/OffscreenPresenter.ts:54:17)

    console.log
      [OffscreenPresenter] Using stream ID from background { recorderId: 'rec-1', tabId: 123, streamId: 'stream-id' }

      at OffscreenPresenter.handleStartRecording (src/presentation/offscreen/OffscreenPresenter.ts:64:21)

    console.error
      [OffscreenPresenter] Failed to start recording { recorderId: 'rec-1', tabId: 123, error: 'String error' }

      116 |       );
      117 |
    > 118 |       // Store recording state
          |                     ^
      119 |       this.activeRecordings.set(request.recorderId, {
      120 |         recorderId: request.recorderId,
      121 |         recorder,

      at OffscreenPresenter.handleStartRecording (src/presentation/offscreen/OffscreenPresenter.ts:118:21)
      at Object.<anonymous> (src/presentation/offscreen/__tests__/OffscreenPresenter.test.ts:171:13)

    console.log
      [OffscreenPresenter] Starting recording {
        recorderId: 'rec-1',
        tabId: 123,
        config: { audio: true, video: true }
      }

      at OffscreenPresenter.handleStartRecording (src/presentation/offscreen/OffscreenPresenter.ts:54:17)

    console.log
      [OffscreenPresenter] Using stream ID from background { recorderId: 'rec-1', tabId: 123, streamId: 'stream-id' }

      at OffscreenPresenter.handleStartRecording (src/presentation/offscreen/OffscreenPresenter.ts:64:21)

    console.log
      [OffscreenPresenter] MediaRecorder started { recorderId: 'rec-1', state: 'recording' }

      at OffscreenPresenter.handleStartRecording (src/presentation/offscreen/OffscreenPresenter.ts:105:21)

    console.log
      [OffscreenPresenter] Stopping recording { recorderId: 'rec-1' }

      at OffscreenPresenter.handleStopRecording (src/presentation/offscreen/OffscreenPresenter.ts:136:17)

    console.log
      [OffscreenPresenter] MediaRecorder stopped { recorderId: 'rec-1', chunksCount: 0 }

      at handleStop (src/presentation/offscreen/OffscreenPresenter.ts:147:25)

    console.log
      [OffscreenPresenter] Recording blob created { recorderId: 'rec-1', blobSize: 1024 }

      at handleStop (src/presentation/offscreen/OffscreenPresenter.ts:155:25)

    console.log
      [OffscreenPresenter] Starting recording {
        recorderId: 'rec-1',
        tabId: 123,
        config: { audio: true, video: true }
      }

      at OffscreenPresenter.handleStartRecording (src/presentation/offscreen/OffscreenPresenter.ts:54:17)

    console.log
      [OffscreenPresenter] Using stream ID from background { recorderId: 'rec-1', tabId: 123, streamId: 'stream-id' }

      at OffscreenPresenter.handleStartRecording (src/presentation/offscreen/OffscreenPresenter.ts:64:21)

    console.log
      [OffscreenPresenter] MediaRecorder started { recorderId: 'rec-1', state: 'recording' }

      at OffscreenPresenter.handleStartRecording (src/presentation/offscreen/OffscreenPresenter.ts:105:21)

    console.log
      [OffscreenPresenter] Stopping recording { recorderId: 'rec-1' }

      at OffscreenPresenter.handleStopRecording (src/presentation/offscreen/OffscreenPresenter.ts:136:17)

    console.log
      [OffscreenPresenter] MediaRecorder stopped { recorderId: 'rec-1', chunksCount: 0 }

      at handleStop (src/presentation/offscreen/OffscreenPresenter.ts:147:25)

    console.log
      [OffscreenPresenter] Recording blob created { recorderId: 'rec-1', blobSize: 1024 }

      at handleStop (src/presentation/offscreen/OffscreenPresenter.ts:155:25)

    console.log
      [OffscreenPresenter] Starting recording {
        recorderId: 'rec-1',
        tabId: 123,
        config: { audio: true, video: true }
      }

      at OffscreenPresenter.handleStartRecording (src/presentation/offscreen/OffscreenPresenter.ts:54:17)

    console.log
      [OffscreenPresenter] Using stream ID from background { recorderId: 'rec-1', tabId: 123, streamId: 'stream-id' }

      at OffscreenPresenter.handleStartRecording (src/presentation/offscreen/OffscreenPresenter.ts:64:21)

    console.log
      [OffscreenPresenter] MediaRecorder started { recorderId: 'rec-1', state: 'recording' }

      at OffscreenPresenter.handleStartRecording (src/presentation/offscreen/OffscreenPresenter.ts:105:21)

    console.log
      [OffscreenPresenter] Stopping recording { recorderId: 'rec-1' }

      at OffscreenPresenter.handleStopRecording (src/presentation/offscreen/OffscreenPresenter.ts:136:17)

    console.log
      [OffscreenPresenter] MediaRecorder stopped { recorderId: 'rec-1', chunksCount: 0 }

      at handleStop (src/presentation/offscreen/OffscreenPresenter.ts:147:25)

    console.log
      [OffscreenPresenter] Recording blob created { recorderId: 'rec-1', blobSize: 1024 }

      at handleStop (src/presentation/offscreen/OffscreenPresenter.ts:155:25)

    console.log
      [OffscreenPresenter] Starting recording {
        recorderId: 'rec-1',
        tabId: 123,
        config: { audio: true, video: true }
      }

      at OffscreenPresenter.handleStartRecording (src/presentation/offscreen/OffscreenPresenter.ts:54:17)

    console.log
      [OffscreenPresenter] Using stream ID from background { recorderId: 'rec-1', tabId: 123, streamId: 'stream-id' }

      at OffscreenPresenter.handleStartRecording (src/presentation/offscreen/OffscreenPresenter.ts:64:21)

    console.log
      [OffscreenPresenter] MediaRecorder started { recorderId: 'rec-1', state: 'recording' }

      at OffscreenPresenter.handleStartRecording (src/presentation/offscreen/OffscreenPresenter.ts:105:21)

    console.log
      [OffscreenPresenter] Stopping recording { recorderId: 'rec-1' }

      at OffscreenPresenter.handleStopRecording (src/presentation/offscreen/OffscreenPresenter.ts:136:17)

    console.log
      [OffscreenPresenter] MediaRecorder stopped { recorderId: 'rec-1', chunksCount: 0 }

      at handleStop (src/presentation/offscreen/OffscreenPresenter.ts:147:25)

    console.log
      [OffscreenPresenter] Recording blob created { recorderId: 'rec-1', blobSize: 1024 }

      at handleStop (src/presentation/offscreen/OffscreenPresenter.ts:155:25)

    console.log
      [OffscreenPresenter] Stopping recording { recorderId: 'rec-1' }

      at OffscreenPresenter.handleStopRecording (src/presentation/offscreen/OffscreenPresenter.ts:136:17)

    console.log
      [OffscreenPresenter] Starting recording {
        recorderId: 'rec-1',
        tabId: 123,
        config: { audio: true, video: true }
      }

      at OffscreenPresenter.handleStartRecording (src/presentation/offscreen/OffscreenPresenter.ts:54:17)

    console.log
      [OffscreenPresenter] Using stream ID from background { recorderId: 'rec-1', tabId: 123, streamId: 'stream-id' }

      at OffscreenPresenter.handleStartRecording (src/presentation/offscreen/OffscreenPresenter.ts:64:21)

    console.log
      [OffscreenPresenter] MediaRecorder started { recorderId: 'rec-1', state: 'recording' }

      at OffscreenPresenter.handleStartRecording (src/presentation/offscreen/OffscreenPresenter.ts:105:21)

    console.log
      [OffscreenPresenter] Stopping recording { recorderId: 'non-existent' }

      at OffscreenPresenter.handleStopRecording (src/presentation/offscreen/OffscreenPresenter.ts:136:17)

    console.log
      [OffscreenPresenter] Starting recording {
        recorderId: 'rec-1',
        tabId: 123,
        config: { audio: true, video: true }
      }

      at OffscreenPresenter.handleStartRecording (src/presentation/offscreen/OffscreenPresenter.ts:54:17)

    console.log
      [OffscreenPresenter] Using stream ID from background { recorderId: 'rec-1', tabId: 123, streamId: 'stream-id' }

      at OffscreenPresenter.handleStartRecording (src/presentation/offscreen/OffscreenPresenter.ts:64:21)

    console.log
      [OffscreenPresenter] MediaRecorder started { recorderId: 'rec-1', state: 'recording' }

      at OffscreenPresenter.handleStartRecording (src/presentation/offscreen/OffscreenPresenter.ts:105:21)

    console.log
      [OffscreenPresenter] Stopping recording { recorderId: 'rec-1' }

      at OffscreenPresenter.handleStopRecording (src/presentation/offscreen/OffscreenPresenter.ts:136:17)

    console.log
      [OffscreenPresenter] MediaRecorder stopped { recorderId: 'rec-1', chunksCount: 0 }

      at handleStop (src/presentation/offscreen/OffscreenPresenter.ts:147:25)

    console.log
      [OffscreenPresenter] Recording blob created { recorderId: 'rec-1', blobSize: 1024 }

      at handleStop (src/presentation/offscreen/OffscreenPresenter.ts:155:25)

    console.log
      [OffscreenPresenter] Starting recording {
        recorderId: 'rec-1',
        tabId: 123,
        config: { audio: true, video: true }
      }

      at OffscreenPresenter.handleStartRecording (src/presentation/offscreen/OffscreenPresenter.ts:54:17)

    console.log
      [OffscreenPresenter] Using stream ID from background { recorderId: 'rec-1', tabId: 123, streamId: 'stream-1' }

      at OffscreenPresenter.handleStartRecording (src/presentation/offscreen/OffscreenPresenter.ts:64:21)

    console.log
      [OffscreenPresenter] MediaRecorder started { recorderId: 'rec-1', state: 'recording' }

      at OffscreenPresenter.handleStartRecording (src/presentation/offscreen/OffscreenPresenter.ts:105:21)

    console.log
      [OffscreenPresenter] Starting recording {
        recorderId: 'rec-2',
        tabId: 456,
        config: { audio: true, video: false }
      }

      at OffscreenPresenter.handleStartRecording (src/presentation/offscreen/OffscreenPresenter.ts:54:17)

    console.log
      [OffscreenPresenter] Using stream ID from background { recorderId: 'rec-2', tabId: 456, streamId: 'stream-2' }

      at OffscreenPresenter.handleStartRecording (src/presentation/offscreen/OffscreenPresenter.ts:64:21)

    console.log
      [OffscreenPresenter] MediaRecorder started { recorderId: 'rec-2', state: 'recording' }

      at OffscreenPresenter.handleStartRecording (src/presentation/offscreen/OffscreenPresenter.ts:105:21)

    console.log
      [OffscreenPresenter] Starting recording {
        recorderId: 'rec-1',
        tabId: 123,
        config: { audio: true, video: true }
      }

      at OffscreenPresenter.handleStartRecording (src/presentation/offscreen/OffscreenPresenter.ts:54:17)

    console.log
      [OffscreenPresenter] Using stream ID from background { recorderId: 'rec-1', tabId: 123, streamId: 'stream-1' }

      at OffscreenPresenter.handleStartRecording (src/presentation/offscreen/OffscreenPresenter.ts:64:21)

    console.log
      [OffscreenPresenter] MediaRecorder started { recorderId: 'rec-1', state: 'recording' }

      at OffscreenPresenter.handleStartRecording (src/presentation/offscreen/OffscreenPresenter.ts:105:21)

    console.log
      [OffscreenPresenter] Starting recording {
        recorderId: 'rec-2',
        tabId: 456,
        config: { audio: true, video: false }
      }

      at OffscreenPresenter.handleStartRecording (src/presentation/offscreen/OffscreenPresenter.ts:54:17)

    console.log
      [OffscreenPresenter] Using stream ID from background { recorderId: 'rec-2', tabId: 456, streamId: 'stream-2' }

      at OffscreenPresenter.handleStartRecording (src/presentation/offscreen/OffscreenPresenter.ts:64:21)

    console.log
      [OffscreenPresenter] MediaRecorder started { recorderId: 'rec-2', state: 'recording' }

      at OffscreenPresenter.handleStartRecording (src/presentation/offscreen/OffscreenPresenter.ts:105:21)

    console.log
      [OffscreenPresenter] Stopping recording { recorderId: 'rec-1' }

      at OffscreenPresenter.handleStopRecording (src/presentation/offscreen/OffscreenPresenter.ts:136:17)

    console.log
      [OffscreenPresenter] MediaRecorder stopped { recorderId: 'rec-1', chunksCount: 0 }

      at handleStop (src/presentation/offscreen/OffscreenPresenter.ts:147:25)

    console.log
      [OffscreenPresenter] Recording blob created { recorderId: 'rec-1', blobSize: 1024 }

      at handleStop (src/presentation/offscreen/OffscreenPresenter.ts:155:25)

    console.log
      [OffscreenPresenter] Stopping recording { recorderId: 'rec-2' }

      at OffscreenPresenter.handleStopRecording (src/presentation/offscreen/OffscreenPresenter.ts:136:17)

    console.log
      [OffscreenPresenter] MediaRecorder stopped { recorderId: 'rec-2', chunksCount: 0 }

      at handleStop (src/presentation/offscreen/OffscreenPresenter.ts:147:25)

    console.log
      [OffscreenPresenter] Recording blob created { recorderId: 'rec-2', blobSize: 1024 }

      at handleStop (src/presentation/offscreen/OffscreenPresenter.ts:155:25)

PASS src/usecases/auto-fill/__tests__/ExecuteAutoFillUseCase.test.ts
PASS src/infrastructure/factories/__tests__/RepositoryFactory.test.ts
PASS src/presentation/popup/__tests__/ModalManager.test.ts
PASS src/domain/entities/__tests__/BatchConfig.test.ts
PASS src/presentation/xpath-manager/__tests__/XPathManagerView.test.ts
PASS src/infrastructure/repositories/__tests__/ChromeStorageSyncHistoryRepository.test.ts
PASS src/presentation/system-settings/__tests__/GeneralSettingsManager.test.ts
PASS src/presentation/xpath-manager/__tests__/WebsiteSelectManager.test.ts
PASS tests/performance/PageTransitionPerformance.performance.test.ts (11.891 s)
  ● Console

    console.log
      
      📊 Performance Test Results:

      at Object.<anonymous> (tests/performance/PageTransitionPerformance.performance.test.ts:258:21)

    console.log
         Without progress saving: 1111.74ms

      at Object.<anonymous> (tests/performance/PageTransitionPerformance.performance.test.ts:259:21)

    console.log
         With progress saving: 1129.15ms

      at Object.<anonymous> (tests/performance/PageTransitionPerformance.performance.test.ts:260:21)

    console.log
         Overhead: 17.42ms (1.57%)

      at Object.<anonymous> (tests/performance/PageTransitionPerformance.performance.test.ts:261:21)

    console.log
         CHANGE_URL actions: 10

      at Object.<anonymous> (tests/performance/PageTransitionPerformance.performance.test.ts:262:21)

    console.log
         Storage writes: 10 (expected: 10)

      at Object.<anonymous> (tests/performance/PageTransitionPerformance.performance.test.ts:263:21)

    console.log
      
      📝 Storage Write Count Test:

      at Object.<anonymous> (tests/performance/PageTransitionPerformance.performance.test.ts:321:21)

    console.log
         Total steps: 50

      at Object.<anonymous> (tests/performance/PageTransitionPerformance.performance.test.ts:322:21)

    console.log
         CHANGE_URL actions: 5

      at Object.<anonymous> (tests/performance/PageTransitionPerformance.performance.test.ts:323:21)

    console.log
         Storage writes: 5

      at Object.<anonymous> (tests/performance/PageTransitionPerformance.performance.test.ts:324:21)

    console.log
         Match: ✅

      at Object.<anonymous> (tests/performance/PageTransitionPerformance.performance.test.ts:325:21)

    console.log
      
      ⏱️  Overhead Per CHANGE_URL Action:

      at Object.<anonymous> (tests/performance/PageTransitionPerformance.performance.test.ts:403:21)

    console.log
         Total overhead: 33.31ms

      at Object.<anonymous> (tests/performance/PageTransitionPerformance.performance.test.ts:404:21)

    console.log
         CHANGE_URL actions: 10

      at Object.<anonymous> (tests/performance/PageTransitionPerformance.performance.test.ts:405:21)

    console.log
         Overhead per action: 3.33ms

      at Object.<anonymous> (tests/performance/PageTransitionPerformance.performance.test.ts:406:21)

    console.log
         Expected range: 1-5ms

      at Object.<anonymous> (tests/performance/PageTransitionPerformance.performance.test.ts:407:21)

    console.log
         Within range: ✅

      at Object.<anonymous> (tests/performance/PageTransitionPerformance.performance.test.ts:408:21)

PASS src/presentation/storage-sync-manager/__tests__/StorageSyncManagerPresenter.test.ts
PASS src/presentation/automation-variables-manager/__tests__/AutomationVariablesManagerController.test.ts
PASS src/presentation/security-log-viewer/__tests__/SecurityLogViewerView.test.ts
PASS src/presentation/xpath-manager/__tests__/XPathEditModalManager.test.ts
PASS src/presentation/unlock/__tests__/UnlockView.test.ts
PASS src/domain/entities/__tests__/Website.test.ts
PASS src/presentation/xpath-manager/__tests__/VariableManager.test.ts
PASS src/presentation/popup/__tests__/WebsiteListPresenter.test.ts
PASS src/domain/entities/__tests__/DataTransformer.test.ts
PASS src/presentation/content-script/__tests__/ContentScriptPresenter.test.ts
PASS src/presentation/components/__tests__/TabManager.test.ts
PASS src/usecases/storage/__tests__/MigrateToSecureStorageUseCase.test.ts
PASS src/usecases/xpaths/__tests__/XPathUseCases.test.ts
PASS src/domain/services/__tests__/DefaultConflictResolver.test.ts
PASS src/infrastructure/mappers/__tests__/AutomationVariablesMapper.test.ts
PASS src/domain/constants/__tests__/ActionPatterns.test.ts
PASS src/presentation/system-settings/__tests__/SystemSettingsView.test.ts
PASS src/infrastructure/adapters/__tests__/I18nAdapter.test.ts
PASS src/infrastructure/auto-fill/__tests__/TimeoutManager.test.ts
PASS src/presentation/common/__tests__/DataBinder.test.ts
PASS src/presentation/background/handlers/__tests__/CancelAutoFillHandler.test.ts
PASS src/usecases/sync/__tests__/UpdateSyncConfigUseCase.test.ts
PASS src/presentation/system-settings/__tests__/RecordingSettingsManager.test.ts
PASS src/domain/services/__tests__/DataTransformationService.test.ts
PASS src/presentation/master-password-setup/__tests__/MasterPasswordSetupView.test.ts
PASS src/presentation/system-settings/__tests__/SystemSettingsCoordinator.test.ts
PASS tests/fixtures/__tests__/TestDataFactories.test.ts
PASS src/infrastructure/adapters/__tests__/JSONPathDataMapper.test.ts
PASS src/presentation/background/__tests__/XPathContextMenuHandler.test.ts
PASS src/presentation/popup/__tests__/WebsiteActionHandler.test.ts
PASS src/presentation/xpath-manager/__tests__/XPathManagerPresenter.test.ts
PASS src/infrastructure/adapters/__tests__/NotionSyncAdapter.test.ts
PASS src/domain/values/__tests__/CommonPasswordDictionary.test.ts
PASS src/domain/services/__tests__/RetryExecutor.test.ts
PASS src/usecases/sync/__tests__/ExecuteScheduledSyncUseCase.test.ts
PASS src/domain/values/__tests__/PasswordEntropy.test.ts
PASS src/presentation/common/__tests__/TemplateLoader.test.ts
PASS src/domain/entities/__tests__/SyncHistory.test.ts
PASS src/usecases/sync/__tests__/ListSyncConfigsUseCase.test.ts
PASS src/domain/entities/__tests__/TabRecording.test.ts
PASS src/usecases/websites/__tests__/SaveWebsiteWithAutomationVariablesUseCase.test.ts
PASS src/usecases/sync/__tests__/ValidateSyncConfigUseCase.test.ts
PASS src/usecases/websites/__tests__/DeleteWebsiteUseCase.test.ts
PASS src/presentation/content-script/handlers/__tests__/GetXPathHandler.test.ts
PASS src/domain/entities/__tests__/RetryPolicy.test.ts
PASS src/presentation/master-password-setup/__tests__/MasterPasswordSetupPresenter.test.ts
PASS src/domain/entities/__tests__/SyncResult.test.ts
PASS src/domain/services/__tests__/StepValidationService.test.ts
PASS src/infrastructure/mappers/__tests__/JsonPathDataMapper.test.ts
PASS src/domain/values/__tests__/MasterPasswordRequirements.test.ts
PASS src/domain/entities/__tests__/AutomationVariables.test.ts
PASS src/domain/entities/__tests__/AutomationResult.test.ts
PASS src/infrastructure/auto-fill/__tests__/InputActionExecutor.test.ts
PASS src/infrastructure/repositories/__tests__/SecureSystemSettingsRepository.test.ts
PASS src/infrastructure/auto-fill/__tests__/JudgeActionExecutor.test.ts
PASS src/usecases/sync/__tests__/ExecuteReceiveDataUseCase.test.ts
PASS src/infrastructure/repositories/__tests__/SecureAutomationVariablesRepository.test.ts
PASS src/infrastructure/messaging/__tests__/MessageRouter.test.ts
  ● Console

    console.debug
      [08:49:31.298] [TestRouter] [DEBUG] Registered handler for action: executeAutoFill

      at ConsoleLogger.debug (src/infrastructure/loggers/ConsoleLogger.ts:17:21)

    console.info
      [08:49:31.299] [TestRouter] [INFO] Message router started listening

      at ConsoleLogger.info (src/infrastructure/loggers/ConsoleLogger.ts:23:21)

PASS src/infrastructure/repositories/__tests__/SecureXPathRepository.test.ts
PASS src/presentation/security-log-viewer/__tests__/SecurityLogViewerPresenter.test.ts
PASS src/usecases/system-settings/__tests__/ResetSystemSettingsUseCase.test.ts
PASS src/usecases/automation-variables/__tests__/MigrateAutomationVariablesStorageUseCase.test.ts
PASS src/domain/services/__tests__/CSVValidationService.test.ts
PASS src/usecases/sync/__tests__/ExecuteSendDataUseCase.test.ts
PASS src/infrastructure/repositories/__tests__/ChromeStorageAutomationVariablesRepository.test.ts
PASS src/infrastructure/mappers/__tests__/XPathCollectionMapper.test.ts
PASS src/infrastructure/adapters/__tests__/PapaParseAdapter.test.ts
PASS src/presentation/background/handlers/__tests__/ExecuteAutoFillHandler.test.ts
PASS src/domain/entities/__tests__/SystemSettings.test.ts
PASS src/domain/services/__tests__/PasswordValidator.test.ts
PASS src/usecases/xpaths/__tests__/SaveXPathUseCase.test.ts
PASS src/domain/constants/__tests__/StorageKeys.test.ts
PASS src/usecases/websites/__tests__/UpdateWebsiteStatusUseCase.test.ts
PASS src/usecases/system-settings/__tests__/ImportSystemSettingsUseCase.test.ts
PASS src/domain/services/__tests__/SessionManager.test.ts
PASS src/domain/entities/__tests__/MasterPasswordPolicy.test.ts
PASS src/infrastructure/mappers/__tests__/WebsiteCollectionMapper.test.ts
PASS src/usecases/storage/__tests__/ExportStorageSyncConfigsUseCase.test.ts
PASS src/infrastructure/adapters/__tests__/PermissionManager.test.ts
PASS tests/integration/ExportImportFlow.test.ts
PASS src/infrastructure/adapters/__tests__/ChromeStorageLogAggregatorAdapter.test.ts
PASS src/usecases/system-settings/__tests__/UpdateSystemSettingsUseCase.test.ts
PASS src/usecases/storage/__tests__/CheckUnlockStatusUseCase.test.ts
PASS src/infrastructure/repositories/__tests__/ChromeStorageStorageSyncConfigRepository.test.ts
PASS src/infrastructure/loggers/__tests__/ConsoleLogger.test.ts
PASS src/infrastructure/auto-fill/__tests__/CheckboxActionExecutor.test.ts
PASS src/usecases/sync/__tests__/GetSyncHistoriesUseCase.test.ts
PASS src/infrastructure/auto-fill/__tests__/ClickActionExecutor.test.ts
PASS src/infrastructure/repositories/__tests__/SecureWebsiteRepository.test.ts
PASS src/domain/services/__tests__/RetryPolicyService.test.ts
PASS src/domain/services/__tests__/LockoutManager.test.ts
PASS src/usecases/storage/__tests__/LockStorageUseCase.test.ts
PASS src/domain/entities/__tests__/AutoFillEvent.test.ts
PASS src/domain/services/__tests__/ProgressTrackingService.test.ts
PASS src/domain/services/__tests__/URLMatchingService.test.ts
PASS src/domain/utils/__tests__/SyncConfigUtils.test.ts
PASS src/usecases/sync/__tests__/CleanupSyncHistoriesUseCase.test.ts
PASS src/infrastructure/mappers/__tests__/SystemSettingsMapper.test.ts
PASS src/domain/events/events/__tests__/SyncEvents.test.ts
PASS src/domain/events/events/__tests__/AutoFillEvents.test.ts
PASS src/presentation/content-script/__tests__/ContentScriptView.test.ts
PASS src/domain/constants/__tests__/SelectPattern.test.ts
PASS src/usecases/sync/__tests__/ExportCSVUseCase.test.ts
PASS src/usecases/system-settings/__tests__/GetSystemSettingsUseCase.test.ts
PASS src/presentation/offscreen/__tests__/OffscreenView.test.ts
  ● Console

    console.log
      [OffscreenView] Tab stream captured { streamId: 'test-stream-id', audioTracks: 1, videoTracks: 1 }

      at OffscreenView.createMediaRecorder (src/presentation/offscreen/OffscreenView.ts:36:17)

    console.log
      [OffscreenView] MediaRecorder created { mimeType: 'video/webm;codecs=vp9', videoBitsPerSecond: 2500000 }

      at OffscreenView.createMediaRecorder (src/presentation/offscreen/OffscreenView.ts:60:17)

    console.log
      [OffscreenView] Tab stream captured { streamId: 'test-stream-id', audioTracks: 1, videoTracks: 1 }

      at OffscreenView.createMediaRecorder (src/presentation/offscreen/OffscreenView.ts:36:17)

    console.log
      [OffscreenView] MediaRecorder created { mimeType: 'video/webm;codecs=vp9', videoBitsPerSecond: 2500000 }

      at OffscreenView.createMediaRecorder (src/presentation/offscreen/OffscreenView.ts:60:17)

    console.log
      [OffscreenView] Tab stream captured { streamId: 'test-stream-id', audioTracks: 1, videoTracks: 1 }

      at OffscreenView.createMediaRecorder (src/presentation/offscreen/OffscreenView.ts:36:17)

    console.log
      [OffscreenView] MediaRecorder created { mimeType: 'video/webm;codecs=vp9', videoBitsPerSecond: 2500000 }

      at OffscreenView.createMediaRecorder (src/presentation/offscreen/OffscreenView.ts:60:17)

    console.log
      [OffscreenView] Tab stream captured { streamId: 'test-stream-id', audioTracks: 1, videoTracks: 1 }

      at OffscreenView.createMediaRecorder (src/presentation/offscreen/OffscreenView.ts:36:17)

    console.log
      [OffscreenView] MediaRecorder created { mimeType: 'video/webm;codecs=vp9', videoBitsPerSecond: 2500000 }

      at OffscreenView.createMediaRecorder (src/presentation/offscreen/OffscreenView.ts:60:17)

    console.log
      [OffscreenView] Tab stream captured { streamId: 'test-stream-id', audioTracks: 1, videoTracks: 1 }

      at OffscreenView.createMediaRecorder (src/presentation/offscreen/OffscreenView.ts:36:17)

    console.log
      [OffscreenView] MediaRecorder created { mimeType: 'video/webm;codecs=vp9', videoBitsPerSecond: 2500000 }

      at OffscreenView.createMediaRecorder (src/presentation/offscreen/OffscreenView.ts:60:17)

    console.log
      [OffscreenView] Tab stream captured { streamId: 'test-stream-id', audioTracks: 1, videoTracks: 1 }

      at OffscreenView.createMediaRecorder (src/presentation/offscreen/OffscreenView.ts:36:17)

    console.log
      [OffscreenView] MediaRecorder created { mimeType: 'video/webm;codecs=vp9', videoBitsPerSecond: 2500000 }

      at OffscreenView.createMediaRecorder (src/presentation/offscreen/OffscreenView.ts:60:17)

    console.log
      [OffscreenView] Tab stream captured { streamId: 'test-stream-id', audioTracks: 1, videoTracks: 1 }

      at OffscreenView.createMediaRecorder (src/presentation/offscreen/OffscreenView.ts:36:17)

    console.log
      [OffscreenView] MediaRecorder created { mimeType: 'video/webm;codecs=vp9', videoBitsPerSecond: 2500000 }

      at OffscreenView.createMediaRecorder (src/presentation/offscreen/OffscreenView.ts:60:17)

    console.log
      [OffscreenView] Tab stream captured { streamId: 'test-stream-id', audioTracks: 1, videoTracks: 1 }

      at OffscreenView.createMediaRecorder (src/presentation/offscreen/OffscreenView.ts:36:17)

    console.log
      [OffscreenView] MediaRecorder created { mimeType: 'video/webm;codecs=vp9', videoBitsPerSecond: 2500000 }

      at OffscreenView.createMediaRecorder (src/presentation/offscreen/OffscreenView.ts:60:17)

    console.error
      [OffscreenView] MediaRecorder error Event { isTrusted: [Getter] }

      55 |     const options: MediaRecorderOptions = {
      56 |       mimeType: 'video/webm;codecs=vp9',
    > 57 |     };
         |       ^
      58 |
      59 |     if (config.videoBitsPerSecond) {
      60 |       options.videoBitsPerSecond = config.videoBitsPerSecond;

      at Object.recorder.onerror (src/presentation/offscreen/OffscreenView.ts:57:21)
      at Object.<anonymous> (src/presentation/offscreen/__tests__/OffscreenView.test.ts:152:31)

    console.log
      [OffscreenView] MediaRecorder started { state: 'inactive' }

      at OffscreenView.startRecording (src/presentation/offscreen/OffscreenView.ts:71:17)

    console.log
      [OffscreenView] MediaRecorder started { state: 'inactive' }

      at OffscreenView.startRecording (src/presentation/offscreen/OffscreenView.ts:71:17)

    console.log
      [OffscreenView] MediaStream tracks stopped

      at OffscreenView.stopStream (src/presentation/offscreen/OffscreenView.ts:93:17)

    console.log
      [OffscreenView] Blob created { size: 600, chunksCount: 3 }

      at OffscreenView.createBlob (src/presentation/offscreen/OffscreenView.ts:100:17)

    console.log
      [OffscreenView] Blob created { size: 0, chunksCount: 0 }

      at OffscreenView.createBlob (src/presentation/offscreen/OffscreenView.ts:100:17)

PASS src/infrastructure/repositories/__tests__/ChromeStorageAutomationResultRepository.test.ts
PASS src/infrastructure/adapters/__tests__/BrowserXPathGenerationAdapter.test.ts
PASS src/domain/services/__tests__/XPathSelectionService.test.ts
PASS src/infrastructure/adapters/__tests__/BrowserSyncStateNotifier.test.ts
PASS src/domain/entities/__tests__/CheckerState.test.ts
PASS src/domain/entities/__tests__/StorageSyncConfig.test.ts
PASS src/usecases/sync/__tests__/DeleteSyncConfigUseCase.test.ts
PASS src/domain/constants/__tests__/ActionType.test.ts
PASS src/usecases/storage/__tests__/GetAllStorageSyncConfigsUseCase.test.ts
PASS src/domain/services/__tests__/NoOpLogger.test.ts
PASS src/domain/services/__tests__/VariableSubstitutionService.test.ts
PASS src/infrastructure/auto-fill/__tests__/GetValueActionExecutor.test.ts
PASS src/domain/entities/__tests__/LogEntry.test.ts
PASS src/usecases/xpaths/__tests__/GetXPathsByWebsiteIdUseCase.test.ts
PASS src/domain/events/__tests__/DomainEvent.test.ts
PASS src/infrastructure/repositories/__tests__/ChromeStorageXPathRepository.test.ts
PASS src/infrastructure/messaging/__tests__/MessageDispatcher.test.ts
PASS src/domain/constants/__tests__/SessionConfig.test.ts
PASS src/domain/values/__tests__/PasswordStrength.test.ts
PASS src/domain/services/__tests__/WebsiteMigrationService.test.ts
PASS src/usecases/websites/__tests__/UpdateWebsiteUseCase.test.ts
PASS src/usecases/websites/__tests__/GetWebsiteByIdUseCase.test.ts
PASS src/domain/entities/__tests__/WebsiteCollection.test.ts
PASS src/usecases/automation-variables/__tests__/GetLatestAutomationResultUseCase.test.ts
PASS src/infrastructure/adapters/__tests__/ChromeStorageLockoutStorage.test.ts
PASS tests/helpers/__tests__/MockLogger.test.ts
PASS src/domain/events/events/__tests__/XPathEvents.test.ts
PASS src/usecases/automation-variables/__tests__/SaveAutomationResultUseCase.test.ts
PASS src/domain/services/__tests__/ActionTypeDetectorService.test.ts
PASS src/domain/constants/__tests__/InputPattern.test.ts
PASS src/usecases/sync/__tests__/ImportCSVUseCase.test.ts
PASS src/usecases/automation-variables/__tests__/GetAutomationResultHistoryUseCase.test.ts
PASS src/domain/services/__tests__/SecurityEventLogger.test.ts
PASS src/domain/entities/__tests__/Variable.test.ts
PASS src/usecases/websites/__tests__/SaveWebsiteUseCase.test.ts
PASS src/usecases/automation-variables/__tests__/ImportAutomationVariablesUseCase.test.ts
PASS src/domain/services/__tests__/InputPatternService.test.ts
PASS src/infrastructure/auto-fill/__tests__/RetryController.test.ts
PASS src/domain/values/__tests__/result.value.test.ts
PASS src/usecases/xpaths/__tests__/DuplicateXPathUseCase.test.ts
PASS src/domain/constants/__tests__/PathPattern.test.ts
PASS src/usecases/websites/__tests__/ExportWebsitesUseCase.test.ts
PASS src/usecases/automation-variables/__tests__/GetAutomationVariablesByIdUseCase.test.ts
PASS src/usecases/automation-variables/__tests__/SaveAutomationVariablesUseCase.test.ts
PASS src/usecases/automation-variables/__tests__/DuplicateAutomationVariablesUseCase.test.ts
PASS src/infrastructure/mappers/__tests__/StorageSyncConfigMapper.test.ts
PASS src/domain/events/__tests__/EventBus.test.ts
PASS src/usecases/storage/__tests__/InitializeMasterPasswordUseCase.test.ts
PASS src/usecases/automation-variables/__tests__/GetAllAutomationVariablesUseCase.test.ts
PASS src/utils/__tests__/dateFormatter.test.ts
PASS tests/integration/ImportValidation.test.ts
PASS src/domain/events/events/__tests__/WebsiteEvents.test.ts
PASS src/infrastructure/repositories/__tests__/ChromeStorageSystemSettingsRepository.test.ts
PASS src/presentation/content-script/handlers/__tests__/ShowXPathDialogHandler.test.ts
PASS src/infrastructure/loggers/__tests__/LoggerFactory.test.ts
PASS src/usecases/automation-variables/__tests__/GetAutomationVariablesByWebsiteIdUseCase.test.ts
PASS src/infrastructure/adapters/__tests__/ChromeNotificationAdapter.test.ts
PASS src/infrastructure/loggers/__tests__/BackgroundLogger.test.ts
PASS src/usecases/websites/__tests__/GetAllWebsitesUseCase.test.ts
PASS src/usecases/automation-variables/__tests__/ExportAutomationVariablesUseCase.test.ts
PASS src/usecases/xpaths/__tests__/UpdateXPathUseCase.test.ts
PASS src/domain/factories/__tests__/XPathDataFactory.test.ts
PASS src/infrastructure/repositories/__tests__/ChromeWebsiteConfigRepository.test.ts
PASS src/domain/services/__tests__/ElementValidationService.test.ts
PASS src/domain/services/__tests__/CSVFormatDetectorService.test.ts
PASS src/infrastructure/repositories/__tests__/ChromeStorageWebsiteRepository.test.ts
PASS src/domain/entities/__tests__/XPathCollection.test.ts
PASS src/domain/constants/__tests__/EventPattern.test.ts
PASS src/infrastructure/adapters/__tests__/ChromeSchedulerAdapter.test.ts
PASS src/domain/constants/__tests__/MessageTypes.test.ts
PASS src/domain/constants/__tests__/ComparisonPattern.test.ts
PASS src/usecases/websites/__tests__/ImportWebsitesUseCase.test.ts
PASS src/domain/constants/__tests__/RetryType.test.ts
PASS src/usecases/automation-variables/__tests__/DeleteAutomationVariablesUseCase.test.ts
PASS src/usecases/recording/__tests__/GetRecordingByResultIdUseCase.test.ts
PASS src/usecases/recording/__tests__/StopTabRecordingUseCase.test.ts
PASS src/domain/values/__tests__/validation-result.value.test.ts
FAIL src/presentation/content-script/__tests__/AutoFillHandler.test.ts
  ● AutoFillHandler › handlePageLoad › should execute auto-fill when URL matches enabled website

    expect(jest.fn()).toHaveBeenCalledWith(...expected)

    Expected: "https://example.com/login", "https://example.com/login"

    Number of calls: 0

      161 |       // Mock AutomationVariables for website_1 with enabled status
      162 |       const mockAv1 = AutomationVariables.create({
    > 163 |         websiteId: 'website_1',
          |                                ^
      164 |         status: 'enabled',
      165 |         variables: { username: 'user1' },
      166 |       });

      at Object.<anonymous> (src/presentation/content-script/__tests__/AutoFillHandler.test.ts:163:52)

  ● AutoFillHandler › handlePageLoad › should change status from once to disabled before execution

    expect(jest.fn()).toHaveBeenCalled()

    Expected number of calls: >= 1
    Received number of calls:    0

      195 |       expect(mockLogger.info).toHaveBeenCalledWith('Auto-fill completed successfully', {
      196 |         processedSteps: 2,
    > 197 |       });
          |          ^
      198 |     });
      199 |
      200 |     it('should change status from once to disabled before execution', async () => {

      at Object.<anonymous> (src/presentation/content-script/__tests__/AutoFillHandler.test.ts:197:35)

  ● AutoFillHandler › handlePageLoad › should not execute when no URL matches

    expect(jest.fn()).toHaveBeenCalledWith(...expected)

    - Expected
    + Received

    - "No matching website found",
    + "Found in-progress executions",
      Object {
    -   "currentURL": "https://example.com/login",
    +   "total": 0,
    +   "within24h": 0,
      },

    Number of calls: 1

      216 |       });
      217 |       (browser.storage.local.get as jest.Mock).mockResolvedValueOnce({
    > 218 |         xpathCollectionCSV: mockXPathCSV,
          |                                      ^
      219 |       });
      220 |       mockURLMatchingService.matches.mockImplementation((currentUrl: string, startUrl: string) => {
      221 |         return currentUrl === startUrl;

      at Object.<anonymous> (src/presentation/content-script/__tests__/AutoFillHandler.test.ts:218:38)

  ● AutoFillHandler › handlePageLoad › should return early when no enabled websites found

    expect(jest.fn()).toHaveBeenCalledWith(...expected)

    - Expected
    + Received

    - "All automation variables",
    + "Found in-progress executions",
      Object {
    -   "allAutomationVariables": Array [],
    +   "total": 0,
    +   "within24h": 0,
      },

    Number of calls: 1

      235 |
      236 |     it('should not execute when no URL matches', async () => {
    > 237 |       // Mock enabled website
          |                              ^
      238 |       const mockAv1 = AutomationVariables.create({
      239 |         websiteId: 'website_1',
      240 |         status: 'enabled',

      at Object.<anonymous> (src/presentation/content-script/__tests__/AutoFillHandler.test.ts:237:38)

  ● AutoFillHandler › handlePageLoad › should skip websites without XPaths

    expect(jest.fn()).toHaveBeenCalledWith(...expected)

    Expected: "Skipping website (no XPaths configured)", {"name": "Test Website 1"}
    Received
           1
              "Found in-progress executions",
              Object {
            -   "name": "Test Website 1",
            +   "total": 0,
            +   "within24h": 0,
              },
           2: "No website configs found"

    Number of calls: 2

      257 |       expect(mockMessageDispatcher.executeAutoFill).not.toHaveBeenCalled();
      258 |       expect(mockLogger.debug).toHaveBeenCalledWith('No matching website found', {
    > 259 |         currentURL: 'https://example.com/login',
          |                                      ^
      260 |       });
      261 |     });
      262 |

      at Object.<anonymous> (src/presentation/content-script/__tests__/AutoFillHandler.test.ts:259:38)

  ● AutoFillHandler › handlePageLoad › should skip websites when first step has no URL

    expect(jest.fn()).toHaveBeenCalledWith(...expected)

    - Expected
    + Received

    - "Skipping website (first step has no URL)",
    + "Found in-progress executions",
      Object {
    -   "name": "Test Website 1",
    +   "total": 0,
    +   "within24h": 0,
      },

    Number of calls: 1

      281 |       });
      282 |
    > 283 |       await handler.handlePageLoad();
          |                                      ^
      284 |
      285 |       expect(mockLogger.debug).toHaveBeenCalledWith('All automation variables', {
      286 |         allAutomationVariables: [],

      at Object.<anonymous> (src/presentation/content-script/__tests__/AutoFillHandler.test.ts:283:38)

  ● AutoFillHandler › handlePageLoad › should return early when XPath collection not found

    expect(jest.fn()).toHaveBeenCalledWith(...expected)

    Expected: "No XPath collection found"
    Received: "Found in-progress executions", {"total": 0, "within24h": 0}

    Number of calls: 1

      300 |
      301 |       const mockRepo = (handler as any).automationVariablesRepository;
    > 302 |       mockRepo.loadAll = jest.fn().mockResolvedValue([mockAv1]);
          |                                      ^
      303 |
      304 |       (browser.storage.local.get as jest.Mock).mockResolvedValueOnce({
      305 |         websiteConfigs: JSON.stringify(websitesWithoutXPaths),

      at Object.<anonymous> (src/presentation/content-script/__tests__/AutoFillHandler.test.ts:302:38)

  ● AutoFillHandler › handlePageLoad › should return early when XPath collection is empty

    expect(jest.fn()).toHaveBeenCalledWith(...expected)

    Expected: "XPath collection is empty"
    Received
           1: "Found in-progress executions", {"total": 0, "within24h": 0}
           2: "No website configs found"

    Number of calls: 2

      319 |
      320 |     it('should skip websites when first step has no URL', async () => {
    > 321 |       const websitesWithNoUrl = [mockWebsites[0]];
          |                                      ^
      322 |
      323 |       // Mock enabled website
      324 |       const mockAv1 = AutomationVariables.create({

      at Object.<anonymous> (src/presentation/content-script/__tests__/AutoFillHandler.test.ts:321:38)

  ● AutoFillHandler › handlePageLoad › should log error when auto-fill fails

    expect(jest.fn()).toHaveBeenCalledWith(...expected)

    Expected: "Auto-fill failed", "Execution failed"
    Received: "Error during auto-fill on load", [TypeError: Cannot read properties of undefined (reading 'map')]

    Number of calls: 1

      343 |       await handler.handlePageLoad();
      344 |
    > 345 |       expect(mockLogger.debug).toHaveBeenCalledWith('Skipping website (first step has no URL)', {
          |                                      ^
      346 |         name: 'Test Website 1',
      347 |       });
      348 |       expect(mockMessageDispatcher.executeAutoFill).not.toHaveBeenCalled();

      at Object.<anonymous> (src/presentation/content-script/__tests__/AutoFillHandler.test.ts:345:38)

  ● AutoFillHandler › handlePageLoad › should handle errors during page load

    expect(jest.fn()).toHaveBeenCalledWith(...expected)

    Expected: "Error during auto-fill on load", [Error: Storage error]

    Number of calls: 0

      349 |     });
      350 |
    > 351 |     it('should return early when XPath collection not found', async () => {
          |                                      ^
      352 |       // Mock enabled website
      353 |       const mockAv1 = AutomationVariables.create({
      354 |         websiteId: 'website_1',

      at Object.<anonymous> (src/presentation/content-script/__tests__/AutoFillHandler.test.ts:351:38)

  ● AutoFillHandler › handlePageLoad › should sort enabled websites by automationVariables.updatedAt (newest first)

    expect(jest.fn()).toHaveBeenCalledWith(...expected)

    Expected: {"tabId": null, "websiteId": "website_2", "websiteVariables": {"username": "user2"}}

    Number of calls: 0

      397 |     it('should log error when auto-fill fails', async () => {
      398 |       // Mock enabled website
    > 399 |       const mockAv1 = AutomationVariables.create({
          |                                                   ^
      400 |         websiteId: 'website_1',
      401 |         status: 'enabled',
      402 |         variables: { username: 'user1' },

      at Object.<anonymous> (src/presentation/content-script/__tests__/AutoFillHandler.test.ts:399:59)

PASS src/presentation/content-script/__tests__/ContentScriptCoordinator.test.ts
PASS tests/e2e/PageTransitionResume.e2e.test.ts
FAIL tests/integration/TabRecording.integration.test.ts
  ● Tab Recording Integration Tests › Complete Recording Flow › should start and stop recording successfully

    expect(received).not.toBeNull()

    Received: null

      190 |   beforeEach(() => {
      191 |     mockTabCaptureAdapter = new MockTabCaptureAdapter();
    > 192 |     mockRecordingRepository = new MockRecordingStorageRepository();
          |                                          ^
      193 |     mockSystemSettingsRepository = new MockSystemSettingsRepository();
      194 |     mockAutomationResultRepository = new MockAutomationResultRepository();
      195 |     mockLogger = new MockLogger();

      at Object.<anonymous> (tests/integration/TabRecording.integration.test.ts:192:42)

  ● Tab Recording Integration Tests › Tab Close Handling › should stop recording when tab is closed

    expect(received).not.toBeNull()

    Received: null

      236 |       expect(recording!.getAutomationResultId()).toBe(automationResultId);
      237 |       expect(recording!.getStatus()).toBe(RecordingStatus.RECORDING);
    > 238 |       expect(recording!.getTabId()).toBe(tabId);
          |                                          ^
      239 |
      240 |       // Wait for chunks to be processed
      241 |       await new Promise((resolve) => setTimeout(resolve, 50));

      at Object.<anonymous> (tests/integration/TabRecording.integration.test.ts:238:42)

  ● Tab Recording Integration Tests › Tab Close Handling › should handle stopping non-existent recording gracefully

    TypeError: Cannot read properties of null (reading 'isFailure')

      30 |     private logger: Logger
      31 |   ) {}
    > 32 |
         | ^
      33 |   // eslint-disable-next-line max-lines-per-function -- Recording stop requires extensive validation (recording exists, is recording, has recorderId) and detailed logging at each step for debugging. Splitting would separate validation logic from business logic, reducing code cohesion.
      34 |   async execute(input: StopTabRecordingInput): Promise<TabRecording | null> {
      35 |     this.logger.info('Starting stop tab recording use case', {

      at StopTabRecordingUseCase.execute (src/usecases/recording/StopTabRecordingUseCase.ts:32:29)
      at Object.<anonymous> (tests/integration/TabRecording.integration.test.ts:243:28)

  ● Tab Recording Integration Tests › Old Recordings Deletion › should delete recordings older than retention period

    TypeError: Cannot read properties of undefined (reading 'isFailure')

      20 |   async execute(_input: DeleteOldRecordingsInput): Promise<number> {
      21 |     const settingsResult = await this.systemSettingsRepository.load();
    > 22 |     if (settingsResult.isFailure) {
         |                          ^
      23 |       throw new Error(
      24 |         `Failed to load system settings: ${settingsResult.error?.message || 'Unknown error'}`
      25 |       );

      at DeleteOldRecordingsUseCase.execute (src/usecases/recording/DeleteOldRecordingsUseCase.ts:22:26)
      at Object.<anonymous> (tests/integration/TabRecording.integration.test.ts:274:13)

  ● Tab Recording Integration Tests › Old Recordings Deletion › should respect custom retention period

    TypeError: Cannot read properties of undefined (reading 'isFailure')

      20 |   async execute(_input: DeleteOldRecordingsInput): Promise<number> {
      21 |     const settingsResult = await this.systemSettingsRepository.load();
    > 22 |     if (settingsResult.isFailure) {
         |                          ^
      23 |       throw new Error(
      24 |         `Failed to load system settings: ${settingsResult.error?.message || 'Unknown error'}`
      25 |       );

      at DeleteOldRecordingsUseCase.execute (src/usecases/recording/DeleteOldRecordingsUseCase.ts:22:26)
      at Object.<anonymous> (tests/integration/TabRecording.integration.test.ts:296:13)

  ● Tab Recording Integration Tests › UI Recording Preview › should retrieve latest recording for automation variables

    expect(received).not.toBeNull()

    Received: null

      322 |       const oldDate = new Date();
      323 |       oldDate.setDate(oldDate.getDate() - 15); // 15 days ago
    > 324 |
          | ^
      325 |       const oldRecording = TabRecording.create({
      326 |         automationResultId: 'old-result',
      327 |         tabId: 1,

      at Object.<anonymous> (tests/integration/TabRecording.integration.test.ts:324:44)

  ● Tab Recording Integration Tests › UI Recording Preview › should return null if no recording exists

    TypeError: Cannot read properties of null (reading 'isFailure')

      13 |
      14 | export class GetLatestRecordingByVariablesIdUseCase {
    > 15 |   constructor(
         |               ^
      16 |     private recordingRepository: RecordingStorageRepository,
      17 |     private logger: Logger
      18 |   ) {}

      at GetLatestRecordingByVariablesIdUseCase.execute (src/usecases/recording/GetLatestRecordingByVariablesIdUseCase.ts:15:29)
      at Object.<anonymous> (tests/integration/TabRecording.integration.test.ts:329:31)

  ● Tab Recording Integration Tests › Error Handling › should handle recording stop failure gracefully

    expect(received).rejects.toThrow()

    Received promise resolved instead of rejected
    Resolved to value: null

      361 |
      362 |       const oldDate = new Date();
    > 363 |       oldDate.setDate(oldDate.getDate() - 25); // 25 days ago
          |                   ^
      364 |
      365 |       const recording = TabRecording.create({
      366 |         automationResultId: 'result-1',

      at expect (node_modules/expect/build/index.js:113:15)
      at Object.<anonymous> (tests/integration/TabRecording.integration.test.ts:363:19)

FAIL src/infrastructure/repositories/__tests__/IndexedDBRecordingRepository.test.ts
  ● IndexedDBRecordingRepository › save() › should handle save error

    expect(received).rejects.toThrow()

    Received promise resolved instead of rejected
    Resolved to value: {"_data": undefined, "_error": [Error: Put failed], "_isSuccess": false, "_value": undefined}

      217 |         id: recording.getId(),
      218 |         automationResultId: recording.getAutomationResultId(),
    > 219 |         tabId: recording.getTabId(),
          |                   ^
      220 |         status: recording.getStatus(),
      221 |         sizeBytes: recording.getSizeBytes(),
      222 |         sizeMB: recording.getSizeMB().toFixed(2),

      at expect (node_modules/expect/build/index.js:113:15)
      at Object.<anonymous> (src/infrastructure/repositories/__tests__/IndexedDBRecordingRepository.test.ts:219:19)

  ● IndexedDBRecordingRepository › load() › should return null when recording not found

    expect(received).toBeNull()

    Received: {"_data": undefined, "_error": undefined, "_isSuccess": true, "_value": null}

      310 |         close: jest.fn(),
      311 |       };
    > 312 |
          | ^
      313 |       const getRequest = {
      314 |         result: recordingData,
      315 |         onsuccess: null as any,

      at Object.<anonymous> (src/infrastructure/repositories/__tests__/IndexedDBRecordingRepository.test.ts:312:28)

  ● IndexedDBRecordingRepository › load() › should handle load error

    expect(received).rejects.toThrow()

    Received promise resolved instead of rejected
    Resolved to value: {"_data": undefined, "_error": [Error: Failed to load recording], "_isSuccess": false, "_value": undefined}

      338 |       expect(result.value).not.toBeNull();
      339 |       expect(result.value!.getId()).toBe(recordingId);
    > 340 |       expect(mockStore.get).toHaveBeenCalledWith(recordingId);
          |                   ^
      341 |       expect(mockDB.close).toHaveBeenCalled();
      342 |     });
      343 |

      at expect (node_modules/expect/build/index.js:113:15)
      at Object.<anonymous> (src/infrastructure/repositories/__tests__/IndexedDBRecordingRepository.test.ts:340:19)

  ● IndexedDBRecordingRepository › loadByAutomationResultId() › should return null when recording not found by automation result ID

    expect(received).toBeNull()

    Received: {"_data": undefined, "_error": undefined, "_isSuccess": true, "_value": null}

      429 |       const automationResultId = 'result-123';
      430 |       const recordingData = {
    > 431 |         id: 'recording-123',
          |                            ^
      432 |         automationResultId,
      433 |         tabId: 1,
      434 |         status: RecordingStatus.SAVED,

      at Object.<anonymous> (src/infrastructure/repositories/__tests__/IndexedDBRecordingRepository.test.ts:431:28)

  ● IndexedDBRecordingRepository › deleteOldRecordings() › should delete recordings older than retention period

    expect(received).toBe(expected) // Object.is equality

    Expected: 1
    Received: {"_data": undefined, "_error": undefined, "_isSuccess": true, "_value": 1}

      638 |       } as IDBRequest;
      639 |
    > 640 |       mockStore.delete.mockReturnValue(deleteRequest);
          |                                  ^
      641 |
      642 |       jest.spyOn(repository as any, 'openDB').mockResolvedValue(mockDB);
      643 |

      at Object.<anonymous> (src/infrastructure/repositories/__tests__/IndexedDBRecordingRepository.test.ts:640:34)

  ● IndexedDBRecordingRepository › loadLatestByAutomationVariablesId() › should return null when no automation results found

    expect(received).toBeNull()

    Received: {"_data": undefined, "_error": undefined, "_isSuccess": true, "_value": null}

      741 |
      742 |       const mockStore = {
    > 743 |         index: jest.fn().mockReturnValue(mockIndex),
          |                            ^
      744 |         delete: jest.fn(),
      745 |       };
      746 |

      at Object.<anonymous> (src/infrastructure/repositories/__tests__/IndexedDBRecordingRepository.test.ts:743:28)

  ● IndexedDBRecordingRepository › loadLatestByAutomationVariablesId() › should handle errors gracefully

    expect(received).toBeNull()

    Received: {"_data": undefined, "_error": [Error: Repository error], "_isSuccess": false, "_value": undefined}

      774 |             value: oldRecordingData,
      775 |             continue: jest.fn(),
    > 776 |           };
          |             ^
      777 |           cursorRequest.onsuccess({ target: cursorRequest } as any);
      778 |
      779 |           // Second cursor: recent recording

      at Object.<anonymous> (src/infrastructure/repositories/__tests__/IndexedDBRecordingRepository.test.ts:776:28)

PASS src/presentation/automation-variables-manager/__tests__/AutomationVariablesManagerPresenter.test.ts (15.419 s)
A worker process has failed to exit gracefully and has been force exited. This is likely caused by tests leaking due to improper teardown. Try running with --detectOpenHandles to find leaks. Active timers can also cause this, ensure that .unref() was called on them.

Summary of all failing tests
FAIL src/usecases/storage/__tests__/ExecuteStorageSyncUseCase.test.ts (9.593 s)
  ● ExecuteStorageSyncUseCase › execute() › should handle repository load errors

    expect(received).rejects.toThrow()

    Received promise resolved instead of rejected
    Resolved to value: {"error": "Database connection failed", "success": false, "syncDirection": "bidirectional"}

      165 |       useCase = new ExecuteStorageSyncUseCase(
      166 |         mockConfigRepository,
    > 167 |         mockExecuteReceiveDataUseCase,
          |                   ^
      168 |         mockExecuteSendDataUseCase,
      169 |         mockSyncHistoryRepository,
      170 |         mockSyncStateNotifier,

      at expect (node_modules/expect/build/index.js:113:15)
      at Object.<anonymous> (src/usecases/storage/__tests__/ExecuteStorageSyncUseCase.test.ts:167:19)

FAIL tests/integration/page-transition-resume.integration.test.ts (18.698 s)
  ● Page Transition Resume Integration Tests › Task 4.2: New Execution › should create AutomationResult in DOING status when starting new execution

    TypeError: Cannot read properties of undefined (reading 'getByWebsiteId')

      111 |       // Find matching automationVariablesId
      112 |       for (const result of validResults) {
    > 113 |         const loadResult = await this.automationVariablesRepository.load(
          |                          ^
      114 |           result.getAutomationVariablesId()
      115 |         );
      116 |

      at ExecuteAutoFillUseCase.loadAndValidateXPaths (src/usecases/auto-fill/ExecuteAutoFillUseCase.ts:113:26)
      at ExecuteAutoFillUseCase.startNewExecution (src/usecases/auto-fill/ExecuteAutoFillUseCase.ts:124:39)
      at ExecuteAutoFillUseCase.execute (src/usecases/auto-fill/ExecuteAutoFillUseCase.ts:52:16)
      at Object.<anonymous> (tests/integration/page-transition-resume.integration.test.ts:239:28)

  ● Page Transition Resume Integration Tests › Task 4.2: New Execution › should save AutomationVariables with correct websiteId

    TypeError: Cannot read properties of undefined (reading 'getByWebsiteId')

      111 |       // Find matching automationVariablesId
      112 |       for (const result of validResults) {
    > 113 |         const loadResult = await this.automationVariablesRepository.load(
          |                          ^
      114 |           result.getAutomationVariablesId()
      115 |         );
      116 |

      at ExecuteAutoFillUseCase.loadAndValidateXPaths (src/usecases/auto-fill/ExecuteAutoFillUseCase.ts:113:26)
      at ExecuteAutoFillUseCase.startNewExecution (src/usecases/auto-fill/ExecuteAutoFillUseCase.ts:124:39)
      at ExecuteAutoFillUseCase.execute (src/usecases/auto-fill/ExecuteAutoFillUseCase.ts:52:16)
      at Object.<anonymous> (tests/integration/page-transition-resume.integration.test.ts:280:28)

  ● Page Transition Resume Integration Tests › Task 4.2: New Execution › should initialize progress tracking fields correctly

    TypeError: Cannot read properties of undefined (reading 'getByWebsiteId')

      111 |       // Find matching automationVariablesId
      112 |       for (const result of validResults) {
    > 113 |         const loadResult = await this.automationVariablesRepository.load(
          |                          ^
      114 |           result.getAutomationVariablesId()
      115 |         );
      116 |

      at ExecuteAutoFillUseCase.loadAndValidateXPaths (src/usecases/auto-fill/ExecuteAutoFillUseCase.ts:113:26)
      at ExecuteAutoFillUseCase.startNewExecution (src/usecases/auto-fill/ExecuteAutoFillUseCase.ts:124:39)
      at ExecuteAutoFillUseCase.execute (src/usecases/auto-fill/ExecuteAutoFillUseCase.ts:52:16)
      at Object.<anonymous> (tests/integration/page-transition-resume.integration.test.ts:330:28)

  ● Page Transition Resume Integration Tests › Task 4.2: New Execution › should calculate progress percentage correctly

    TypeError: Cannot read properties of undefined (reading 'getByWebsiteId')

      111 |       // Find matching automationVariablesId
      112 |       for (const result of validResults) {
    > 113 |         const loadResult = await this.automationVariablesRepository.load(
          |                          ^
      114 |           result.getAutomationVariablesId()
      115 |         );
      116 |

      at ExecuteAutoFillUseCase.loadAndValidateXPaths (src/usecases/auto-fill/ExecuteAutoFillUseCase.ts:113:26)
      at ExecuteAutoFillUseCase.startNewExecution (src/usecases/auto-fill/ExecuteAutoFillUseCase.ts:124:39)
      at ExecuteAutoFillUseCase.execute (src/usecases/auto-fill/ExecuteAutoFillUseCase.ts:52:16)
      at Object.<anonymous> (tests/integration/page-transition-resume.integration.test.ts:375:28)

  ● Page Transition Resume Integration Tests › Task 4.3: CHANGE_URL Progress Saving › should save progress after CHANGE_URL action

    TypeError: Cannot read properties of undefined (reading 'getByWebsiteId')

      111 |       // Find matching automationVariablesId
      112 |       for (const result of validResults) {
    > 113 |         const loadResult = await this.automationVariablesRepository.load(
          |                          ^
      114 |           result.getAutomationVariablesId()
      115 |         );
      116 |

      at ExecuteAutoFillUseCase.loadAndValidateXPaths (src/usecases/auto-fill/ExecuteAutoFillUseCase.ts:113:26)
      at ExecuteAutoFillUseCase.startNewExecution (src/usecases/auto-fill/ExecuteAutoFillUseCase.ts:124:39)
      at ExecuteAutoFillUseCase.execute (src/usecases/auto-fill/ExecuteAutoFillUseCase.ts:52:16)
      at Object.<anonymous> (tests/integration/page-transition-resume.integration.test.ts:440:28)

  ● Page Transition Resume Integration Tests › Task 4.3: CHANGE_URL Progress Saving › should save progress multiple times for multiple CHANGE_URL actions

    TypeError: Cannot read properties of undefined (reading 'getByWebsiteId')

      111 |       // Find matching automationVariablesId
      112 |       for (const result of validResults) {
    > 113 |         const loadResult = await this.automationVariablesRepository.load(
          |                          ^
      114 |           result.getAutomationVariablesId()
      115 |         );
      116 |

      at ExecuteAutoFillUseCase.loadAndValidateXPaths (src/usecases/auto-fill/ExecuteAutoFillUseCase.ts:113:26)
      at ExecuteAutoFillUseCase.startNewExecution (src/usecases/auto-fill/ExecuteAutoFillUseCase.ts:124:39)
      at ExecuteAutoFillUseCase.execute (src/usecases/auto-fill/ExecuteAutoFillUseCase.ts:52:16)
      at Object.<anonymous> (tests/integration/page-transition-resume.integration.test.ts:506:28)

  ● Page Transition Resume Integration Tests › Task 4.3: CHANGE_URL Progress Saving › should calculate correct progress percentage after CHANGE_URL

    TypeError: Cannot read properties of undefined (reading 'getByWebsiteId')

      111 |       // Find matching automationVariablesId
      112 |       for (const result of validResults) {
    > 113 |         const loadResult = await this.automationVariablesRepository.load(
          |                          ^
      114 |           result.getAutomationVariablesId()
      115 |         );
      116 |

      at ExecuteAutoFillUseCase.loadAndValidateXPaths (src/usecases/auto-fill/ExecuteAutoFillUseCase.ts:113:26)
      at ExecuteAutoFillUseCase.startNewExecution (src/usecases/auto-fill/ExecuteAutoFillUseCase.ts:124:39)
      at ExecuteAutoFillUseCase.execute (src/usecases/auto-fill/ExecuteAutoFillUseCase.ts:52:16)
      at Object.<anonymous> (tests/integration/page-transition-resume.integration.test.ts:555:28)

  ● Page Transition Resume Integration Tests › Task 4.4: Resume Execution › should resume execution from currentStepIndex when DOING status exists

    TypeError: Cannot read properties of undefined (reading 'getByWebsiteId')

      111 |       // Find matching automationVariablesId
      112 |       for (const result of validResults) {
    > 113 |         const loadResult = await this.automationVariablesRepository.load(
          |                          ^
      114 |           result.getAutomationVariablesId()
      115 |         );
      116 |

      at ExecuteAutoFillUseCase.loadAndValidateXPaths (src/usecases/auto-fill/ExecuteAutoFillUseCase.ts:113:26)
      at ExecuteAutoFillUseCase.startNewExecution (src/usecases/auto-fill/ExecuteAutoFillUseCase.ts:124:39)
      at ExecuteAutoFillUseCase.execute (src/usecases/auto-fill/ExecuteAutoFillUseCase.ts:52:16)
      at Object.<anonymous> (tests/integration/page-transition-resume.integration.test.ts:607:28)

  ● Page Transition Resume Integration Tests › Task 4.4: Resume Execution › should only resume executions within 24 hours

    TypeError: Cannot read properties of undefined (reading 'getByWebsiteId')

      111 |       // Find matching automationVariablesId
      112 |       for (const result of validResults) {
    > 113 |         const loadResult = await this.automationVariablesRepository.load(
          |                          ^
      114 |           result.getAutomationVariablesId()
      115 |         );
      116 |

      at ExecuteAutoFillUseCase.loadAndValidateXPaths (src/usecases/auto-fill/ExecuteAutoFillUseCase.ts:113:26)
      at ExecuteAutoFillUseCase.startNewExecution (src/usecases/auto-fill/ExecuteAutoFillUseCase.ts:124:39)
      at ExecuteAutoFillUseCase.execute (src/usecases/auto-fill/ExecuteAutoFillUseCase.ts:52:16)
      at Object.<anonymous> (tests/integration/page-transition-resume.integration.test.ts:663:28)

  ● Page Transition Resume Integration Tests › Task 4.4: Resume Execution › should only resume executions with matching websiteId

    TypeError: Cannot read properties of undefined (reading 'getByWebsiteId')

      111 |       // Find matching automationVariablesId
      112 |       for (const result of validResults) {
    > 113 |         const loadResult = await this.automationVariablesRepository.load(
          |                          ^
      114 |           result.getAutomationVariablesId()
      115 |         );
      116 |

      at ExecuteAutoFillUseCase.loadAndValidateXPaths (src/usecases/auto-fill/ExecuteAutoFillUseCase.ts:113:26)
      at ExecuteAutoFillUseCase.startNewExecution (src/usecases/auto-fill/ExecuteAutoFillUseCase.ts:124:39)
      at ExecuteAutoFillUseCase.execute (src/usecases/auto-fill/ExecuteAutoFillUseCase.ts:52:16)
      at Object.<anonymous> (tests/integration/page-transition-resume.integration.test.ts:718:28)

  ● Page Transition Resume Integration Tests › Task 4.4: Resume Execution › should handle case when currentStepIndex exceeds total steps

    TypeError: Cannot read properties of undefined (reading 'getByWebsiteId')

      111 |       // Find matching automationVariablesId
      112 |       for (const result of validResults) {
    > 113 |         const loadResult = await this.automationVariablesRepository.load(
          |                          ^
      114 |           result.getAutomationVariablesId()
      115 |         );
      116 |

      at ExecuteAutoFillUseCase.loadAndValidateXPaths (src/usecases/auto-fill/ExecuteAutoFillUseCase.ts:113:26)
      at ExecuteAutoFillUseCase.startNewExecution (src/usecases/auto-fill/ExecuteAutoFillUseCase.ts:124:39)
      at ExecuteAutoFillUseCase.execute (src/usecases/auto-fill/ExecuteAutoFillUseCase.ts:52:16)
      at Object.<anonymous> (tests/integration/page-transition-resume.integration.test.ts:767:28)

  ● Page Transition Resume Integration Tests › Task 4.5: Edge Cases › should start new execution when checkExistingExecution fails

    TypeError: Cannot read properties of undefined (reading 'getByWebsiteId')

      111 |       // Find matching automationVariablesId
      112 |       for (const result of validResults) {
    > 113 |         const loadResult = await this.automationVariablesRepository.load(
          |                          ^
      114 |           result.getAutomationVariablesId()
      115 |         );
      116 |

      at ExecuteAutoFillUseCase.loadAndValidateXPaths (src/usecases/auto-fill/ExecuteAutoFillUseCase.ts:113:26)
      at ExecuteAutoFillUseCase.startNewExecution (src/usecases/auto-fill/ExecuteAutoFillUseCase.ts:124:39)
      at ExecuteAutoFillUseCase.execute (src/usecases/auto-fill/ExecuteAutoFillUseCase.ts:52:16)
      at Object.<anonymous> (tests/integration/page-transition-resume.integration.test.ts:812:28)

  ● Page Transition Resume Integration Tests › Task 4.5: Edge Cases › should continue execution even when AutomationResult save fails

    TypeError: Cannot read properties of undefined (reading 'getByWebsiteId')

      111 |       // Find matching automationVariablesId
      112 |       for (const result of validResults) {
    > 113 |         const loadResult = await this.automationVariablesRepository.load(
          |                          ^
      114 |           result.getAutomationVariablesId()
      115 |         );
      116 |

      at ExecuteAutoFillUseCase.loadAndValidateXPaths (src/usecases/auto-fill/ExecuteAutoFillUseCase.ts:113:26)
      at ExecuteAutoFillUseCase.startNewExecution (src/usecases/auto-fill/ExecuteAutoFillUseCase.ts:124:39)
      at ExecuteAutoFillUseCase.execute (src/usecases/auto-fill/ExecuteAutoFillUseCase.ts:52:16)
      at Object.<anonymous> (tests/integration/page-transition-resume.integration.test.ts:851:28)

  ● Page Transition Resume Integration Tests › Task 4.5: Edge Cases › should execute successfully when AutomationVariables not found

    TypeError: Cannot read properties of undefined (reading 'getByWebsiteId')

      111 |       // Find matching automationVariablesId
      112 |       for (const result of validResults) {
    > 113 |         const loadResult = await this.automationVariablesRepository.load(
          |                          ^
      114 |           result.getAutomationVariablesId()
      115 |         );
      116 |

      at ExecuteAutoFillUseCase.loadAndValidateXPaths (src/usecases/auto-fill/ExecuteAutoFillUseCase.ts:113:26)
      at ExecuteAutoFillUseCase.startNewExecution (src/usecases/auto-fill/ExecuteAutoFillUseCase.ts:124:39)
      at ExecuteAutoFillUseCase.execute (src/usecases/auto-fill/ExecuteAutoFillUseCase.ts:52:16)
      at Object.<anonymous> (tests/integration/page-transition-resume.integration.test.ts:878:28)

  ● Page Transition Resume Integration Tests › Task 4.5: Edge Cases › should handle repository errors gracefully during resume check

    TypeError: Cannot read properties of undefined (reading 'getByWebsiteId')

      111 |       // Find matching automationVariablesId
      112 |       for (const result of validResults) {
    > 113 |         const loadResult = await this.automationVariablesRepository.load(
          |                          ^
      114 |           result.getAutomationVariablesId()
      115 |         );
      116 |

      at ExecuteAutoFillUseCase.loadAndValidateXPaths (src/usecases/auto-fill/ExecuteAutoFillUseCase.ts:113:26)
      at ExecuteAutoFillUseCase.startNewExecution (src/usecases/auto-fill/ExecuteAutoFillUseCase.ts:124:39)
      at ExecuteAutoFillUseCase.execute (src/usecases/auto-fill/ExecuteAutoFillUseCase.ts:52:16)
      at Object.<anonymous> (tests/integration/page-transition-resume.integration.test.ts:932:28)

  ● Page Transition Resume Integration Tests › Task 4.5: Edge Cases › should handle AutomationResult load failure in finalizeExecution

    TypeError: Cannot read properties of undefined (reading 'getByWebsiteId')

      111 |       // Find matching automationVariablesId
      112 |       for (const result of validResults) {
    > 113 |         const loadResult = await this.automationVariablesRepository.load(
          |                          ^
      114 |           result.getAutomationVariablesId()
      115 |         );
      116 |

      at ExecuteAutoFillUseCase.loadAndValidateXPaths (src/usecases/auto-fill/ExecuteAutoFillUseCase.ts:113:26)
      at ExecuteAutoFillUseCase.startNewExecution (src/usecases/auto-fill/ExecuteAutoFillUseCase.ts:124:39)
      at ExecuteAutoFillUseCase.execute (src/usecases/auto-fill/ExecuteAutoFillUseCase.ts:52:16)
      at Object.<anonymous> (tests/integration/page-transition-resume.integration.test.ts:963:28)

FAIL src/presentation/background/handlers/__tests__/ExecuteWebsiteFromPopupHandler.test.ts (19.131 s)
  ● ExecuteWebsiteFromPopupHandler › handle › should successfully execute website from popup

    expect(received).toBe(expected) // Object.is equality

    Expected: true
    Received: false

      86 |     );
      87 |   });
    > 88 |
         | ^
      89 |   describe('handle', () => {
      90 |     it('should successfully execute website from popup', async () => {
      91 |       const message: ExecuteWebsiteFromPopupRequest = {

      at Object.<anonymous> (src/presentation/background/handlers/__tests__/ExecuteWebsiteFromPopupHandler.test.ts:88:38)

  ● ExecuteWebsiteFromPopupHandler › handle › should return error when website has no startUrl

    expect(received).toContain(expected) // indexOf

    Expected substring: "startUrlが設定されていません"
    Received string:    "automationVariables?.getStatus is not a function"

      126 |     it('should return error when website not found', async () => {
      127 |       const message: ExecuteWebsiteFromPopupRequest = {
    > 128 |         action: MessageTypes.EXECUTE_WEBSITE_FROM_POPUP,
          |                                          ^
      129 |         websiteId: 'non_existent',
      130 |       };
      131 |

      at Object.<anonymous> (src/presentation/background/handlers/__tests__/ExecuteWebsiteFromPopupHandler.test.ts:128:42)

  ● ExecuteWebsiteFromPopupHandler › handle › should return error when tab creation fails

    expect(received).toBe(expected) // Object.is equality

    Expected: "新しいタブの作成に失敗しました"
    Received: "automationVariables?.getStatus is not a function"

      138 |       expect(mockLogger.error).toHaveBeenCalledWith(
      139 |         '[ExecuteWebsiteFromPopupHandler] Website not found',
    > 140 |         expect.any(Object)
          |                           ^
      141 |       );
      142 |     });
      143 |

      at Object.<anonymous> (src/presentation/background/handlers/__tests__/ExecuteWebsiteFromPopupHandler.test.ts:140:42)

  ● ExecuteWebsiteFromPopupHandler › handle › should handle auto-fill execution failure

    expect(received).toBe(expected) // Object.is equality

    Expected: "XPath not found"
    Received: "automationVariables?.getStatus is not a function"

      159 |
      160 |       const response: ExecuteWebsiteFromPopupResponse = await handler.handle(message);
    > 161 |
          | ^
      162 |       expect(response.success).toBe(false);
      163 |       expect(response.data?.error).toContain('startUrlが設定されていません');
      164 |       expect(mockLogger.error).toHaveBeenCalledWith(

      at Object.<anonymous> (src/presentation/background/handlers/__tests__/ExecuteWebsiteFromPopupHandler.test.ts:161:42)

  ● ExecuteWebsiteFromPopupHandler › handle › should log all execution steps

    expect(jest.fn()).toHaveBeenCalledWith(...expected)

    Expected: "[ExecuteWebsiteFromPopupHandler] Creating new tab", Any<Object>
    Received
           1: "[ExecuteWebsiteFromPopupHandler] Received request", {"websiteId": "website_123"}
           2: "[ExecuteWebsiteFromPopupHandler] Website loaded", {"name": "Test Website", "startUrl": "https://example.com"}

    Number of calls: 2

      191 |         action: MessageTypes.EXECUTE_WEBSITE_FROM_POPUP,
      192 |         websiteId: 'website_123',
    > 193 |       };
          |         ^
      194 |
      195 |       mockGetWebsiteByIdUseCase.execute.mockResolvedValue({ success: true, website: mockWebsite });
      196 |

      at Object.<anonymous> (src/presentation/background/handlers/__tests__/ExecuteWebsiteFromPopupHandler.test.ts:193:37)

FAIL src/presentation/content-script/__tests__/AutoFillHandler.test.ts
  ● AutoFillHandler › handlePageLoad › should execute auto-fill when URL matches enabled website

    expect(jest.fn()).toHaveBeenCalledWith(...expected)

    Expected: "https://example.com/login", "https://example.com/login"

    Number of calls: 0

      161 |       // Mock AutomationVariables for website_1 with enabled status
      162 |       const mockAv1 = AutomationVariables.create({
    > 163 |         websiteId: 'website_1',
          |                                ^
      164 |         status: 'enabled',
      165 |         variables: { username: 'user1' },
      166 |       });

      at Object.<anonymous> (src/presentation/content-script/__tests__/AutoFillHandler.test.ts:163:52)

  ● AutoFillHandler › handlePageLoad › should change status from once to disabled before execution

    expect(jest.fn()).toHaveBeenCalled()

    Expected number of calls: >= 1
    Received number of calls:    0

      195 |       expect(mockLogger.info).toHaveBeenCalledWith('Auto-fill completed successfully', {
      196 |         processedSteps: 2,
    > 197 |       });
          |          ^
      198 |     });
      199 |
      200 |     it('should change status from once to disabled before execution', async () => {

      at Object.<anonymous> (src/presentation/content-script/__tests__/AutoFillHandler.test.ts:197:35)

  ● AutoFillHandler › handlePageLoad › should not execute when no URL matches

    expect(jest.fn()).toHaveBeenCalledWith(...expected)

    - Expected
    + Received

    - "No matching website found",
    + "Found in-progress executions",
      Object {
    -   "currentURL": "https://example.com/login",
    +   "total": 0,
    +   "within24h": 0,
      },

    Number of calls: 1

      216 |       });
      217 |       (browser.storage.local.get as jest.Mock).mockResolvedValueOnce({
    > 218 |         xpathCollectionCSV: mockXPathCSV,
          |                                      ^
      219 |       });
      220 |       mockURLMatchingService.matches.mockImplementation((currentUrl: string, startUrl: string) => {
      221 |         return currentUrl === startUrl;

      at Object.<anonymous> (src/presentation/content-script/__tests__/AutoFillHandler.test.ts:218:38)

  ● AutoFillHandler › handlePageLoad › should return early when no enabled websites found

    expect(jest.fn()).toHaveBeenCalledWith(...expected)

    - Expected
    + Received

    - "All automation variables",
    + "Found in-progress executions",
      Object {
    -   "allAutomationVariables": Array [],
    +   "total": 0,
    +   "within24h": 0,
      },

    Number of calls: 1

      235 |
      236 |     it('should not execute when no URL matches', async () => {
    > 237 |       // Mock enabled website
          |                              ^
      238 |       const mockAv1 = AutomationVariables.create({
      239 |         websiteId: 'website_1',
      240 |         status: 'enabled',

      at Object.<anonymous> (src/presentation/content-script/__tests__/AutoFillHandler.test.ts:237:38)

  ● AutoFillHandler › handlePageLoad › should skip websites without XPaths

    expect(jest.fn()).toHaveBeenCalledWith(...expected)

    Expected: "Skipping website (no XPaths configured)", {"name": "Test Website 1"}
    Received
           1
              "Found in-progress executions",
              Object {
            -   "name": "Test Website 1",
            +   "total": 0,
            +   "within24h": 0,
              },
           2: "No website configs found"

    Number of calls: 2

      257 |       expect(mockMessageDispatcher.executeAutoFill).not.toHaveBeenCalled();
      258 |       expect(mockLogger.debug).toHaveBeenCalledWith('No matching website found', {
    > 259 |         currentURL: 'https://example.com/login',
          |                                      ^
      260 |       });
      261 |     });
      262 |

      at Object.<anonymous> (src/presentation/content-script/__tests__/AutoFillHandler.test.ts:259:38)

  ● AutoFillHandler › handlePageLoad › should skip websites when first step has no URL

    expect(jest.fn()).toHaveBeenCalledWith(...expected)

    - Expected
    + Received

    - "Skipping website (first step has no URL)",
    + "Found in-progress executions",
      Object {
    -   "name": "Test Website 1",
    +   "total": 0,
    +   "within24h": 0,
      },

    Number of calls: 1

      281 |       });
      282 |
    > 283 |       await handler.handlePageLoad();
          |                                      ^
      284 |
      285 |       expect(mockLogger.debug).toHaveBeenCalledWith('All automation variables', {
      286 |         allAutomationVariables: [],

      at Object.<anonymous> (src/presentation/content-script/__tests__/AutoFillHandler.test.ts:283:38)

  ● AutoFillHandler › handlePageLoad › should return early when XPath collection not found

    expect(jest.fn()).toHaveBeenCalledWith(...expected)

    Expected: "No XPath collection found"
    Received: "Found in-progress executions", {"total": 0, "within24h": 0}

    Number of calls: 1

      300 |
      301 |       const mockRepo = (handler as any).automationVariablesRepository;
    > 302 |       mockRepo.loadAll = jest.fn().mockResolvedValue([mockAv1]);
          |                                      ^
      303 |
      304 |       (browser.storage.local.get as jest.Mock).mockResolvedValueOnce({
      305 |         websiteConfigs: JSON.stringify(websitesWithoutXPaths),

      at Object.<anonymous> (src/presentation/content-script/__tests__/AutoFillHandler.test.ts:302:38)

  ● AutoFillHandler › handlePageLoad › should return early when XPath collection is empty

    expect(jest.fn()).toHaveBeenCalledWith(...expected)

    Expected: "XPath collection is empty"
    Received
           1: "Found in-progress executions", {"total": 0, "within24h": 0}
           2: "No website configs found"

    Number of calls: 2

      319 |
      320 |     it('should skip websites when first step has no URL', async () => {
    > 321 |       const websitesWithNoUrl = [mockWebsites[0]];
          |                                      ^
      322 |
      323 |       // Mock enabled website
      324 |       const mockAv1 = AutomationVariables.create({

      at Object.<anonymous> (src/presentation/content-script/__tests__/AutoFillHandler.test.ts:321:38)

  ● AutoFillHandler › handlePageLoad › should log error when auto-fill fails

    expect(jest.fn()).toHaveBeenCalledWith(...expected)

    Expected: "Auto-fill failed", "Execution failed"
    Received: "Error during auto-fill on load", [TypeError: Cannot read properties of undefined (reading 'map')]

    Number of calls: 1

      343 |       await handler.handlePageLoad();
      344 |
    > 345 |       expect(mockLogger.debug).toHaveBeenCalledWith('Skipping website (first step has no URL)', {
          |                                      ^
      346 |         name: 'Test Website 1',
      347 |       });
      348 |       expect(mockMessageDispatcher.executeAutoFill).not.toHaveBeenCalled();

      at Object.<anonymous> (src/presentation/content-script/__tests__/AutoFillHandler.test.ts:345:38)

  ● AutoFillHandler › handlePageLoad › should handle errors during page load

    expect(jest.fn()).toHaveBeenCalledWith(...expected)

    Expected: "Error during auto-fill on load", [Error: Storage error]

    Number of calls: 0

      349 |     });
      350 |
    > 351 |     it('should return early when XPath collection not found', async () => {
          |                                      ^
      352 |       // Mock enabled website
      353 |       const mockAv1 = AutomationVariables.create({
      354 |         websiteId: 'website_1',

      at Object.<anonymous> (src/presentation/content-script/__tests__/AutoFillHandler.test.ts:351:38)

  ● AutoFillHandler › handlePageLoad › should sort enabled websites by automationVariables.updatedAt (newest first)

    expect(jest.fn()).toHaveBeenCalledWith(...expected)

    Expected: {"tabId": null, "websiteId": "website_2", "websiteVariables": {"username": "user2"}}

    Number of calls: 0

      397 |     it('should log error when auto-fill fails', async () => {
      398 |       // Mock enabled website
    > 399 |       const mockAv1 = AutomationVariables.create({
          |                                                   ^
      400 |         websiteId: 'website_1',
      401 |         status: 'enabled',
      402 |         variables: { username: 'user1' },

      at Object.<anonymous> (src/presentation/content-script/__tests__/AutoFillHandler.test.ts:399:59)

FAIL tests/integration/TabRecording.integration.test.ts
  ● Tab Recording Integration Tests › Complete Recording Flow › should start and stop recording successfully

    expect(received).not.toBeNull()

    Received: null

      190 |   beforeEach(() => {
      191 |     mockTabCaptureAdapter = new MockTabCaptureAdapter();
    > 192 |     mockRecordingRepository = new MockRecordingStorageRepository();
          |                                          ^
      193 |     mockSystemSettingsRepository = new MockSystemSettingsRepository();
      194 |     mockAutomationResultRepository = new MockAutomationResultRepository();
      195 |     mockLogger = new MockLogger();

      at Object.<anonymous> (tests/integration/TabRecording.integration.test.ts:192:42)

  ● Tab Recording Integration Tests › Tab Close Handling › should stop recording when tab is closed

    expect(received).not.toBeNull()

    Received: null

      236 |       expect(recording!.getAutomationResultId()).toBe(automationResultId);
      237 |       expect(recording!.getStatus()).toBe(RecordingStatus.RECORDING);
    > 238 |       expect(recording!.getTabId()).toBe(tabId);
          |                                          ^
      239 |
      240 |       // Wait for chunks to be processed
      241 |       await new Promise((resolve) => setTimeout(resolve, 50));

      at Object.<anonymous> (tests/integration/TabRecording.integration.test.ts:238:42)

  ● Tab Recording Integration Tests › Tab Close Handling › should handle stopping non-existent recording gracefully

    TypeError: Cannot read properties of null (reading 'isFailure')

      30 |     private logger: Logger
      31 |   ) {}
    > 32 |
         | ^
      33 |   // eslint-disable-next-line max-lines-per-function -- Recording stop requires extensive validation (recording exists, is recording, has recorderId) and detailed logging at each step for debugging. Splitting would separate validation logic from business logic, reducing code cohesion.
      34 |   async execute(input: StopTabRecordingInput): Promise<TabRecording | null> {
      35 |     this.logger.info('Starting stop tab recording use case', {

      at StopTabRecordingUseCase.execute (src/usecases/recording/StopTabRecordingUseCase.ts:32:29)
      at Object.<anonymous> (tests/integration/TabRecording.integration.test.ts:243:28)

  ● Tab Recording Integration Tests › Old Recordings Deletion › should delete recordings older than retention period

    TypeError: Cannot read properties of undefined (reading 'isFailure')

      20 |   async execute(_input: DeleteOldRecordingsInput): Promise<number> {
      21 |     const settingsResult = await this.systemSettingsRepository.load();
    > 22 |     if (settingsResult.isFailure) {
         |                          ^
      23 |       throw new Error(
      24 |         `Failed to load system settings: ${settingsResult.error?.message || 'Unknown error'}`
      25 |       );

      at DeleteOldRecordingsUseCase.execute (src/usecases/recording/DeleteOldRecordingsUseCase.ts:22:26)
      at Object.<anonymous> (tests/integration/TabRecording.integration.test.ts:274:13)

  ● Tab Recording Integration Tests › Old Recordings Deletion › should respect custom retention period

    TypeError: Cannot read properties of undefined (reading 'isFailure')

      20 |   async execute(_input: DeleteOldRecordingsInput): Promise<number> {
      21 |     const settingsResult = await this.systemSettingsRepository.load();
    > 22 |     if (settingsResult.isFailure) {
         |                          ^
      23 |       throw new Error(
      24 |         `Failed to load system settings: ${settingsResult.error?.message || 'Unknown error'}`
      25 |       );

      at DeleteOldRecordingsUseCase.execute (src/usecases/recording/DeleteOldRecordingsUseCase.ts:22:26)
      at Object.<anonymous> (tests/integration/TabRecording.integration.test.ts:296:13)

  ● Tab Recording Integration Tests › UI Recording Preview › should retrieve latest recording for automation variables

    expect(received).not.toBeNull()

    Received: null

      322 |       const oldDate = new Date();
      323 |       oldDate.setDate(oldDate.getDate() - 15); // 15 days ago
    > 324 |
          | ^
      325 |       const oldRecording = TabRecording.create({
      326 |         automationResultId: 'old-result',
      327 |         tabId: 1,

      at Object.<anonymous> (tests/integration/TabRecording.integration.test.ts:324:44)

  ● Tab Recording Integration Tests › UI Recording Preview › should return null if no recording exists

    TypeError: Cannot read properties of null (reading 'isFailure')

      13 |
      14 | export class GetLatestRecordingByVariablesIdUseCase {
    > 15 |   constructor(
         |               ^
      16 |     private recordingRepository: RecordingStorageRepository,
      17 |     private logger: Logger
      18 |   ) {}

      at GetLatestRecordingByVariablesIdUseCase.execute (src/usecases/recording/GetLatestRecordingByVariablesIdUseCase.ts:15:29)
      at Object.<anonymous> (tests/integration/TabRecording.integration.test.ts:329:31)

  ● Tab Recording Integration Tests › Error Handling › should handle recording stop failure gracefully

    expect(received).rejects.toThrow()

    Received promise resolved instead of rejected
    Resolved to value: null

      361 |
      362 |       const oldDate = new Date();
    > 363 |       oldDate.setDate(oldDate.getDate() - 25); // 25 days ago
          |                   ^
      364 |
      365 |       const recording = TabRecording.create({
      366 |         automationResultId: 'result-1',

      at expect (node_modules/expect/build/index.js:113:15)
      at Object.<anonymous> (tests/integration/TabRecording.integration.test.ts:363:19)

FAIL src/infrastructure/repositories/__tests__/IndexedDBRecordingRepository.test.ts
  ● IndexedDBRecordingRepository › save() › should handle save error

    expect(received).rejects.toThrow()

    Received promise resolved instead of rejected
    Resolved to value: {"_data": undefined, "_error": [Error: Put failed], "_isSuccess": false, "_value": undefined}

      217 |         id: recording.getId(),
      218 |         automationResultId: recording.getAutomationResultId(),
    > 219 |         tabId: recording.getTabId(),
          |                   ^
      220 |         status: recording.getStatus(),
      221 |         sizeBytes: recording.getSizeBytes(),
      222 |         sizeMB: recording.getSizeMB().toFixed(2),

      at expect (node_modules/expect/build/index.js:113:15)
      at Object.<anonymous> (src/infrastructure/repositories/__tests__/IndexedDBRecordingRepository.test.ts:219:19)

  ● IndexedDBRecordingRepository › load() › should return null when recording not found

    expect(received).toBeNull()

    Received: {"_data": undefined, "_error": undefined, "_isSuccess": true, "_value": null}

      310 |         close: jest.fn(),
      311 |       };
    > 312 |
          | ^
      313 |       const getRequest = {
      314 |         result: recordingData,
      315 |         onsuccess: null as any,

      at Object.<anonymous> (src/infrastructure/repositories/__tests__/IndexedDBRecordingRepository.test.ts:312:28)

  ● IndexedDBRecordingRepository › load() › should handle load error

    expect(received).rejects.toThrow()

    Received promise resolved instead of rejected
    Resolved to value: {"_data": undefined, "_error": [Error: Failed to load recording], "_isSuccess": false, "_value": undefined}

      338 |       expect(result.value).not.toBeNull();
      339 |       expect(result.value!.getId()).toBe(recordingId);
    > 340 |       expect(mockStore.get).toHaveBeenCalledWith(recordingId);
          |                   ^
      341 |       expect(mockDB.close).toHaveBeenCalled();
      342 |     });
      343 |

      at expect (node_modules/expect/build/index.js:113:15)
      at Object.<anonymous> (src/infrastructure/repositories/__tests__/IndexedDBRecordingRepository.test.ts:340:19)

  ● IndexedDBRecordingRepository › loadByAutomationResultId() › should return null when recording not found by automation result ID

    expect(received).toBeNull()

    Received: {"_data": undefined, "_error": undefined, "_isSuccess": true, "_value": null}

      429 |       const automationResultId = 'result-123';
      430 |       const recordingData = {
    > 431 |         id: 'recording-123',
          |                            ^
      432 |         automationResultId,
      433 |         tabId: 1,
      434 |         status: RecordingStatus.SAVED,

      at Object.<anonymous> (src/infrastructure/repositories/__tests__/IndexedDBRecordingRepository.test.ts:431:28)

  ● IndexedDBRecordingRepository › deleteOldRecordings() › should delete recordings older than retention period

    expect(received).toBe(expected) // Object.is equality

    Expected: 1
    Received: {"_data": undefined, "_error": undefined, "_isSuccess": true, "_value": 1}

      638 |       } as IDBRequest;
      639 |
    > 640 |       mockStore.delete.mockReturnValue(deleteRequest);
          |                                  ^
      641 |
      642 |       jest.spyOn(repository as any, 'openDB').mockResolvedValue(mockDB);
      643 |

      at Object.<anonymous> (src/infrastructure/repositories/__tests__/IndexedDBRecordingRepository.test.ts:640:34)

  ● IndexedDBRecordingRepository › loadLatestByAutomationVariablesId() › should return null when no automation results found

    expect(received).toBeNull()

    Received: {"_data": undefined, "_error": undefined, "_isSuccess": true, "_value": null}

      741 |
      742 |       const mockStore = {
    > 743 |         index: jest.fn().mockReturnValue(mockIndex),
          |                            ^
      744 |         delete: jest.fn(),
      745 |       };
      746 |

      at Object.<anonymous> (src/infrastructure/repositories/__tests__/IndexedDBRecordingRepository.test.ts:743:28)

  ● IndexedDBRecordingRepository › loadLatestByAutomationVariablesId() › should handle errors gracefully

    expect(received).toBeNull()

    Received: {"_data": undefined, "_error": [Error: Repository error], "_isSuccess": false, "_value": undefined}

      774 |             value: oldRecordingData,
      775 |             continue: jest.fn(),
    > 776 |           };
          |             ^
      777 |           cursorRequest.onsuccess({ target: cursorRequest } as any);
      778 |
      779 |           // Second cursor: recent recording

      at Object.<anonymous> (src/infrastructure/repositories/__tests__/IndexedDBRecordingRepository.test.ts:776:28)


Test Suites: 6 failed, 234 passed, 240 total
Tests:       48 failed, 5425 passed, 5473 total
Snapshots:   0 total
Time:        55.202 s, estimated 58 s
Ran all test suites.
