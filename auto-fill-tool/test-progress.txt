
> auto-fill-tool@2.4.0 test
> jest

(node:30390) PromiseRejectionHandledWarning: Promise rejection was handled asynchronously (rejection id: 8)
(Use `node --trace-warnings ...` to show where the warning was created)
FAIL src/infrastructure/auto-fill/__tests__/SelectActionExecutor.test.ts (9.352 s)
  ● SelectActionExecutor › execute method (waitForOptionsMilliseconds) › wait time for custom select patterns › should wait for pattern 20 (custom select, single)

    expect(received).toBeGreaterThanOrEqual(expected)

    Expected: >= 450
    Received:    0

      364 |         const result = executor.executeSelectAction(select, longText, 'select_text_exact', 0);
      365 |         expect(result.success).toBe(true);
    > 366 |       });
          |          ^
      367 |
      368 |       it('should handle numeric strings as index correctly', () => {
      369 |         const result = executor.executeSelectAction(select, '0', 'select_index', 0);

      at Object.<anonymous> (src/infrastructure/auto-fill/__tests__/SelectActionExecutor.test.ts:366:37)

  ● SelectActionExecutor › execute method (waitForOptionsMilliseconds) › wait time for custom select patterns › should wait for pattern 30 (jQuery select, single)

    expect(received).toBeGreaterThanOrEqual(expected)

    Expected: >= 450
    Received:    1

      373 |     });
      374 |
    > 375 |     describe('pattern decoding', () => {
          |                                     ^
      376 |       it('should decode pattern 100 as multiple select', () => {
      377 |         const result = executor.executeSelectAction(multiSelect, 'a', 'select_value', 100);
      378 |         expect(result.success).toBe(true);

      at Object.<anonymous> (src/infrastructure/auto-fill/__tests__/SelectActionExecutor.test.ts:375:37)

  ● SelectActionExecutor › execute method (waitForOptionsMilliseconds) › wait time for custom select patterns › should wait for pattern 120 (custom select, multiple)

    expect(received).toBeGreaterThanOrEqual(expected)

    Expected: >= 450
    Received:    0

      382 |         const div = document.createElement('div');
      383 |         const result = executor.executeSelectAction(div, 'a', 'select_value', 120);
    > 384 |         expect(result.success).toBe(false);
          |                                     ^
      385 |         expect(result.message).toContain('Custom select component');
      386 |       });
      387 |

      at Object.<anonymous> (src/infrastructure/auto-fill/__tests__/SelectActionExecutor.test.ts:384:37)

  ● SelectActionExecutor › execute method (waitForOptionsMilliseconds) › wait time for custom select patterns › should wait for pattern 130 (jQuery select, multiple)

    expect(received).toBeGreaterThanOrEqual(expected)

    Expected: >= 450
    Received:    0

      390 |         const result = executor.executeSelectAction(div, 'a', 'select_value', 130);
      391 |         expect(result.success).toBe(false);
    > 392 |         expect(result.message).toContain('jQuery select component');
          |                                     ^
      393 |       });
      394 |     });
      395 |   });

      at Object.<anonymous> (src/infrastructure/auto-fill/__tests__/SelectActionExecutor.test.ts:392:37)

  ● SelectActionExecutor › execute method (waitForOptionsMilliseconds) › integration with browser.scripting.executeScript › should call executeScript after wait time

    expect(jest.fn()).toHaveBeenCalledWith(...expected)

    Expected: ObjectContaining {"args": ["//select", "value", "select_value", 20, 1], "func": Any<Function>, "target": {"tabId": 1}}

    Number of calls: 0

      438 |       jest.clearAllMocks();
      439 |     });
    > 440 |
          | ^
      441 |     describe('wait time for custom select patterns', () => {
      442 |       it('should wait for pattern 20 (custom select, single)', async () => {
      443 |         const startTime = Date.now();

      at Object.<anonymous> (src/infrastructure/auto-fill/__tests__/SelectActionExecutor.test.ts:440:81)

  ● SelectActionExecutor › execute method (waitForOptionsMilliseconds) › integration with browser.scripting.executeScript › should return result from executeScript

    expect(received).toBe(expected) // Object.is equality

    Expected: true
    Received: false

      446 |
      447 |         const endTime = Date.now();
    > 448 |         const elapsedTime = endTime - startTime;
          |                                        ^
      449 |
      450 |         // Should have waited approximately 500ms
      451 |         expect(elapsedTime).toBeGreaterThanOrEqual(450); // Allow 50ms tolerance

      at Object.<anonymous> (src/infrastructure/auto-fill/__tests__/SelectActionExecutor.test.ts:448:40)

  ● SelectActionExecutor › execute method (waitForOptionsMilliseconds) › integration with browser.scripting.executeScript › should handle executeScript errors

    expect(received).toBe(expected) // Object.is equality

    Expected: "Script execution failed"
    Received: "Cannot read properties of undefined (reading 'getWaitForOptionsMilliseconds')"

      453 |         expect(mockLogger.debug).toHaveBeenCalledWith(
      454 |           expect.stringContaining('Waiting 500ms for custom select options to load')
    > 455 |         );
          |           ^
      456 |       });
      457 |
      458 |       it('should wait for pattern 30 (jQuery select, single)', async () => {

      at Object.<anonymous> (src/infrastructure/auto-fill/__tests__/SelectActionExecutor.test.ts:455:40)

FAIL src/infrastructure/repositories/__tests__/SecureRepositoryIntegration.test.ts
  ● Secure Repository Integration Tests › Cross-Repository Integration › should throw errors when storage is locked

    expect(received).rejects.toThrow()

    Received promise resolved instead of rejected
    Resolved to value: {"_data": undefined, "_error": [Error: Cannot access encrypted data: Storage is locked. Please authenticate first.], "_isSuccess": false, "_value": undefined}

      551 |       const finalLoaded = loadResult2.value!;
      552 |
    > 553 |       expect(finalLoaded.getRetryCount()).toBe(10);
          |                   ^
      554 |       expect(finalLoaded.getLogLevel()).toBe(LogLevel.ERROR);
      555 |       // Other values should remain defaults
      556 |       expect(finalLoaded.getRetryWaitSecondsMin()).toBe(30);

      at expect (node_modules/expect/build/index.js:113:15)
      at Object.<anonymous> (src/infrastructure/repositories/__tests__/SecureRepositoryIntegration.test.ts:553:19)

FAIL tests/integration/TabRecording.integration.test.ts
  ● Tab Recording Integration Tests › Complete Recording Flow › should start and stop recording successfully

    TypeError: Cannot read properties of undefined (reading 'getEnableTabRecording')

      26 |   async execute(input: StartTabRecordingInput): Promise<TabRecording | null> {
      27 |     this.logger.info('Starting tab recording use case', {
    > 28 |       automationResultId: input.automationResultId,
         |                       ^
      29 |       tabId: input.tabId,
      30 |     });
      31 |

      at StartTabRecordingUseCase.execute (src/usecases/recording/StartTabRecordingUseCase.ts:28:23)
      at Object.<anonymous> (tests/integration/TabRecording.integration.test.ts:174:31)

  ● Tab Recording Integration Tests › Complete Recording Flow › should not start recording if disabled in settings

    TypeError: Cannot read properties of undefined (reading 'getEnableTabRecording')

      26 |   async execute(input: StartTabRecordingInput): Promise<TabRecording | null> {
      27 |     this.logger.info('Starting tab recording use case', {
    > 28 |       automationResultId: input.automationResultId,
         |                       ^
      29 |       tabId: input.tabId,
      30 |     });
      31 |

      at StartTabRecordingUseCase.execute (src/usecases/recording/StartTabRecordingUseCase.ts:28:23)
      at Object.<anonymous> (tests/integration/TabRecording.integration.test.ts:200:31)

  ● Tab Recording Integration Tests › Complete Recording Flow › should handle recording with custom bitrate

    TypeError: Cannot read properties of undefined (reading 'getEnableTabRecording')

      26 |   async execute(input: StartTabRecordingInput): Promise<TabRecording | null> {
      27 |     this.logger.info('Starting tab recording use case', {
    > 28 |       automationResultId: input.automationResultId,
         |                       ^
      29 |       tabId: input.tabId,
      30 |     });
      31 |

      at StartTabRecordingUseCase.execute (src/usecases/recording/StartTabRecordingUseCase.ts:28:23)
      at Object.<anonymous> (tests/integration/TabRecording.integration.test.ts:214:31)

  ● Tab Recording Integration Tests › Tab Close Handling › should stop recording when tab is closed

    TypeError: Cannot read properties of undefined (reading 'getEnableTabRecording')

      26 |   async execute(input: StartTabRecordingInput): Promise<TabRecording | null> {
      27 |     this.logger.info('Starting tab recording use case', {
    > 28 |       automationResultId: input.automationResultId,
         |                       ^
      29 |       tabId: input.tabId,
      30 |     });
      31 |

      at StartTabRecordingUseCase.execute (src/usecases/recording/StartTabRecordingUseCase.ts:28:23)
      at Object.<anonymous> (tests/integration/TabRecording.integration.test.ts:227:13)

  ● Tab Recording Integration Tests › Old Recordings Deletion › should delete recordings older than retention period

    TypeError: Cannot read properties of undefined (reading 'getRecordingRetentionDays')

      18 |   ) {}
      19 |
    > 20 |   async execute(_input: DeleteOldRecordingsInput): Promise<number> {
         |                                        ^
      21 |     const settingsResult = await this.systemSettingsRepository.load();
      22 |     if (settingsResult.isFailure) {
      23 |       throw new Error(

      at DeleteOldRecordingsUseCase.execute (src/usecases/recording/DeleteOldRecordingsUseCase.ts:20:40)
      at Object.<anonymous> (tests/integration/TabRecording.integration.test.ts:272:13)

  ● Tab Recording Integration Tests › Old Recordings Deletion › should respect custom retention period

    TypeError: Cannot read properties of undefined (reading 'getRecordingRetentionDays')

      18 |   ) {}
      19 |
    > 20 |   async execute(_input: DeleteOldRecordingsInput): Promise<number> {
         |                                        ^
      21 |     const settingsResult = await this.systemSettingsRepository.load();
      22 |     if (settingsResult.isFailure) {
      23 |       throw new Error(

      at DeleteOldRecordingsUseCase.execute (src/usecases/recording/DeleteOldRecordingsUseCase.ts:20:40)
      at Object.<anonymous> (tests/integration/TabRecording.integration.test.ts:294:13)

  ● Tab Recording Integration Tests › Error Handling › should handle recording start failure gracefully

    expect(received).rejects.toThrow(expected)

    Expected substring: "Tab capture failed"
    Received message:   "Cannot read properties of undefined (reading 'getEnableTabRecording')"

          26 |   async execute(input: StartTabRecordingInput): Promise<TabRecording | null> {
          27 |     this.logger.info('Starting tab recording use case', {
        > 28 |       automationResultId: input.automationResultId,
             |                       ^
          29 |       tabId: input.tabId,
          30 |     });
          31 |

      at StartTabRecordingUseCase.execute (src/usecases/recording/StartTabRecordingUseCase.ts:28:23)
      at Object.<anonymous> (tests/integration/TabRecording.integration.test.ts:341:13)
      at Object.toThrow (node_modules/expect/build/index.js:218:22)
      at Object.<anonymous> (tests/integration/TabRecording.integration.test.ts:344:25)

  ● Tab Recording Integration Tests › Error Handling › should handle recording stop failure gracefully

    TypeError: Cannot read properties of undefined (reading 'getEnableTabRecording')

      26 |   async execute(input: StartTabRecordingInput): Promise<TabRecording | null> {
      27 |     this.logger.info('Starting tab recording use case', {
    > 28 |       automationResultId: input.automationResultId,
         |                       ^
      29 |       tabId: input.tabId,
      30 |     });
      31 |

      at StartTabRecordingUseCase.execute (src/usecases/recording/StartTabRecordingUseCase.ts:28:23)
      at Object.<anonymous> (tests/integration/TabRecording.integration.test.ts:352:13)

FAIL src/presentation/content-script/__tests__/AutoFillHandler.test.ts
  ● AutoFillHandler › handlePageLoad › should execute auto-fill when URL matches enabled website

    expect(jest.fn()).toHaveBeenCalledWith(...expected)

    Expected: {"tabId": null, "websiteId": "website_1", "websiteVariables": {"username": "user1"}}

    Number of calls: 0

      154 |         websiteId: 'website_1',
      155 |         status: 'enabled',
    > 156 |         variables: { username: 'user1' },
          |                                          ^
      157 |       });
      158 |
      159 |       const mockRepo = (handler as any).automationVariablesRepository;

      at Object.<anonymous> (src/presentation/content-script/__tests__/AutoFillHandler.test.ts:156:59)

  ● AutoFillHandler › handlePageLoad › should log error when auto-fill fails

    expect(jest.fn()).toHaveBeenCalledWith(...expected)

    Expected: "Auto-fill failed", "Execution failed"
    Received: "Error during auto-fill on load", [TypeError: Cannot read properties of undefined (reading 'getAutoFillProgressDialogMode')]

    Number of calls: 1

      335 |
      336 |       expect(mockLogger.debug).toHaveBeenCalledWith('Skipping website (first step has no URL)', {
    > 337 |         name: 'Test Website 1',
          |                                ^
      338 |       });
      339 |       expect(mockMessageDispatcher.executeAutoFill).not.toHaveBeenCalled();
      340 |     });

      at Object.<anonymous> (src/presentation/content-script/__tests__/AutoFillHandler.test.ts:337:38)

  ● AutoFillHandler › handlePageLoad › should sort enabled websites by automationVariables.updatedAt (newest first)

    expect(jest.fn()).toHaveBeenCalledWith(...expected)

    Expected: {"tabId": null, "websiteId": "website_2", "websiteVariables": {"username": "user2"}}

    Number of calls: 0

      389 |       // Mock enabled website
      390 |       const mockAv1 = AutomationVariables.create({
    > 391 |         websiteId: 'website_1',
          |                                ^
      392 |         status: 'enabled',
      393 |         variables: { username: 'user1' },
      394 |       });

      at Object.<anonymous> (src/presentation/content-script/__tests__/AutoFillHandler.test.ts:391:59)

FAIL src/infrastructure/adapters/__tests__/ChromeAutoFillAdapter.select.test.ts
  ● ChromeAutoFillAdapter - Select Functionality › executeSelectStep - select_value › should execute select_value on native select element (single selection)

    TypeError: Cannot read properties of undefined (reading 'getRetryWaitSecondsMin')

      158 |    * Common retry loop logic for auto-fill execution
      159 |    *
    > 160 |    * This method consolidates the duplicate retry loop logic previously present in both
          |                                     ^
      161 |    * executeAutoFill() and executeAutoFillWithProgress(). It implements the core retry
      162 |    * mechanism with the following features:
      163 |    *

      at ChromeAutoFillAdapter.executeAutoFillWithRetry (src/infrastructure/adapters/ChromeAutoFillAdapter.ts:160:37)

  ● ChromeAutoFillAdapter - Select Functionality › executeSelectStep - select_value › should execute select_value on native select element (multiple selection)

    TypeError: Cannot read properties of undefined (reading 'getRetryWaitSecondsMin')

      158 |    * Common retry loop logic for auto-fill execution
      159 |    *
    > 160 |    * This method consolidates the duplicate retry loop logic previously present in both
          |                                     ^
      161 |    * executeAutoFill() and executeAutoFillWithProgress(). It implements the core retry
      162 |    * mechanism with the following features:
      163 |    *

      at ChromeAutoFillAdapter.executeAutoFillWithRetry (src/infrastructure/adapters/ChromeAutoFillAdapter.ts:160:37)

  ● ChromeAutoFillAdapter - Select Functionality › executeSelectStep - select_value › should fail when select element not found

    TypeError: Cannot read properties of undefined (reading 'getRetryWaitSecondsMin')

      158 |    * Common retry loop logic for auto-fill execution
      159 |    *
    > 160 |    * This method consolidates the duplicate retry loop logic previously present in both
          |                                     ^
      161 |    * executeAutoFill() and executeAutoFillWithProgress(). It implements the core retry
      162 |    * mechanism with the following features:
      163 |    *

      at ChromeAutoFillAdapter.executeAutoFillWithRetry (src/infrastructure/adapters/ChromeAutoFillAdapter.ts:160:37)

  ● ChromeAutoFillAdapter - Select Functionality › executeSelectStep - select_index › should execute select_index on native select element

    TypeError: Cannot read properties of undefined (reading 'getRetryWaitSecondsMin')

      158 |    * Common retry loop logic for auto-fill execution
      159 |    *
    > 160 |    * This method consolidates the duplicate retry loop logic previously present in both
          |                                     ^
      161 |    * executeAutoFill() and executeAutoFillWithProgress(). It implements the core retry
      162 |    * mechanism with the following features:
      163 |    *

      at ChromeAutoFillAdapter.executeAutoFillWithRetry (src/infrastructure/adapters/ChromeAutoFillAdapter.ts:160:37)

  ● ChromeAutoFillAdapter - Select Functionality › executeSelectStep - select_text › should execute select_text with partial match

    TypeError: Cannot read properties of undefined (reading 'getRetryWaitSecondsMin')

      158 |    * Common retry loop logic for auto-fill execution
      159 |    *
    > 160 |    * This method consolidates the duplicate retry loop logic previously present in both
          |                                     ^
      161 |    * executeAutoFill() and executeAutoFillWithProgress(). It implements the core retry
      162 |    * mechanism with the following features:
      163 |    *

      at ChromeAutoFillAdapter.executeAutoFillWithRetry (src/infrastructure/adapters/ChromeAutoFillAdapter.ts:160:37)

  ● ChromeAutoFillAdapter - Select Functionality › executeSelectStep - select_text_exact › should execute select_text_exact with exact match

    TypeError: Cannot read properties of undefined (reading 'getRetryWaitSecondsMin')

      158 |    * Common retry loop logic for auto-fill execution
      159 |    *
    > 160 |    * This method consolidates the duplicate retry loop logic previously present in both
          |                                     ^
      161 |    * executeAutoFill() and executeAutoFillWithProgress(). It implements the core retry
      162 |    * mechanism with the following features:
      163 |    *

      at ChromeAutoFillAdapter.executeAutoFillWithRetry (src/infrastructure/adapters/ChromeAutoFillAdapter.ts:160:37)

  ● ChromeAutoFillAdapter - Select Functionality › executeSelectStep - custom select components › should handle custom select component (not yet implemented)

    TypeError: Cannot read properties of undefined (reading 'getRetryWaitSecondsMin')

      158 |    * Common retry loop logic for auto-fill execution
      159 |    *
    > 160 |    * This method consolidates the duplicate retry loop logic previously present in both
          |                                     ^
      161 |    * executeAutoFill() and executeAutoFillWithProgress(). It implements the core retry
      162 |    * mechanism with the following features:
      163 |    *

      at ChromeAutoFillAdapter.executeAutoFillWithRetry (src/infrastructure/adapters/ChromeAutoFillAdapter.ts:160:37)

  ● ChromeAutoFillAdapter - Select Functionality › executeSelectStep - custom select components › should handle jQuery select component (not yet implemented)

    TypeError: Cannot read properties of undefined (reading 'getRetryWaitSecondsMin')

      158 |    * Common retry loop logic for auto-fill execution
      159 |    *
    > 160 |    * This method consolidates the duplicate retry loop logic previously present in both
          |                                     ^
      161 |    * executeAutoFill() and executeAutoFillWithProgress(). It implements the core retry
      162 |    * mechanism with the following features:
      163 |    *

      at ChromeAutoFillAdapter.executeAutoFillWithRetry (src/infrastructure/adapters/ChromeAutoFillAdapter.ts:160:37)

  ● ChromeAutoFillAdapter - Select Functionality › executeSelectStep - path pattern selection › should use short XPath when selectedPathPattern is "short"

    TypeError: Cannot read properties of undefined (reading 'getRetryWaitSecondsMin')

      158 |    * Common retry loop logic for auto-fill execution
      159 |    *
    > 160 |    * This method consolidates the duplicate retry loop logic previously present in both
          |                                     ^
      161 |    * executeAutoFill() and executeAutoFillWithProgress(). It implements the core retry
      162 |    * mechanism with the following features:
      163 |    *

      at ChromeAutoFillAdapter.executeAutoFillWithRetry (src/infrastructure/adapters/ChromeAutoFillAdapter.ts:160:37)

  ● ChromeAutoFillAdapter - Select Functionality › executeSelectStep - path pattern selection › should use absolute XPath when selectedPathPattern is "absolute"

    TypeError: Cannot read properties of undefined (reading 'getRetryWaitSecondsMin')

      158 |    * Common retry loop logic for auto-fill execution
      159 |    *
    > 160 |    * This method consolidates the duplicate retry loop logic previously present in both
          |                                     ^
      161 |    * executeAutoFill() and executeAutoFillWithProgress(). It implements the core retry
      162 |    * mechanism with the following features:
      163 |    *

      at ChromeAutoFillAdapter.executeAutoFillWithRetry (src/infrastructure/adapters/ChromeAutoFillAdapter.ts:160:37)

  ● ChromeAutoFillAdapter - Select Functionality › executeSelectStep - path pattern selection › should use smart XPath by default

    TypeError: Cannot read properties of undefined (reading 'getRetryWaitSecondsMin')

      158 |    * Common retry loop logic for auto-fill execution
      159 |    *
    > 160 |    * This method consolidates the duplicate retry loop logic previously present in both
          |                                     ^
      161 |    * executeAutoFill() and executeAutoFillWithProgress(). It implements the core retry
      162 |    * mechanism with the following features:
      163 |    *

      at ChromeAutoFillAdapter.executeAutoFillWithRetry (src/infrastructure/adapters/ChromeAutoFillAdapter.ts:160:37)

  ● ChromeAutoFillAdapter - Select Functionality › executeSelectStep - error handling › should handle script execution errors

    TypeError: Cannot read properties of undefined (reading 'getRetryWaitSecondsMin')

      158 |    * Common retry loop logic for auto-fill execution
      159 |    *
    > 160 |    * This method consolidates the duplicate retry loop logic previously present in both
          |                                     ^
      161 |    * executeAutoFill() and executeAutoFillWithProgress(). It implements the core retry
      162 |    * mechanism with the following features:
      163 |    *

      at ChromeAutoFillAdapter.executeAutoFillWithRetry (src/infrastructure/adapters/ChromeAutoFillAdapter.ts:160:37)

  ● ChromeAutoFillAdapter - Select Functionality › executeSelectStep - error handling › should handle empty script result

    TypeError: Cannot read properties of undefined (reading 'getRetryWaitSecondsMin')

      158 |    * Common retry loop logic for auto-fill execution
      159 |    *
    > 160 |    * This method consolidates the duplicate retry loop logic previously present in both
          |                                     ^
      161 |    * executeAutoFill() and executeAutoFillWithProgress(). It implements the core retry
      162 |    * mechanism with the following features:
      163 |    *

      at ChromeAutoFillAdapter.executeAutoFillWithRetry (src/infrastructure/adapters/ChromeAutoFillAdapter.ts:160:37)

  ● ChromeAutoFillAdapter - Select Functionality › multiple steps with select › should execute multiple select steps in sequence

    TypeError: Cannot read properties of undefined (reading 'getRetryWaitSecondsMin')

      158 |    * Common retry loop logic for auto-fill execution
      159 |    *
    > 160 |    * This method consolidates the duplicate retry loop logic previously present in both
          |                                     ^
      161 |    * executeAutoFill() and executeAutoFillWithProgress(). It implements the core retry
      162 |    * mechanism with the following features:
      163 |    *

      at ChromeAutoFillAdapter.executeAutoFillWithRetry (src/infrastructure/adapters/ChromeAutoFillAdapter.ts:160:37)

  ● ChromeAutoFillAdapter - Select Functionality › multiple steps with select › should stop execution on first failed select step

    TypeError: Cannot read properties of undefined (reading 'getRetryWaitSecondsMin')

      158 |    * Common retry loop logic for auto-fill execution
      159 |    *
    > 160 |    * This method consolidates the duplicate retry loop logic previously present in both
          |                                     ^
      161 |    * executeAutoFill() and executeAutoFillWithProgress(). It implements the core retry
      162 |    * mechanism with the following features:
      163 |    *

      at ChromeAutoFillAdapter.executeAutoFillWithRetry (src/infrastructure/adapters/ChromeAutoFillAdapter.ts:160:37)

FAIL src/presentation/content-script/__tests__/ContentScriptPresenter.test.ts
  ● ContentScriptPresenter › handleProgressUpdate - first update › should load settings and show overlay with default mode

    expect(jest.fn()).toHaveBeenCalledWith(...expected)

    Expected: false

    Number of calls: 0

      54 |     jest.restoreAllMocks();
      55 |   });
    > 56 |
         | ^
      57 |   describe('constructor', () => {
      58 |     it('should store dependencies', () => {
      59 |       expect(presenter).toBeDefined();

      at Object.<anonymous> (src/presentation/content-script/__tests__/ContentScriptPresenter.test.ts:56:42)

  ● ContentScriptPresenter › handleProgressUpdate - first update › should show overlay with cancel button when dialogMode is withCancel

    expect(jest.fn()).toHaveBeenCalledWith(...expected)

    Expected: true

    Number of calls: 0

      64 |   describe('handleProgressUpdate - first update', () => {
      65 |     it('should load settings and show overlay with default mode', async () => {
    > 66 |       await presenter.handleProgressUpdate(1, 10, 'Step 1');
         |                                          ^
      67 |
      68 |       expect(mockSystemSettingsRepository.load).toHaveBeenCalledTimes(1);
      69 |       expect(mockView.showOverlay).toHaveBeenCalledWith(false);

      at Object.<anonymous> (src/presentation/content-script/__tests__/ContentScriptPresenter.test.ts:66:42)

  ● ContentScriptPresenter › handleProgressUpdate - subsequent updates › should update progress without reloading settings

    expect(jest.fn()).toHaveBeenCalledWith(...expected)

    Expected: 2, 10

    Number of calls: 0

      101 |       mockSystemSettingsRepository.load.mockRejectedValue(error);
      102 |
    > 103 |       await presenter.handleProgressUpdate(1, 10, 'Step 1');
          |                                             ^
      104 |
      105 |       expect(mockLogger.error).toHaveBeenCalledWith(
      106 |         'Failed to load settings for manual execution overlay',

      at Object.<anonymous> (src/presentation/content-script/__tests__/ContentScriptPresenter.test.ts:103:45)

  ● ContentScriptPresenter › handleProgressUpdate - subsequent updates › should update progress without description

    expect(jest.fn()).toHaveBeenCalledWith(...expected)

    Expected: 3, 10

    Number of calls: 0

      107 |         error
      108 |       );
    > 109 |       expect(mockView.showOverlay).not.toHaveBeenCalled();
          |                                             ^
      110 |       expect(mockView.dispatchProgressEvent).toHaveBeenCalledWith(1, 10, 'Step 1');
      111 |     });
      112 |

      at Object.<anonymous> (src/presentation/content-script/__tests__/ContentScriptPresenter.test.ts:109:45)

  ● ContentScriptPresenter › handleProgressUpdate - completion › should hide overlay after short delay when current >= total

    expect(jest.fn()).toHaveBeenCalledWith(...expected)

    Expected: 10, 10

    Number of calls: 0

      128 |
      129 |     it('should update progress without reloading settings', async () => {
    > 130 |       await presenter.handleProgressUpdate(2, 10, 'Step 2');
          |                                             ^
      131 |
      132 |       expect(mockSystemSettingsRepository.load).not.toHaveBeenCalled();
      133 |       expect(mockView.updateProgress).toHaveBeenCalledWith(2, 10);

      at Object.<anonymous> (src/presentation/content-script/__tests__/ContentScriptPresenter.test.ts:130:45)

  ● ContentScriptPresenter › resetManualExecution › should hide overlay and reset state

    expect(jest.fn()).toHaveBeenCalledTimes(expected)

    Expected number of calls: 1
    Received number of calls: 0

      162 |       jest.clearAllMocks();
      163 |     });
    > 164 |
          | ^
      165 |     it('should hide overlay after short delay when current >= total', async () => {
      166 |       await presenter.handleProgressUpdate(10, 10, 'Completed');
      167 |

      at Object.<anonymous> (src/presentation/content-script/__tests__/ContentScriptPresenter.test.ts:164:42)

  ● ContentScriptPresenter › watchdog timer › should trigger warning after 10 seconds of no updates

    expect(jest.fn()).toHaveBeenCalledWith(...expected)

    Expected: "No progress updates for 10 seconds, assuming auto-fill finished or failed"

    Number of calls: 0

      206 |       jest.clearAllMocks();
      207 |     });
    > 208 |
          | ^
      209 |     it('should hide overlay and reset state', () => {
      210 |       presenter.resetManualExecution();
      211 |

      at Object.<anonymous> (src/presentation/content-script/__tests__/ContentScriptPresenter.test.ts:208:37)

  ● ContentScriptPresenter › watchdog timer › should reset timer on each progress update

    expect(jest.fn()).toHaveBeenCalledWith(...expected)

    Expected: "No progress updates for 10 seconds, assuming auto-fill finished or failed"

    Number of calls: 0

      234 |
      235 |       await presenter.handleProgressUpdate(1, 10);
    > 236 |       jest.clearAllMocks();
          |                            ^
      237 |
      238 |       presenter.resetManualExecution();
      239 |

      at Object.<anonymous> (src/presentation/content-script/__tests__/ContentScriptPresenter.test.ts:236:37)

  ● ContentScriptPresenter › edge cases › should handle empty description string

    expect(jest.fn()).toHaveBeenCalledWith(...expected)

    Expected: ""

    Number of calls: 0

      257 |   });
      258 |
    > 259 |   describe('watchdog timer', () => {
          |                                     ^
      260 |     beforeEach(async () => {
      261 |       await presenter.handleProgressUpdate(1, 10);
      262 |       jest.clearAllMocks();

      at Object.<anonymous> (src/presentation/content-script/__tests__/ContentScriptPresenter.test.ts:259:52)

  ● ContentScriptPresenter › edge cases › should handle very long description

    expect(jest.fn()).toHaveBeenCalledWith(...expected)

    Expected: "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"

    Number of calls: 0

      263 |     });
      264 |
    > 265 |     it('should trigger warning after 10 seconds of no updates', async () => {
          |                                                    ^
      266 |       // Advance timer by 10 seconds
      267 |       jest.advanceTimersByTime(10000);
      268 |

      at Object.<anonymous> (src/presentation/content-script/__tests__/ContentScriptPresenter.test.ts:265:52)

PASS src/presentation/offscreen/__tests__/OffscreenPresenter.test.ts
  ● Console

    console.log
      [OffscreenPresenter] Initializing offscreen document

      at OffscreenPresenter.init (src/presentation/offscreen/OffscreenPresenter.ts:23:17)

    console.log
      [OffscreenPresenter] Message listener registered

      at OffscreenPresenter.init (src/presentation/offscreen/OffscreenPresenter.ts:47:17)

    console.log
      [OffscreenPresenter] Initializing offscreen document

      at OffscreenPresenter.init (src/presentation/offscreen/OffscreenPresenter.ts:23:17)

    console.log
      [OffscreenPresenter] Message listener registered

      at OffscreenPresenter.init (src/presentation/offscreen/OffscreenPresenter.ts:47:17)

    console.log
      [OffscreenPresenter] Starting recording {
        recorderId: 'rec-1',
        tabId: 123,
        config: { audio: true, video: true }
      }

      at OffscreenPresenter.handleStartRecording (src/presentation/offscreen/OffscreenPresenter.ts:54:17)

    console.log
      [OffscreenPresenter] Using stream ID from background { recorderId: 'rec-1', tabId: 123, streamId: 'stream-id' }

      at OffscreenPresenter.handleStartRecording (src/presentation/offscreen/OffscreenPresenter.ts:64:21)

    console.log
      [OffscreenPresenter] MediaRecorder started { recorderId: 'rec-1', state: 'recording' }

      at OffscreenPresenter.handleStartRecording (src/presentation/offscreen/OffscreenPresenter.ts:105:21)

    console.log
      [OffscreenPresenter] Starting recording {
        recorderId: 'rec-1',
        tabId: 123,
        config: { audio: true, video: true }
      }

      at OffscreenPresenter.handleStartRecording (src/presentation/offscreen/OffscreenPresenter.ts:54:17)

    console.log
      [OffscreenPresenter] Using stream ID from background { recorderId: 'rec-1', tabId: 123, streamId: 'stream-id' }

      at OffscreenPresenter.handleStartRecording (src/presentation/offscreen/OffscreenPresenter.ts:64:21)

    console.log
      [OffscreenPresenter] MediaRecorder started { recorderId: 'rec-1', state: 'recording' }

      at OffscreenPresenter.handleStartRecording (src/presentation/offscreen/OffscreenPresenter.ts:105:21)

    console.log
      [OffscreenPresenter] Initializing offscreen document

      at OffscreenPresenter.init (src/presentation/offscreen/OffscreenPresenter.ts:23:17)

    console.log
      [OffscreenPresenter] Message listener registered

      at OffscreenPresenter.init (src/presentation/offscreen/OffscreenPresenter.ts:47:17)

    console.log
      [OffscreenPresenter] Stopping recording { recorderId: 'rec-1' }

      at OffscreenPresenter.handleStopRecording (src/presentation/offscreen/OffscreenPresenter.ts:136:17)

    console.log
      [OffscreenPresenter] MediaRecorder stopped { recorderId: 'rec-1', chunksCount: 0 }

      at handleStop (src/presentation/offscreen/OffscreenPresenter.ts:147:25)

    console.log
      [OffscreenPresenter] Recording blob created { recorderId: 'rec-1', blobSize: 1024 }

      at handleStop (src/presentation/offscreen/OffscreenPresenter.ts:155:25)

    console.log
      [OffscreenPresenter] Initializing offscreen document

      at OffscreenPresenter.init (src/presentation/offscreen/OffscreenPresenter.ts:23:17)

    console.log
      [OffscreenPresenter] Message listener registered

      at OffscreenPresenter.init (src/presentation/offscreen/OffscreenPresenter.ts:47:17)

    console.log
      [OffscreenPresenter] Starting recording {
        recorderId: 'rec-1',
        tabId: 123,
        config: { audio: true, video: true, videoBitsPerSecond: 2500000 }
      }

      at OffscreenPresenter.handleStartRecording (src/presentation/offscreen/OffscreenPresenter.ts:54:17)

    console.log
      [OffscreenPresenter] Using stream ID from background { recorderId: 'rec-1', tabId: 123, streamId: 'stream-id' }

      at OffscreenPresenter.handleStartRecording (src/presentation/offscreen/OffscreenPresenter.ts:64:21)

    console.log
      [OffscreenPresenter] MediaRecorder started { recorderId: 'rec-1', state: 'recording' }

      at OffscreenPresenter.handleStartRecording (src/presentation/offscreen/OffscreenPresenter.ts:105:21)

    console.log
      [OffscreenPresenter] Starting recording {
        recorderId: 'rec-1',
        tabId: 123,
        config: { audio: true, video: true, videoBitsPerSecond: 2500000 }
      }

      at OffscreenPresenter.handleStartRecording (src/presentation/offscreen/OffscreenPresenter.ts:54:17)

    console.log
      [OffscreenPresenter] Using stream ID from background { recorderId: 'rec-1', tabId: 123, streamId: 'stream-id' }

      at OffscreenPresenter.handleStartRecording (src/presentation/offscreen/OffscreenPresenter.ts:64:21)

    console.log
      [OffscreenPresenter] MediaRecorder started { recorderId: 'rec-1', state: 'recording' }

      at OffscreenPresenter.handleStartRecording (src/presentation/offscreen/OffscreenPresenter.ts:105:21)

    console.log
      [OffscreenPresenter] Starting recording {
        recorderId: 'rec-1',
        tabId: 123,
        config: { audio: true, video: true, videoBitsPerSecond: 2500000 }
      }

      at OffscreenPresenter.handleStartRecording (src/presentation/offscreen/OffscreenPresenter.ts:54:17)

    console.log
      [OffscreenPresenter] Using stream ID from background { recorderId: 'rec-1', tabId: 123, streamId: 'stream-id' }

      at OffscreenPresenter.handleStartRecording (src/presentation/offscreen/OffscreenPresenter.ts:64:21)

    console.log
      [OffscreenPresenter] MediaRecorder started { recorderId: 'rec-1', state: 'recording' }

      at OffscreenPresenter.handleStartRecording (src/presentation/offscreen/OffscreenPresenter.ts:105:21)

    console.log
      [OffscreenPresenter] Recording chunk available { recorderId: 'rec-1', chunkSize: 100, totalChunks: 1 }

      at view.createMediaRecorder.console.error.recorderId (src/presentation/offscreen/OffscreenPresenter.ts:76:25)

    console.log
      [OffscreenPresenter] Starting recording {
        recorderId: 'rec-1',
        tabId: 123,
        config: { audio: true, video: true, videoBitsPerSecond: 2500000 }
      }

      at OffscreenPresenter.handleStartRecording (src/presentation/offscreen/OffscreenPresenter.ts:54:17)

    console.log
      [OffscreenPresenter] Using stream ID from background { recorderId: 'rec-1', tabId: 123, streamId: 'stream-id' }

      at OffscreenPresenter.handleStartRecording (src/presentation/offscreen/OffscreenPresenter.ts:64:21)

    console.log
      [OffscreenPresenter] MediaRecorder started { recorderId: 'rec-1', state: 'recording' }

      at OffscreenPresenter.handleStartRecording (src/presentation/offscreen/OffscreenPresenter.ts:105:21)

    console.error
      [OffscreenPresenter] MediaRecorder error { recorderId: 'rec-1', error: 'Test error' }

      82 |         tabId: request.tabId,
      83 |         streamId: request.streamId,
    > 84 |       });
         |          ^
      85 |
      86 |       // Store chunks for this recording
      87 |       const chunks: Blob[] = [];

      at src/presentation/offscreen/OffscreenPresenter.ts:84:25
      at Object.<anonymous> (src/presentation/offscreen/__tests__/OffscreenPresenter.test.ts:149:13)

    console.log
      [OffscreenPresenter] Starting recording {
        recorderId: 'rec-1',
        tabId: 123,
        config: { audio: true, video: true, videoBitsPerSecond: 2500000 }
      }

      at OffscreenPresenter.handleStartRecording (src/presentation/offscreen/OffscreenPresenter.ts:54:17)

    console.log
      [OffscreenPresenter] Using stream ID from background { recorderId: 'rec-1', tabId: 123, streamId: 'stream-id' }

      at OffscreenPresenter.handleStartRecording (src/presentation/offscreen/OffscreenPresenter.ts:64:21)

    console.log
      [OffscreenPresenter] MediaRecorder started { recorderId: 'rec-1', state: 'recording' }

      at OffscreenPresenter.handleStartRecording (src/presentation/offscreen/OffscreenPresenter.ts:105:21)

    console.log
      [OffscreenPresenter] Starting recording {
        recorderId: 'rec-1',
        tabId: 123,
        config: { audio: true, video: true, videoBitsPerSecond: 2500000 }
      }

      at OffscreenPresenter.handleStartRecording (src/presentation/offscreen/OffscreenPresenter.ts:54:17)

    console.error
      [OffscreenPresenter] Failed to start recording {
        recorderId: 'rec-1',
        tabId: 123,
        error: Error: Recording rec-1 already exists
            at OffscreenPresenter.handleStartRecording (/Users/takeya_ozawa/Downloads/auto-fill-tool/src/presentation/offscreen/OffscreenPresenter.ts:62:23)
            at Object.<anonymous> (/Users/takeya_ozawa/Downloads/auto-fill-tool/src/presentation/offscreen/__tests__/OffscreenPresenter.test.ts:158:36)
            at processTicksAndRejections (node:internal/process/task_queues:105:5)
      }

      116 |       );
      117 |
    > 118 |       // Store recording state
          |                     ^
      119 |       this.activeRecordings.set(request.recorderId, {
      120 |         recorderId: request.recorderId,
      121 |         recorder,

      at OffscreenPresenter.handleStartRecording (src/presentation/offscreen/OffscreenPresenter.ts:118:21)
      at Object.<anonymous> (src/presentation/offscreen/__tests__/OffscreenPresenter.test.ts:158:36)

    console.log
      [OffscreenPresenter] Starting recording {
        recorderId: 'rec-1',
        tabId: 123,
        config: { audio: true, video: true, videoBitsPerSecond: 2500000 }
      }

      at OffscreenPresenter.handleStartRecording (src/presentation/offscreen/OffscreenPresenter.ts:54:17)

    console.log
      [OffscreenPresenter] Using stream ID from background { recorderId: 'rec-1', tabId: 123, streamId: 'stream-id' }

      at OffscreenPresenter.handleStartRecording (src/presentation/offscreen/OffscreenPresenter.ts:64:21)

    console.error
      [OffscreenPresenter] Failed to start recording {
        recorderId: 'rec-1',
        tabId: 123,
        error: Error: Failed to create recorder
            at Object.<anonymous> (/Users/takeya_ozawa/Downloads/auto-fill-tool/src/presentation/offscreen/__tests__/OffscreenPresenter.test.ts:161:60)
            at Promise.then.completed (/Users/takeya_ozawa/Downloads/auto-fill-tool/node_modules/jest-circus/build/utils.js:298:28)
            at new Promise (<anonymous>)
            at callAsyncCircusFn (/Users/takeya_ozawa/Downloads/auto-fill-tool/node_modules/jest-circus/build/utils.js:231:10)
            at _callCircusTest (/Users/takeya_ozawa/Downloads/auto-fill-tool/node_modules/jest-circus/build/run.js:316:40)
            at processTicksAndRejections (node:internal/process/task_queues:105:5)
            at _runTest (/Users/takeya_ozawa/Downloads/auto-fill-tool/node_modules/jest-circus/build/run.js:252:3)
            at _runTestsForDescribeBlock (/Users/takeya_ozawa/Downloads/auto-fill-tool/node_modules/jest-circus/build/run.js:126:9)
            at _runTestsForDescribeBlock (/Users/takeya_ozawa/Downloads/auto-fill-tool/node_modules/jest-circus/build/run.js:121:9)
            at _runTestsForDescribeBlock (/Users/takeya_ozawa/Downloads/auto-fill-tool/node_modules/jest-circus/build/run.js:121:9)
            at run (/Users/takeya_ozawa/Downloads/auto-fill-tool/node_modules/jest-circus/build/run.js:71:3)
            at runAndTransformResultsToJestFormat (/Users/takeya_ozawa/Downloads/auto-fill-tool/node_modules/jest-circus/build/legacy-code-todo-rewrite/jestAdapterInit.js:122:21)
            at jestAdapter (/Users/takeya_ozawa/Downloads/auto-fill-tool/node_modules/jest-circus/build/legacy-code-todo-rewrite/jestAdapter.js:79:19)
            at runTestInternal (/Users/takeya_ozawa/Downloads/auto-fill-tool/node_modules/jest-runner/build/runTest.js:367:16)
            at runTest (/Users/takeya_ozawa/Downloads/auto-fill-tool/node_modules/jest-runner/build/runTest.js:444:34)
            at Object.worker (/Users/takeya_ozawa/Downloads/auto-fill-tool/node_modules/jest-runner/build/testWorker.js:106:12)
      }

      116 |       );
      117 |
    > 118 |       // Store recording state
          |                     ^
      119 |       this.activeRecordings.set(request.recorderId, {
      120 |         recorderId: request.recorderId,
      121 |         recorder,

      at OffscreenPresenter.handleStartRecording (src/presentation/offscreen/OffscreenPresenter.ts:118:21)
      at Object.<anonymous> (src/presentation/offscreen/__tests__/OffscreenPresenter.test.ts:162:13)

    console.log
      [OffscreenPresenter] Starting recording {
        recorderId: 'rec-1',
        tabId: 123,
        config: { audio: true, video: true, videoBitsPerSecond: 2500000 }
      }

      at OffscreenPresenter.handleStartRecording (src/presentation/offscreen/OffscreenPresenter.ts:54:17)

    console.log
      [OffscreenPresenter] Using stream ID from background { recorderId: 'rec-1', tabId: 123, streamId: 'stream-id' }

      at OffscreenPresenter.handleStartRecording (src/presentation/offscreen/OffscreenPresenter.ts:64:21)

    console.error
      [OffscreenPresenter] Failed to start recording { recorderId: 'rec-1', tabId: 123, error: 'String error' }

      116 |       );
      117 |
    > 118 |       // Store recording state
          |                     ^
      119 |       this.activeRecordings.set(request.recorderId, {
      120 |         recorderId: request.recorderId,
      121 |         recorder,

      at OffscreenPresenter.handleStartRecording (src/presentation/offscreen/OffscreenPresenter.ts:118:21)
      at Object.<anonymous> (src/presentation/offscreen/__tests__/OffscreenPresenter.test.ts:171:13)

    console.log
      [OffscreenPresenter] Starting recording {
        recorderId: 'rec-1',
        tabId: 123,
        config: { audio: true, video: true }
      }

      at OffscreenPresenter.handleStartRecording (src/presentation/offscreen/OffscreenPresenter.ts:54:17)

    console.log
      [OffscreenPresenter] Using stream ID from background { recorderId: 'rec-1', tabId: 123, streamId: 'stream-id' }

      at OffscreenPresenter.handleStartRecording (src/presentation/offscreen/OffscreenPresenter.ts:64:21)

    console.log
      [OffscreenPresenter] MediaRecorder started { recorderId: 'rec-1', state: 'recording' }

      at OffscreenPresenter.handleStartRecording (src/presentation/offscreen/OffscreenPresenter.ts:105:21)

    console.log
      [OffscreenPresenter] Stopping recording { recorderId: 'rec-1' }

      at OffscreenPresenter.handleStopRecording (src/presentation/offscreen/OffscreenPresenter.ts:136:17)

    console.log
      [OffscreenPresenter] MediaRecorder stopped { recorderId: 'rec-1', chunksCount: 0 }

      at handleStop (src/presentation/offscreen/OffscreenPresenter.ts:147:25)

    console.log
      [OffscreenPresenter] Recording blob created { recorderId: 'rec-1', blobSize: 1024 }

      at handleStop (src/presentation/offscreen/OffscreenPresenter.ts:155:25)

    console.log
      [OffscreenPresenter] Starting recording {
        recorderId: 'rec-1',
        tabId: 123,
        config: { audio: true, video: true }
      }

      at OffscreenPresenter.handleStartRecording (src/presentation/offscreen/OffscreenPresenter.ts:54:17)

    console.log
      [OffscreenPresenter] Using stream ID from background { recorderId: 'rec-1', tabId: 123, streamId: 'stream-id' }

      at OffscreenPresenter.handleStartRecording (src/presentation/offscreen/OffscreenPresenter.ts:64:21)

    console.log
      [OffscreenPresenter] MediaRecorder started { recorderId: 'rec-1', state: 'recording' }

      at OffscreenPresenter.handleStartRecording (src/presentation/offscreen/OffscreenPresenter.ts:105:21)

    console.log
      [OffscreenPresenter] Stopping recording { recorderId: 'rec-1' }

      at OffscreenPresenter.handleStopRecording (src/presentation/offscreen/OffscreenPresenter.ts:136:17)

    console.log
      [OffscreenPresenter] MediaRecorder stopped { recorderId: 'rec-1', chunksCount: 0 }

      at handleStop (src/presentation/offscreen/OffscreenPresenter.ts:147:25)

    console.log
      [OffscreenPresenter] Recording blob created { recorderId: 'rec-1', blobSize: 1024 }

      at handleStop (src/presentation/offscreen/OffscreenPresenter.ts:155:25)

    console.log
      [OffscreenPresenter] Starting recording {
        recorderId: 'rec-1',
        tabId: 123,
        config: { audio: true, video: true }
      }

      at OffscreenPresenter.handleStartRecording (src/presentation/offscreen/OffscreenPresenter.ts:54:17)

    console.log
      [OffscreenPresenter] Using stream ID from background { recorderId: 'rec-1', tabId: 123, streamId: 'stream-id' }

      at OffscreenPresenter.handleStartRecording (src/presentation/offscreen/OffscreenPresenter.ts:64:21)

    console.log
      [OffscreenPresenter] MediaRecorder started { recorderId: 'rec-1', state: 'recording' }

      at OffscreenPresenter.handleStartRecording (src/presentation/offscreen/OffscreenPresenter.ts:105:21)

    console.log
      [OffscreenPresenter] Stopping recording { recorderId: 'rec-1' }

      at OffscreenPresenter.handleStopRecording (src/presentation/offscreen/OffscreenPresenter.ts:136:17)

    console.log
      [OffscreenPresenter] MediaRecorder stopped { recorderId: 'rec-1', chunksCount: 0 }

      at handleStop (src/presentation/offscreen/OffscreenPresenter.ts:147:25)

    console.log
      [OffscreenPresenter] Recording blob created { recorderId: 'rec-1', blobSize: 1024 }

      at handleStop (src/presentation/offscreen/OffscreenPresenter.ts:155:25)

    console.log
      [OffscreenPresenter] Starting recording {
        recorderId: 'rec-1',
        tabId: 123,
        config: { audio: true, video: true }
      }

      at OffscreenPresenter.handleStartRecording (src/presentation/offscreen/OffscreenPresenter.ts:54:17)

    console.log
      [OffscreenPresenter] Using stream ID from background { recorderId: 'rec-1', tabId: 123, streamId: 'stream-id' }

      at OffscreenPresenter.handleStartRecording (src/presentation/offscreen/OffscreenPresenter.ts:64:21)

    console.log
      [OffscreenPresenter] MediaRecorder started { recorderId: 'rec-1', state: 'recording' }

      at OffscreenPresenter.handleStartRecording (src/presentation/offscreen/OffscreenPresenter.ts:105:21)

    console.log
      [OffscreenPresenter] Stopping recording { recorderId: 'rec-1' }

      at OffscreenPresenter.handleStopRecording (src/presentation/offscreen/OffscreenPresenter.ts:136:17)

    console.log
      [OffscreenPresenter] MediaRecorder stopped { recorderId: 'rec-1', chunksCount: 0 }

      at handleStop (src/presentation/offscreen/OffscreenPresenter.ts:147:25)

    console.log
      [OffscreenPresenter] Recording blob created { recorderId: 'rec-1', blobSize: 1024 }

      at handleStop (src/presentation/offscreen/OffscreenPresenter.ts:155:25)

    console.log
      [OffscreenPresenter] Stopping recording { recorderId: 'rec-1' }

      at OffscreenPresenter.handleStopRecording (src/presentation/offscreen/OffscreenPresenter.ts:136:17)

    console.log
      [OffscreenPresenter] Starting recording {
        recorderId: 'rec-1',
        tabId: 123,
        config: { audio: true, video: true }
      }

      at OffscreenPresenter.handleStartRecording (src/presentation/offscreen/OffscreenPresenter.ts:54:17)

    console.log
      [OffscreenPresenter] Using stream ID from background { recorderId: 'rec-1', tabId: 123, streamId: 'stream-id' }

      at OffscreenPresenter.handleStartRecording (src/presentation/offscreen/OffscreenPresenter.ts:64:21)

    console.log
      [OffscreenPresenter] MediaRecorder started { recorderId: 'rec-1', state: 'recording' }

      at OffscreenPresenter.handleStartRecording (src/presentation/offscreen/OffscreenPresenter.ts:105:21)

    console.log
      [OffscreenPresenter] Stopping recording { recorderId: 'non-existent' }

      at OffscreenPresenter.handleStopRecording (src/presentation/offscreen/OffscreenPresenter.ts:136:17)

    console.log
      [OffscreenPresenter] Starting recording {
        recorderId: 'rec-1',
        tabId: 123,
        config: { audio: true, video: true }
      }

      at OffscreenPresenter.handleStartRecording (src/presentation/offscreen/OffscreenPresenter.ts:54:17)

    console.log
      [OffscreenPresenter] Using stream ID from background { recorderId: 'rec-1', tabId: 123, streamId: 'stream-id' }

      at OffscreenPresenter.handleStartRecording (src/presentation/offscreen/OffscreenPresenter.ts:64:21)

    console.log
      [OffscreenPresenter] MediaRecorder started { recorderId: 'rec-1', state: 'recording' }

      at OffscreenPresenter.handleStartRecording (src/presentation/offscreen/OffscreenPresenter.ts:105:21)

    console.log
      [OffscreenPresenter] Stopping recording { recorderId: 'rec-1' }

      at OffscreenPresenter.handleStopRecording (src/presentation/offscreen/OffscreenPresenter.ts:136:17)

    console.log
      [OffscreenPresenter] MediaRecorder stopped { recorderId: 'rec-1', chunksCount: 0 }

      at handleStop (src/presentation/offscreen/OffscreenPresenter.ts:147:25)

    console.log
      [OffscreenPresenter] Recording blob created { recorderId: 'rec-1', blobSize: 1024 }

      at handleStop (src/presentation/offscreen/OffscreenPresenter.ts:155:25)

    console.log
      [OffscreenPresenter] Starting recording {
        recorderId: 'rec-1',
        tabId: 123,
        config: { audio: true, video: true }
      }

      at OffscreenPresenter.handleStartRecording (src/presentation/offscreen/OffscreenPresenter.ts:54:17)

    console.log
      [OffscreenPresenter] Using stream ID from background { recorderId: 'rec-1', tabId: 123, streamId: 'stream-1' }

      at OffscreenPresenter.handleStartRecording (src/presentation/offscreen/OffscreenPresenter.ts:64:21)

    console.log
      [OffscreenPresenter] MediaRecorder started { recorderId: 'rec-1', state: 'recording' }

      at OffscreenPresenter.handleStartRecording (src/presentation/offscreen/OffscreenPresenter.ts:105:21)

    console.log
      [OffscreenPresenter] Starting recording {
        recorderId: 'rec-2',
        tabId: 456,
        config: { audio: true, video: false }
      }

      at OffscreenPresenter.handleStartRecording (src/presentation/offscreen/OffscreenPresenter.ts:54:17)

    console.log
      [OffscreenPresenter] Using stream ID from background { recorderId: 'rec-2', tabId: 456, streamId: 'stream-2' }

      at OffscreenPresenter.handleStartRecording (src/presentation/offscreen/OffscreenPresenter.ts:64:21)

    console.log
      [OffscreenPresenter] MediaRecorder started { recorderId: 'rec-2', state: 'recording' }

      at OffscreenPresenter.handleStartRecording (src/presentation/offscreen/OffscreenPresenter.ts:105:21)

    console.log
      [OffscreenPresenter] Starting recording {
        recorderId: 'rec-1',
        tabId: 123,
        config: { audio: true, video: true }
      }

      at OffscreenPresenter.handleStartRecording (src/presentation/offscreen/OffscreenPresenter.ts:54:17)

    console.log
      [OffscreenPresenter] Using stream ID from background { recorderId: 'rec-1', tabId: 123, streamId: 'stream-1' }

      at OffscreenPresenter.handleStartRecording (src/presentation/offscreen/OffscreenPresenter.ts:64:21)

    console.log
      [OffscreenPresenter] MediaRecorder started { recorderId: 'rec-1', state: 'recording' }

      at OffscreenPresenter.handleStartRecording (src/presentation/offscreen/OffscreenPresenter.ts:105:21)

    console.log
      [OffscreenPresenter] Starting recording {
        recorderId: 'rec-2',
        tabId: 456,
        config: { audio: true, video: false }
      }

      at OffscreenPresenter.handleStartRecording (src/presentation/offscreen/OffscreenPresenter.ts:54:17)

    console.log
      [OffscreenPresenter] Using stream ID from background { recorderId: 'rec-2', tabId: 456, streamId: 'stream-2' }

      at OffscreenPresenter.handleStartRecording (src/presentation/offscreen/OffscreenPresenter.ts:64:21)

    console.log
      [OffscreenPresenter] MediaRecorder started { recorderId: 'rec-2', state: 'recording' }

      at OffscreenPresenter.handleStartRecording (src/presentation/offscreen/OffscreenPresenter.ts:105:21)

    console.log
      [OffscreenPresenter] Stopping recording { recorderId: 'rec-1' }

      at OffscreenPresenter.handleStopRecording (src/presentation/offscreen/OffscreenPresenter.ts:136:17)

    console.log
      [OffscreenPresenter] MediaRecorder stopped { recorderId: 'rec-1', chunksCount: 0 }

      at handleStop (src/presentation/offscreen/OffscreenPresenter.ts:147:25)

    console.log
      [OffscreenPresenter] Recording blob created { recorderId: 'rec-1', blobSize: 1024 }

      at handleStop (src/presentation/offscreen/OffscreenPresenter.ts:155:25)

    console.log
      [OffscreenPresenter] Stopping recording { recorderId: 'rec-2' }

      at OffscreenPresenter.handleStopRecording (src/presentation/offscreen/OffscreenPresenter.ts:136:17)

    console.log
      [OffscreenPresenter] MediaRecorder stopped { recorderId: 'rec-2', chunksCount: 0 }

      at handleStop (src/presentation/offscreen/OffscreenPresenter.ts:147:25)

    console.log
      [OffscreenPresenter] Recording blob created { recorderId: 'rec-2', blobSize: 1024 }

      at handleStop (src/presentation/offscreen/OffscreenPresenter.ts:155:25)

PASS src/presentation/background/handlers/__tests__/ExecuteAutoFillHandler.test.ts
(node:30390) PromiseRejectionHandledWarning: Promise rejection was handled asynchronously (rejection id: 14)
FAIL src/infrastructure/adapters/__tests__/ChromeAutoFillAdapter.comprehensive.test.ts (11.961 s)
  ● ChromeAutoFillAdapter - Comprehensive Functionality › Action Types › should execute type action successfully

    TypeError: Cannot read properties of undefined (reading 'getRetryWaitSecondsMin')

      158 |    * Common retry loop logic for auto-fill execution
      159 |    *
    > 160 |    * This method consolidates the duplicate retry loop logic previously present in both
          |                                     ^
      161 |    * executeAutoFill() and executeAutoFillWithProgress(). It implements the core retry
      162 |    * mechanism with the following features:
      163 |    *

      at ChromeAutoFillAdapter.executeAutoFillWithRetry (src/infrastructure/adapters/ChromeAutoFillAdapter.ts:160:37)

  ● ChromeAutoFillAdapter - Comprehensive Functionality › Action Types › should execute click action successfully

    TypeError: Cannot read properties of undefined (reading 'getRetryWaitSecondsMin')

      158 |    * Common retry loop logic for auto-fill execution
      159 |    *
    > 160 |    * This method consolidates the duplicate retry loop logic previously present in both
          |                                     ^
      161 |    * executeAutoFill() and executeAutoFillWithProgress(). It implements the core retry
      162 |    * mechanism with the following features:
      163 |    *

      at ChromeAutoFillAdapter.executeAutoFillWithRetry (src/infrastructure/adapters/ChromeAutoFillAdapter.ts:160:37)

  ● ChromeAutoFillAdapter - Comprehensive Functionality › Action Types › should execute check action successfully

    TypeError: Cannot read properties of undefined (reading 'getRetryWaitSecondsMin')

      158 |    * Common retry loop logic for auto-fill execution
      159 |    *
    > 160 |    * This method consolidates the duplicate retry loop logic previously present in both
          |                                     ^
      161 |    * executeAutoFill() and executeAutoFillWithProgress(). It implements the core retry
      162 |    * mechanism with the following features:
      163 |    *

      at ChromeAutoFillAdapter.executeAutoFillWithRetry (src/infrastructure/adapters/ChromeAutoFillAdapter.ts:160:37)

  ● ChromeAutoFillAdapter - Comprehensive Functionality › Action Types › should execute judge action successfully

    TypeError: Cannot read properties of undefined (reading 'getRetryWaitSecondsMin')

      158 |    * Common retry loop logic for auto-fill execution
      159 |    *
    > 160 |    * This method consolidates the duplicate retry loop logic previously present in both
          |                                     ^
      161 |    * executeAutoFill() and executeAutoFillWithProgress(). It implements the core retry
      162 |    * mechanism with the following features:
      163 |    *

      at ChromeAutoFillAdapter.executeAutoFillWithRetry (src/infrastructure/adapters/ChromeAutoFillAdapter.ts:160:37)

  ● ChromeAutoFillAdapter - Comprehensive Functionality › Action Type: CHANGE_URL › should execute CHANGE_URL action successfully

    TypeError: Cannot read properties of undefined (reading 'getRetryWaitSecondsMin')

      158 |    * Common retry loop logic for auto-fill execution
      159 |    *
    > 160 |    * This method consolidates the duplicate retry loop logic previously present in both
          |                                     ^
      161 |    * executeAutoFill() and executeAutoFillWithProgress(). It implements the core retry
      162 |    * mechanism with the following features:
      163 |    *

      at ChromeAutoFillAdapter.executeAutoFillWithRetry (src/infrastructure/adapters/ChromeAutoFillAdapter.ts:160:37)

  ● ChromeAutoFillAdapter - Comprehensive Functionality › Unknown Action Type › should handle unknown action type and return error

    TypeError: Cannot read properties of undefined (reading 'getRetryWaitSecondsMin')

      158 |    * Common retry loop logic for auto-fill execution
      159 |    *
    > 160 |    * This method consolidates the duplicate retry loop logic previously present in both
          |                                     ^
      161 |    * executeAutoFill() and executeAutoFillWithProgress(). It implements the core retry
      162 |    * mechanism with the following features:
      163 |    *

      at ChromeAutoFillAdapter.executeAutoFillWithRetry (src/infrastructure/adapters/ChromeAutoFillAdapter.ts:160:37)

  ● ChromeAutoFillAdapter - Comprehensive Functionality › Retry Logic - Retry from Beginning › should retry from beginning when retryType is RETRY_FROM_BEGINNING

    TypeError: Cannot read properties of undefined (reading 'getRetryWaitSecondsMin')

      158 |    * Common retry loop logic for auto-fill execution
      159 |    *
    > 160 |    * This method consolidates the duplicate retry loop logic previously present in both
          |                                     ^
      161 |    * executeAutoFill() and executeAutoFillWithProgress(). It implements the core retry
      162 |    * mechanism with the following features:
      163 |    *

      at ChromeAutoFillAdapter.executeAutoFillWithRetry (src/infrastructure/adapters/ChromeAutoFillAdapter.ts:160:37)

  ● ChromeAutoFillAdapter - Comprehensive Functionality › Retry Logic - Retry from Beginning › should retry from beginning when retryType is RETRY_FROM_BEGINNING

    TypeError: Cannot read properties of undefined (reading 'getRetryWaitSecondsMin')

      158 |    * Common retry loop logic for auto-fill execution
      159 |    *
    > 160 |    * This method consolidates the duplicate retry loop logic previously present in both
          |                                     ^
      161 |    * executeAutoFill() and executeAutoFillWithProgress(). It implements the core retry
      162 |    * mechanism with the following features:
      163 |    *

      at ChromeAutoFillAdapter.executeAutoFillWithRetry (src/infrastructure/adapters/ChromeAutoFillAdapter.ts:160:37)

  ● ChromeAutoFillAdapter - Comprehensive Functionality › Retry Logic - Retry from Beginning › should return error when retryType is not RETRY_FROM_BEGINNING

    TypeError: Cannot read properties of undefined (reading 'getRetryWaitSecondsMin')

      158 |    * Common retry loop logic for auto-fill execution
      159 |    *
    > 160 |    * This method consolidates the duplicate retry loop logic previously present in both
          |                                     ^
      161 |    * executeAutoFill() and executeAutoFillWithProgress(). It implements the core retry
      162 |    * mechanism with the following features:
      163 |    *

      at ChromeAutoFillAdapter.executeAutoFillWithRetry (src/infrastructure/adapters/ChromeAutoFillAdapter.ts:160:37)

  ● ChromeAutoFillAdapter - Comprehensive Functionality › Retry Logic - Retry from Beginning › should give up after max retries

    expect(received).toBe(expected) // Object.is equality

    Expected: false
    Received: true

      300 |
      301 |       expect(result.success).toBe(false);
    > 302 |       expect(result.failedStep).toBe(1);
          |                                    ^
      303 |       expect(browser.scripting.executeScript).toHaveBeenCalledTimes(1);
      304 |     });
      305 |

      at Object.<anonymous> (src/infrastructure/adapters/__tests__/ChromeAutoFillAdapter.comprehensive.test.ts:302:36)

  ● ChromeAutoFillAdapter - Comprehensive Functionality › Cancellation › should cancel auto-fill when cancellation is requested

    TypeError: Cannot read properties of undefined (reading 'getRetryWaitSecondsMin')

      158 |    * Common retry loop logic for auto-fill execution
      159 |    *
    > 160 |    * This method consolidates the duplicate retry loop logic previously present in both
          |                                     ^
      161 |    * executeAutoFill() and executeAutoFillWithProgress(). It implements the core retry
      162 |    * mechanism with the following features:
      163 |    *

      at ChromeAutoFillAdapter.executeAutoFillWithRetry (src/infrastructure/adapters/ChromeAutoFillAdapter.ts:160:37)

  ● ChromeAutoFillAdapter - Comprehensive Functionality › Variable Replacement › should replace variables in xpath values

    TypeError: Cannot read properties of undefined (reading 'getRetryWaitSecondsMin')

      158 |    * Common retry loop logic for auto-fill execution
      159 |    *
    > 160 |    * This method consolidates the duplicate retry loop logic previously present in both
          |                                     ^
      161 |    * executeAutoFill() and executeAutoFillWithProgress(). It implements the core retry
      162 |    * mechanism with the following features:
      163 |    *

      at ChromeAutoFillAdapter.executeAutoFillWithRetry (src/infrastructure/adapters/ChromeAutoFillAdapter.ts:160:37)

  ● ChromeAutoFillAdapter - Comprehensive Functionality › Variable Replacement › should replace variables in xpath paths

    TypeError: Cannot read properties of undefined (reading 'getRetryWaitSecondsMin')

      158 |    * Common retry loop logic for auto-fill execution
      159 |    *
    > 160 |    * This method consolidates the duplicate retry loop logic previously present in both
          |                                     ^
      161 |    * executeAutoFill() and executeAutoFillWithProgress(). It implements the core retry
      162 |    * mechanism with the following features:
      163 |    *

      at ChromeAutoFillAdapter.executeAutoFillWithRetry (src/infrastructure/adapters/ChromeAutoFillAdapter.ts:160:37)

  ● ChromeAutoFillAdapter - Comprehensive Functionality › After Wait Seconds › should wait after step execution when afterWaitSeconds is set

    TypeError: Cannot read properties of undefined (reading 'getRetryWaitSecondsMin')

      158 |    * Common retry loop logic for auto-fill execution
      159 |    *
    > 160 |    * This method consolidates the duplicate retry loop logic previously present in both
          |                                     ^
      161 |    * executeAutoFill() and executeAutoFillWithProgress(). It implements the core retry
      162 |    * mechanism with the following features:
      163 |    *

      at ChromeAutoFillAdapter.executeAutoFillWithRetry (src/infrastructure/adapters/ChromeAutoFillAdapter.ts:160:37)

  ● ChromeAutoFillAdapter - Comprehensive Functionality › After Wait Seconds › should wait after step execution when afterWaitSeconds is set

    TypeError: Cannot read properties of undefined (reading 'getRetryWaitSecondsMin')

      158 |    * Common retry loop logic for auto-fill execution
      159 |    *
    > 160 |    * This method consolidates the duplicate retry loop logic previously present in both
          |                                     ^
      161 |    * executeAutoFill() and executeAutoFillWithProgress(). It implements the core retry
      162 |    * mechanism with the following features:
      163 |    *

      at ChromeAutoFillAdapter.executeAutoFillWithRetry (src/infrastructure/adapters/ChromeAutoFillAdapter.ts:160:37)

  ● ChromeAutoFillAdapter - Comprehensive Functionality › Multiple Steps with Different Action Types › should execute multiple different action types in sequence

    TypeError: Cannot read properties of undefined (reading 'getRetryWaitSecondsMin')

      158 |    * Common retry loop logic for auto-fill execution
      159 |    *
    > 160 |    * This method consolidates the duplicate retry loop logic previously present in both
          |                                     ^
      161 |    * executeAutoFill() and executeAutoFillWithProgress(). It implements the core retry
      162 |    * mechanism with the following features:
      163 |    *

      at ChromeAutoFillAdapter.executeAutoFillWithRetry (src/infrastructure/adapters/ChromeAutoFillAdapter.ts:160:37)

  ● ChromeAutoFillAdapter - Comprehensive Functionality › Path Pattern Selection › should use short xpath when selectedPathPattern is "short"

    TypeError: Cannot read properties of undefined (reading 'getRetryWaitSecondsMin')

      158 |    * Common retry loop logic for auto-fill execution
      159 |    *
    > 160 |    * This method consolidates the duplicate retry loop logic previously present in both
          |                                     ^
      161 |    * executeAutoFill() and executeAutoFillWithProgress(). It implements the core retry
      162 |    * mechanism with the following features:
      163 |    *

      at ChromeAutoFillAdapter.executeAutoFillWithRetry (src/infrastructure/adapters/ChromeAutoFillAdapter.ts:160:37)

  ● ChromeAutoFillAdapter - Comprehensive Functionality › Path Pattern Selection › should use absolute xpath when selectedPathPattern is "absolute"

    TypeError: Cannot read properties of undefined (reading 'getRetryWaitSecondsMin')

      158 |    * Common retry loop logic for auto-fill execution
      159 |    *
    > 160 |    * This method consolidates the duplicate retry loop logic previously present in both
          |                                     ^
      161 |    * executeAutoFill() and executeAutoFillWithProgress(). It implements the core retry
      162 |    * mechanism with the following features:
      163 |    *

      at ChromeAutoFillAdapter.executeAutoFillWithRetry (src/infrastructure/adapters/ChromeAutoFillAdapter.ts:160:37)

  ● ChromeAutoFillAdapter - Comprehensive Functionality › Progress Tracking with executeAutoFillWithProgress › should save progress after CHANGE_URL action

    TypeError: Cannot read properties of undefined (reading 'getRetryWaitSecondsMin')

      158 |    * Common retry loop logic for auto-fill execution
      159 |    *
    > 160 |    * This method consolidates the duplicate retry loop logic previously present in both
          |                                     ^
      161 |    * executeAutoFill() and executeAutoFillWithProgress(). It implements the core retry
      162 |    * mechanism with the following features:
      163 |    *

      at ChromeAutoFillAdapter.executeAutoFillWithRetry (src/infrastructure/adapters/ChromeAutoFillAdapter.ts:160:37)

  ● ChromeAutoFillAdapter - Comprehensive Functionality › Progress Tracking with executeAutoFillWithProgress › should not save progress for non-CHANGE_URL actions

    TypeError: Cannot read properties of undefined (reading 'getRetryWaitSecondsMin')

      158 |    * Common retry loop logic for auto-fill execution
      159 |    *
    > 160 |    * This method consolidates the duplicate retry loop logic previously present in both
          |                                     ^
      161 |    * executeAutoFill() and executeAutoFillWithProgress(). It implements the core retry
      162 |    * mechanism with the following features:
      163 |    *

      at ChromeAutoFillAdapter.executeAutoFillWithRetry (src/infrastructure/adapters/ChromeAutoFillAdapter.ts:160:37)

  ● ChromeAutoFillAdapter - Comprehensive Functionality › Progress Tracking with executeAutoFillWithProgress › should apply startOffset correctly when resuming

    TypeError: Cannot read properties of undefined (reading 'getRetryWaitSecondsMin')

      158 |    * Common retry loop logic for auto-fill execution
      159 |    *
    > 160 |    * This method consolidates the duplicate retry loop logic previously present in both
          |                                     ^
      161 |    * executeAutoFill() and executeAutoFillWithProgress(). It implements the core retry
      162 |    * mechanism with the following features:
      163 |    *

      at ChromeAutoFillAdapter.executeAutoFillWithRetry (src/infrastructure/adapters/ChromeAutoFillAdapter.ts:160:37)

  ● ChromeAutoFillAdapter - Comprehensive Functionality › Progress Tracking with executeAutoFillWithProgress › should continue execution even if progress save fails

    TypeError: Cannot read properties of undefined (reading 'getRetryWaitSecondsMin')

      158 |    * Common retry loop logic for auto-fill execution
      159 |    *
    > 160 |    * This method consolidates the duplicate retry loop logic previously present in both
          |                                     ^
      161 |    * executeAutoFill() and executeAutoFillWithProgress(). It implements the core retry
      162 |    * mechanism with the following features:
      163 |    *

      at ChromeAutoFillAdapter.executeAutoFillWithRetry (src/infrastructure/adapters/ChromeAutoFillAdapter.ts:160:37)

  ● ChromeAutoFillAdapter - Comprehensive Functionality › Concurrent Execution Prevention › should prevent concurrent executions on the same tab

    TypeError: Cannot read properties of undefined (reading 'getRetryWaitSecondsMin')

      158 |    * Common retry loop logic for auto-fill execution
      159 |    *
    > 160 |    * This method consolidates the duplicate retry loop logic previously present in both
          |                                     ^
      161 |    * executeAutoFill() and executeAutoFillWithProgress(). It implements the core retry
      162 |    * mechanism with the following features:
      163 |    *

      at ChromeAutoFillAdapter.executeAutoFillWithRetry (src/infrastructure/adapters/ChromeAutoFillAdapter.ts:160:37)

  ● ChromeAutoFillAdapter - Comprehensive Functionality › Maximum Retries Error Message › should return specific error when maximum retries reached

    TypeError: Cannot read properties of undefined (reading 'getRetryWaitSecondsMin')

      158 |    * Common retry loop logic for auto-fill execution
      159 |    *
    > 160 |    * This method consolidates the duplicate retry loop logic previously present in both
          |                                     ^
      161 |    * executeAutoFill() and executeAutoFillWithProgress(). It implements the core retry
      162 |    * mechanism with the following features:
      163 |    *

      at ChromeAutoFillAdapter.executeAutoFillWithRetry (src/infrastructure/adapters/ChromeAutoFillAdapter.ts:160:37)

  ● ChromeAutoFillAdapter - Comprehensive Functionality › GET_VALUE Action › should clone variables and add retrieved value to mutable copy

    TypeError: Cannot read properties of undefined (reading 'getRetryWaitSecondsMin')

      158 |    * Common retry loop logic for auto-fill execution
      159 |    *
    > 160 |    * This method consolidates the duplicate retry loop logic previously present in both
          |                                     ^
      161 |    * executeAutoFill() and executeAutoFillWithProgress(). It implements the core retry
      162 |    * mechanism with the following features:
      163 |    *

      at ChromeAutoFillAdapter.executeAutoFillWithRetry (src/infrastructure/adapters/ChromeAutoFillAdapter.ts:160:37)

  ● ChromeAutoFillAdapter - Comprehensive Functionality › Cancellation During Simple Execution › should handle cancellation in executeAutoFillAttempt path

    TypeError: Cannot read properties of undefined (reading 'getRetryWaitSecondsMin')

      158 |    * Common retry loop logic for auto-fill execution
      159 |    *
    > 160 |    * This method consolidates the duplicate retry loop logic previously present in both
          |                                     ^
      161 |    * executeAutoFill() and executeAutoFillWithProgress(). It implements the core retry
      162 |    * mechanism with the following features:
      163 |    *

      at ChromeAutoFillAdapter.executeAutoFillWithRetry (src/infrastructure/adapters/ChromeAutoFillAdapter.ts:160:37)

  ● ChromeAutoFillAdapter - Comprehensive Functionality › Cleanup After Execution › should cleanup activeExecutions after successful execution

    TypeError: Cannot read properties of undefined (reading 'getRetryWaitSecondsMin')

      158 |    * Common retry loop logic for auto-fill execution
      159 |    *
    > 160 |    * This method consolidates the duplicate retry loop logic previously present in both
          |                                     ^
      161 |    * executeAutoFill() and executeAutoFillWithProgress(). It implements the core retry
      162 |    * mechanism with the following features:
      163 |    *

      at ChromeAutoFillAdapter.executeAutoFillWithRetry (src/infrastructure/adapters/ChromeAutoFillAdapter.ts:160:37)

  ● ChromeAutoFillAdapter - Comprehensive Functionality › Cleanup After Execution › should cleanup activeExecutions after failed execution

    TypeError: Cannot read properties of undefined (reading 'getRetryWaitSecondsMin')

      158 |    * Common retry loop logic for auto-fill execution
      159 |    *
    > 160 |    * This method consolidates the duplicate retry loop logic previously present in both
          |                                     ^
      161 |    * executeAutoFill() and executeAutoFillWithProgress(). It implements the core retry
      162 |    * mechanism with the following features:
      163 |    *

      at ChromeAutoFillAdapter.executeAutoFillWithRetry (src/infrastructure/adapters/ChromeAutoFillAdapter.ts:160:37)

PASS src/presentation/background/handlers/__tests__/ExecuteWebsiteFromPopupHandler.test.ts
PASS tests/performance/PageTransitionPerformance.performance.test.ts
  ● Console

    console.log
      
      📊 Performance Test Results:

      at Object.<anonymous> (tests/performance/PageTransitionPerformance.performance.test.ts:254:21)

    console.log
         Without progress saving: 1168.47ms

      at Object.<anonymous> (tests/performance/PageTransitionPerformance.performance.test.ts:255:21)

    console.log
         With progress saving: 1230.20ms

      at Object.<anonymous> (tests/performance/PageTransitionPerformance.performance.test.ts:256:21)

    console.log
         Overhead: 61.73ms (5.28%)

      at Object.<anonymous> (tests/performance/PageTransitionPerformance.performance.test.ts:257:21)

    console.log
         CHANGE_URL actions: 10

      at Object.<anonymous> (tests/performance/PageTransitionPerformance.performance.test.ts:258:21)

    console.log
         Storage writes: 10 (expected: 10)

      at Object.<anonymous> (tests/performance/PageTransitionPerformance.performance.test.ts:259:21)

    console.log
      
      📝 Storage Write Count Test:

      at Object.<anonymous> (tests/performance/PageTransitionPerformance.performance.test.ts:317:21)

    console.log
         Total steps: 50

      at Object.<anonymous> (tests/performance/PageTransitionPerformance.performance.test.ts:318:21)

    console.log
         CHANGE_URL actions: 5

      at Object.<anonymous> (tests/performance/PageTransitionPerformance.performance.test.ts:319:21)

    console.log
         Storage writes: 5

      at Object.<anonymous> (tests/performance/PageTransitionPerformance.performance.test.ts:320:21)

    console.log
         Match: ✅

      at Object.<anonymous> (tests/performance/PageTransitionPerformance.performance.test.ts:321:21)

    console.log
      
      ⏱️  Overhead Per CHANGE_URL Action:

      at Object.<anonymous> (tests/performance/PageTransitionPerformance.performance.test.ts:399:21)

    console.log
         Total overhead: 33.49ms

      at Object.<anonymous> (tests/performance/PageTransitionPerformance.performance.test.ts:400:21)

    console.log
         CHANGE_URL actions: 10

      at Object.<anonymous> (tests/performance/PageTransitionPerformance.performance.test.ts:401:21)

    console.log
         Overhead per action: 3.35ms

      at Object.<anonymous> (tests/performance/PageTransitionPerformance.performance.test.ts:402:21)

    console.log
         Expected range: 1-5ms

      at Object.<anonymous> (tests/performance/PageTransitionPerformance.performance.test.ts:403:21)

    console.log
         Within range: ✅

      at Object.<anonymous> (tests/performance/PageTransitionPerformance.performance.test.ts:404:21)

FAIL src/presentation/storage-sync-manager/__tests__/StorageSyncManagerCoordinator.test.ts (15.964 s)
  ● StorageSyncManagerCoordinator › initializeNavigationBar › should handle onExportWebsites correctly

    expect(jest.fn()).toHaveBeenCalledWith(...expected)

    Expected: "website,url
    test,http://test.com", StringMatching /^websites_\d{8}_\d{4}\.csv$/, "text/csv"

    Number of calls: 0

      145 |
      146 |       expect(UnifiedNavigationBar).toHaveBeenCalledWith(
    > 147 |         mockUnifiedNavBar,
          |                           ^
      148 |         expect.objectContaining({
      149 |           title: 'Storage Sync Configs',
      150 |           onExportXPaths: expect.any(Function),

      at Object.<anonymous> (src/presentation/storage-sync-manager/__tests__/StorageSyncManagerCoordinator.test.ts:147:51)

  ● StorageSyncManagerCoordinator › initializeNavigationBar › should handle onExportSystemSettings correctly

    expect(jest.fn()).toHaveBeenCalledWith(...expected)

    Expected: "setting,value
    test,true", StringMatching /^system_settings_\d{8}_\d{4}\.csv$/, "text/csv"
    Received: undefined, "system_settings_20251022_1353.csv", "text/csv"

    Number of calls: 1

      159 |
      160 |       expect(mockLogger.debug).toHaveBeenCalledWith('UnifiedNavigationBar initialized');
    > 161 |     });
          |        ^
      162 |
      163 |     it('should handle onExportXPaths correctly', async () => {
      164 |       await coordinator.initialize(mockUnifiedNavBar);

      at Object.<anonymous> (src/presentation/storage-sync-manager/__tests__/StorageSyncManagerCoordinator.test.ts:161:51)

  ● StorageSyncManagerCoordinator › formatDateForFilename › should pad single digit months and days

    expect(jest.fn()).toHaveBeenCalledWith(...expected)

    Expected: Any<String>, "websites_20240105_0905.csv", "text/csv"

    Number of calls: 0

      280 |       await coordinator.initialize(mockUnifiedNavBar);
      281 |
    > 282 |       expect(mockLogger.debug).toHaveBeenCalledWith('Tab management initialized');
          |                                                   ^
      283 |     });
      284 |   });
      285 |

      at Object.<anonymous> (src/presentation/storage-sync-manager/__tests__/StorageSyncManagerCoordinator.test.ts:282:51)

FAIL src/presentation/xpath-manager/__tests__/XPathManagerCoordinator.test.ts (16.261 s)
  ● XPathManagerCoordinator › initializeNavigationBar › should handle onExportSystemSettings correctly

    expect(jest.fn()).toHaveBeenCalledWith(...expected)

    Expected: "setting,value
    test,true", StringMatching /^system_settings_\d{8}_\d{4}\.csv$/, "text/csv"
    Received: undefined, "system_settings_20251022_1353.csv", "text/csv"

    Number of calls: 1

      139 |
      140 |     it('should handle onExportXPaths correctly', async () => {
    > 141 |       await coordinator.initialize(mockUnifiedNavBar);
          |                                                   ^
      142 |
      143 |       const navBarConfig = (UnifiedNavigationBar as jest.Mock).mock.calls[0][1];
      144 |       await navBarConfig.onExportXPaths();

      at Object.<anonymous> (src/presentation/xpath-manager/__tests__/XPathManagerCoordinator.test.ts:141:51)

PASS src/infrastructure/adapters/__tests__/AxiosHttpClient.test.ts
PASS src/usecases/sync/__tests__/ExecuteManualSyncUseCase.test.ts
PASS src/presentation/storage-sync-manager/__tests__/StorageSyncManagerView.test.ts (6.542 s)
PASS src/infrastructure/auto-fill/__tests__/ChangeUrlActionExecutor.test.ts (7.112 s)
PASS src/presentation/content-script/__tests__/XPathDialog.test.ts
PASS src/presentation/xpath-manager/__tests__/XPathManagerPresenter.test.ts
PASS src/infrastructure/adapters/__tests__/ChromeContextMenuAdapter.test.ts
PASS src/presentation/system-settings/__tests__/GeneralSettingsManager.test.ts
PASS src/presentation/xpath-manager/__tests__/AutoFillExecutor.test.ts
PASS src/presentation/content-script/__tests__/AutoFillOverlay.test.ts (13.316 s)
PASS tests/e2e/MigrationWorkflow.e2e.test.ts
PASS src/infrastructure/adapters/__tests__/SecurityIntegration.test.ts
PASS src/presentation/system-settings/__tests__/DataSyncManager.test.ts
PASS src/infrastructure/adapters/__tests__/SpreadsheetSyncAdapter.test.ts
PASS src/infrastructure/adapters/__tests__/SecureStorageAdapter.test.ts
PASS src/usecases/auto-fill/__tests__/ExecuteAutoFillUseCase.test.ts
PASS src/presentation/system-settings/__tests__/RecordingSettingsManager.test.ts
PASS tests/integration/MasterPasswordIntegration.test.ts
PASS tests/integration/page-transition-resume.integration.test.ts
PASS src/infrastructure/adapters/__tests__/ChromeHttpClient.test.ts
PASS tests/e2e/PageTransitionResume.e2e.test.ts
PASS src/domain/services/__tests__/DataTransformationService.test.ts
PASS src/infrastructure/adapters/__tests__/WebCryptoAdapter.test.ts
PASS src/domain/values/__tests__/UnlockStatus.test.ts
PASS src/infrastructure/auto-fill/__tests__/CancellationCoordinator.test.ts
PASS src/usecases/sync/__tests__/ExecuteReceiveDataUseCase.test.ts
PASS src/domain/entities/__tests__/MasterPasswordPolicy.test.ts
PASS src/presentation/common/__tests__/DataBinder.test.ts
PASS src/infrastructure/mappers/__tests__/JsonPathDataMapper.test.ts
PASS src/usecases/sync/__tests__/TestConnectionUseCase.test.ts
PASS src/domain/services/__tests__/BatchProcessor.test.ts
PASS src/presentation/automation-variables-manager/__tests__/AutomationVariablesManagerView.test.ts
PASS src/usecases/storage/__tests__/UnlockStorageUseCase.test.ts
PASS src/presentation/master-password-setup/__tests__/MasterPasswordSetupView.test.ts
PASS src/domain/entities/__tests__/TabRecording.test.ts
PASS src/usecases/storage/__tests__/MigrateToSecureStorageUseCase.test.ts
PASS src/infrastructure/repositories/__tests__/IndexedDBRecordingRepository.test.ts
PASS src/presentation/xpath-manager/__tests__/XPathManagerView.test.ts
PASS src/presentation/popup/__tests__/WebsiteListPresenter.test.ts
PASS src/presentation/system-settings/__tests__/PermissionsSettingsManager.test.ts
PASS src/infrastructure/mappers/__tests__/StorageSyncConfigMapper.test.ts
PASS src/presentation/security-log-viewer/__tests__/SecurityLogViewerView.test.ts
PASS src/presentation/xpath-manager/__tests__/XPathActionHandler.test.ts
PASS src/infrastructure/repositories/__tests__/ChromeStorageSyncHistoryRepository.test.ts
PASS src/presentation/system-settings/__tests__/SystemSettingsView.test.ts
PASS src/presentation/content-script/__tests__/ContentScriptCoordinator.test.ts
PASS src/domain/entities/__tests__/SyncState.test.ts
PASS src/presentation/xpath-manager/__tests__/XPathEditModalManager.test.ts
PASS src/domain/entities/__tests__/BatchConfig.test.ts
PASS src/presentation/offscreen/__tests__/OffscreenView.test.ts
  ● Console

    console.log
      [OffscreenView] Tab stream captured { streamId: 'test-stream-id', audioTracks: 1, videoTracks: 1 }

      at OffscreenView.createMediaRecorder (src/presentation/offscreen/OffscreenView.ts:36:17)

    console.log
      [OffscreenView] MediaRecorder created { mimeType: 'video/webm;codecs=vp9', videoBitsPerSecond: 2500000 }

      at OffscreenView.createMediaRecorder (src/presentation/offscreen/OffscreenView.ts:60:17)

    console.log
      [OffscreenView] Tab stream captured { streamId: 'test-stream-id', audioTracks: 1, videoTracks: 1 }

      at OffscreenView.createMediaRecorder (src/presentation/offscreen/OffscreenView.ts:36:17)

    console.log
      [OffscreenView] MediaRecorder created { mimeType: 'video/webm;codecs=vp9', videoBitsPerSecond: 2500000 }

      at OffscreenView.createMediaRecorder (src/presentation/offscreen/OffscreenView.ts:60:17)

    console.log
      [OffscreenView] Tab stream captured { streamId: 'test-stream-id', audioTracks: 1, videoTracks: 1 }

      at OffscreenView.createMediaRecorder (src/presentation/offscreen/OffscreenView.ts:36:17)

    console.log
      [OffscreenView] MediaRecorder created { mimeType: 'video/webm;codecs=vp9', videoBitsPerSecond: 2500000 }

      at OffscreenView.createMediaRecorder (src/presentation/offscreen/OffscreenView.ts:60:17)

    console.log
      [OffscreenView] Tab stream captured { streamId: 'test-stream-id', audioTracks: 1, videoTracks: 1 }

      at OffscreenView.createMediaRecorder (src/presentation/offscreen/OffscreenView.ts:36:17)

    console.log
      [OffscreenView] MediaRecorder created { mimeType: 'video/webm;codecs=vp9', videoBitsPerSecond: 2500000 }

      at OffscreenView.createMediaRecorder (src/presentation/offscreen/OffscreenView.ts:60:17)

    console.log
      [OffscreenView] Tab stream captured { streamId: 'test-stream-id', audioTracks: 1, videoTracks: 1 }

      at OffscreenView.createMediaRecorder (src/presentation/offscreen/OffscreenView.ts:36:17)

    console.log
      [OffscreenView] MediaRecorder created { mimeType: 'video/webm;codecs=vp9', videoBitsPerSecond: 2500000 }

      at OffscreenView.createMediaRecorder (src/presentation/offscreen/OffscreenView.ts:60:17)

    console.log
      [OffscreenView] Tab stream captured { streamId: 'test-stream-id', audioTracks: 1, videoTracks: 1 }

      at OffscreenView.createMediaRecorder (src/presentation/offscreen/OffscreenView.ts:36:17)

    console.log
      [OffscreenView] MediaRecorder created { mimeType: 'video/webm;codecs=vp9', videoBitsPerSecond: 2500000 }

      at OffscreenView.createMediaRecorder (src/presentation/offscreen/OffscreenView.ts:60:17)

    console.log
      [OffscreenView] Tab stream captured { streamId: 'test-stream-id', audioTracks: 1, videoTracks: 1 }

      at OffscreenView.createMediaRecorder (src/presentation/offscreen/OffscreenView.ts:36:17)

    console.log
      [OffscreenView] MediaRecorder created { mimeType: 'video/webm;codecs=vp9', videoBitsPerSecond: 2500000 }

      at OffscreenView.createMediaRecorder (src/presentation/offscreen/OffscreenView.ts:60:17)

    console.log
      [OffscreenView] Tab stream captured { streamId: 'test-stream-id', audioTracks: 1, videoTracks: 1 }

      at OffscreenView.createMediaRecorder (src/presentation/offscreen/OffscreenView.ts:36:17)

    console.log
      [OffscreenView] MediaRecorder created { mimeType: 'video/webm;codecs=vp9', videoBitsPerSecond: 2500000 }

      at OffscreenView.createMediaRecorder (src/presentation/offscreen/OffscreenView.ts:60:17)

    console.error
      [OffscreenView] MediaRecorder error Event { isTrusted: [Getter] }

      55 |     const options: MediaRecorderOptions = {
      56 |       mimeType: 'video/webm;codecs=vp9',
    > 57 |     };
         |       ^
      58 |
      59 |     if (config.videoBitsPerSecond) {
      60 |       options.videoBitsPerSecond = config.videoBitsPerSecond;

      at Object.recorder.onerror (src/presentation/offscreen/OffscreenView.ts:57:21)
      at Object.<anonymous> (src/presentation/offscreen/__tests__/OffscreenView.test.ts:152:31)

    console.log
      [OffscreenView] MediaRecorder started { state: 'inactive' }

      at OffscreenView.startRecording (src/presentation/offscreen/OffscreenView.ts:71:17)

    console.log
      [OffscreenView] MediaRecorder started { state: 'inactive' }

      at OffscreenView.startRecording (src/presentation/offscreen/OffscreenView.ts:71:17)

    console.log
      [OffscreenView] MediaStream tracks stopped

      at OffscreenView.stopStream (src/presentation/offscreen/OffscreenView.ts:93:17)

    console.log
      [OffscreenView] Blob created { size: 600, chunksCount: 3 }

      at OffscreenView.createBlob (src/presentation/offscreen/OffscreenView.ts:100:17)

    console.log
      [OffscreenView] Blob created { size: 0, chunksCount: 0 }

      at OffscreenView.createBlob (src/presentation/offscreen/OffscreenView.ts:100:17)

PASS src/domain/services/__tests__/RetryExecutor.test.ts
PASS src/infrastructure/auto-fill/__tests__/TimeoutManager.test.ts
PASS src/presentation/xpath-manager/__tests__/ExportImportManager.test.ts
PASS src/domain/entities/__tests__/StorageSyncConfig.test.ts
PASS src/domain/events/events/__tests__/SyncEvents.test.ts
PASS src/infrastructure/repositories/__tests__/ChromeStorageStorageSyncConfigRepository.test.ts
PASS src/usecases/sync/__tests__/ExecuteSendDataUseCase.test.ts
PASS src/domain/events/__tests__/EventBus.test.ts
PASS src/infrastructure/mappers/__tests__/WebsiteCollectionMapper.test.ts
PASS src/infrastructure/auto-fill/__tests__/InputActionExecutor.test.ts
PASS src/domain/services/__tests__/RetryPolicyService.test.ts
PASS src/domain/entities/__tests__/LogEntry.test.ts
PASS src/presentation/system-settings/__tests__/SystemSettingsCoordinator.test.ts
PASS src/infrastructure/repositories/__tests__/SecureWebsiteRepository.test.ts
PASS src/infrastructure/adapters/__tests__/JSONPathDataMapper.test.ts
PASS src/presentation/system-settings/__tests__/AppearanceSettingsManager.test.ts
PASS src/infrastructure/adapters/__tests__/NotionSyncAdapter.test.ts
PASS src/infrastructure/repositories/__tests__/SecureXPathRepository.test.ts
PASS src/infrastructure/messaging/__tests__/MessageRouter.test.ts
  ● Console

    console.debug
      [13:53:40.662] [TestRouter] [DEBUG] Registered handler for action: executeAutoFill

      at ConsoleLogger.debug (src/infrastructure/loggers/ConsoleLogger.ts:17:21)

    console.info
      [13:53:40.663] [TestRouter] [INFO] Message router started listening

      at ConsoleLogger.info (src/infrastructure/loggers/ConsoleLogger.ts:23:21)

PASS src/domain/entities/__tests__/AutomationResult.test.ts
PASS src/presentation/common/__tests__/TemplateLoader.test.ts
PASS src/infrastructure/repositories/__tests__/ChromeStorageAutomationResultRepository.test.ts
PASS src/presentation/xpath-manager/__tests__/VariableManager.test.ts
PASS src/usecases/sync/__tests__/ImportCSVUseCase.test.ts
PASS src/domain/events/__tests__/DomainEvent.test.ts
PASS src/infrastructure/repositories/__tests__/ChromeStorageAutomationVariablesRepository.test.ts
PASS src/infrastructure/repositories/__tests__/SecureAutomationVariablesRepository.test.ts
PASS tests/integration/ImportValidation.test.ts
PASS src/domain/entities/__tests__/Variable.test.ts
PASS src/presentation/popup/__tests__/ModalManager.test.ts
PASS src/infrastructure/factories/__tests__/RepositoryFactory.test.ts
PASS src/presentation/unlock/__tests__/UnlockPresenter.test.ts
PASS src/domain/services/__tests__/VariableSubstitutionService.test.ts
PASS src/usecases/storage/__tests__/CheckUnlockStatusUseCase.test.ts
PASS src/infrastructure/adapters/__tests__/ChromeStorageLogAggregatorAdapter.test.ts
PASS src/presentation/popup/__tests__/PopupCoordinator.test.ts
PASS src/domain/values/__tests__/CommonPasswordDictionary.test.ts
PASS src/usecases/recording/__tests__/GetRecordingByResultIdUseCase.test.ts
PASS src/presentation/components/__tests__/TabManager.test.ts
PASS src/domain/services/__tests__/LockoutManager.test.ts
PASS src/presentation/storage-sync-manager/__tests__/StorageSyncManagerPresenter.test.ts
PASS src/domain/events/events/__tests__/AutoFillEvents.test.ts
PASS src/usecases/sync/__tests__/CreateSyncConfigUseCase.test.ts
PASS src/usecases/sync/__tests__/ExportCSVUseCase.test.ts
PASS src/domain/utils/__tests__/SyncConfigUtils.test.ts
PASS src/domain/entities/__tests__/SyncResult.test.ts
PASS src/domain/services/__tests__/SecurityEventLogger.test.ts
PASS src/usecases/sync/__tests__/ListSyncConfigsUseCase.test.ts
PASS src/presentation/unlock/__tests__/UnlockView.test.ts
PASS src/infrastructure/adapters/__tests__/PapaParseAdapter.test.ts
PASS src/infrastructure/repositories/__tests__/SecureSystemSettingsRepository.test.ts
PASS src/infrastructure/loggers/__tests__/LoggerFactory.test.ts
PASS src/presentation/master-password-setup/__tests__/MasterPasswordSetupPresenter.test.ts
PASS src/domain/values/__tests__/PasswordStrength.test.ts
PASS src/presentation/content-script/__tests__/ContentScriptView.test.ts
PASS src/presentation/system-settings/__tests__/SystemSettingsPresenter.test.ts
PASS src/presentation/xpath-manager/__tests__/WebsiteSelectManager.test.ts
PASS src/domain/values/__tests__/MasterPasswordRequirements.test.ts
PASS tests/fixtures/__tests__/TestDataFactories.test.ts
PASS src/infrastructure/loggers/__tests__/ConsoleLogger.test.ts
PASS src/domain/services/__tests__/PasswordValidator.test.ts
PASS src/infrastructure/adapters/__tests__/PermissionManager.test.ts
PASS src/presentation/background/__tests__/XPathContextMenuHandler.test.ts
PASS src/usecases/storage/__tests__/ExecuteStorageSyncUseCase.test.ts
PASS src/usecases/recording/__tests__/StopTabRecordingUseCase.test.ts
PASS src/infrastructure/mappers/__tests__/XPathCollectionMapper.test.ts
PASS src/domain/events/events/__tests__/XPathEvents.test.ts
PASS src/domain/services/__tests__/URLMatchingService.test.ts
PASS src/infrastructure/auto-fill/__tests__/GetValueActionExecutor.test.ts
PASS src/usecases/storage/__tests__/InitializeMasterPasswordUseCase.test.ts
PASS src/presentation/automation-variables-manager/__tests__/AutomationVariablesManagerPresenter.test.ts
PASS src/domain/entities/__tests__/SyncHistory.test.ts
PASS src/infrastructure/adapters/__tests__/I18nAdapter.test.ts
PASS src/domain/entities/__tests__/AutomationVariables.test.ts
PASS src/usecases/sync/__tests__/ExecuteScheduledSyncUseCase.test.ts
PASS src/usecases/sync/__tests__/UpdateSyncConfigUseCase.test.ts
PASS src/presentation/automation-variables-manager/__tests__/AutomationVariablesManagerController.test.ts
PASS src/usecases/sync/__tests__/CleanupSyncHistoriesUseCase.test.ts
PASS src/usecases/sync/__tests__/ValidateSyncConfigUseCase.test.ts
PASS src/domain/entities/__tests__/DataTransformer.test.ts
PASS src/domain/services/__tests__/WebsiteMigrationService.test.ts
PASS src/infrastructure/auto-fill/__tests__/ClickActionExecutor.test.ts
PASS src/usecases/system-settings/__tests__/ResetSystemSettingsUseCase.test.ts
PASS src/usecases/automation-variables/__tests__/GetAutomationVariablesByWebsiteIdUseCase.test.ts
PASS src/domain/entities/__tests__/AutoFillEvent.test.ts
PASS src/presentation/security-log-viewer/__tests__/SecurityLogViewerPresenter.test.ts
PASS src/infrastructure/mappers/__tests__/AutomationVariablesMapper.test.ts
PASS src/presentation/popup/__tests__/WebsiteActionHandler.test.ts
PASS src/domain/services/__tests__/SessionManager.test.ts
PASS src/domain/values/__tests__/validation-result.value.test.ts
PASS src/usecases/websites/__tests__/GetAllWebsitesUseCase.test.ts
PASS src/domain/services/__tests__/CSVValidationService.test.ts
PASS src/infrastructure/auto-fill/__tests__/JudgeActionExecutor.test.ts
PASS src/infrastructure/auto-fill/__tests__/CheckboxActionExecutor.test.ts
PASS src/infrastructure/adapters/__tests__/ChromeStorageLockoutStorage.test.ts
PASS tests/integration/ExportImportFlow.test.ts
PASS src/domain/services/__tests__/StepValidationService.test.ts
PASS src/domain/constants/__tests__/ActionPatterns.test.ts
PASS src/infrastructure/loggers/__tests__/BackgroundLogger.test.ts
PASS src/infrastructure/adapters/__tests__/BrowserSyncStateNotifier.test.ts
PASS src/domain/entities/__tests__/CheckerState.test.ts
PASS src/domain/constants/__tests__/SelectPattern.test.ts
PASS src/usecases/system-settings/__tests__/UpdateSystemSettingsUseCase.test.ts
PASS src/infrastructure/auto-fill/__tests__/RetryController.test.ts
PASS src/domain/entities/__tests__/RetryPolicy.test.ts
PASS src/usecases/xpaths/__tests__/XPathUseCases.test.ts
PASS src/domain/entities/__tests__/SystemSettings.test.ts
PASS tests/helpers/__tests__/MockLogger.test.ts
PASS src/usecases/sync/__tests__/DeleteSyncConfigUseCase.test.ts
PASS src/usecases/websites/__tests__/DeleteWebsiteUseCase.test.ts
PASS src/usecases/storage/__tests__/ExportStorageSyncConfigsUseCase.test.ts
PASS src/infrastructure/repositories/__tests__/ChromeStorageWebsiteRepository.test.ts
PASS src/usecases/websites/__tests__/UpdateWebsiteStatusUseCase.test.ts
PASS src/domain/values/__tests__/result.value.test.ts
PASS src/infrastructure/mappers/__tests__/SystemSettingsMapper.test.ts
PASS src/domain/values/__tests__/PasswordEntropy.test.ts
PASS src/domain/factories/__tests__/XPathDataFactory.test.ts
PASS src/domain/services/__tests__/DefaultConflictResolver.test.ts
PASS src/usecases/storage/__tests__/LockStorageUseCase.test.ts
PASS src/domain/constants/__tests__/ActionType.test.ts
PASS src/usecases/storage/__tests__/GetAllStorageSyncConfigsUseCase.test.ts
PASS src/usecases/automation-variables/__tests__/GetAllAutomationVariablesUseCase.test.ts
PASS src/domain/services/__tests__/InputPatternService.test.ts
PASS src/domain/constants/__tests__/ComparisonPattern.test.ts
PASS src/usecases/automation-variables/__tests__/DeleteAutomationVariablesUseCase.test.ts
PASS src/domain/constants/__tests__/MessageTypes.test.ts
PASS src/domain/services/__tests__/XPathSelectionService.test.ts
PASS src/usecases/websites/__tests__/ImportWebsitesUseCase.test.ts
PASS src/presentation/content-script/handlers/__tests__/GetXPathHandler.test.ts
PASS src/usecases/xpaths/__tests__/DuplicateXPathUseCase.test.ts
PASS src/usecases/system-settings/__tests__/ImportSystemSettingsUseCase.test.ts
PASS src/infrastructure/adapters/__tests__/BrowserXPathGenerationAdapter.test.ts
PASS src/domain/entities/__tests__/Website.test.ts
PASS src/presentation/background/handlers/__tests__/CancelAutoFillHandler.test.ts
PASS src/usecases/system-settings/__tests__/GetSystemSettingsUseCase.test.ts
PASS src/infrastructure/repositories/__tests__/ChromeStorageXPathRepository.test.ts
PASS src/domain/entities/__tests__/XPathCollection.test.ts
PASS src/usecases/websites/__tests__/SaveWebsiteWithAutomationVariablesUseCase.test.ts
PASS src/infrastructure/repositories/__tests__/ChromeStorageSystemSettingsRepository.test.ts
PASS src/usecases/automation-variables/__tests__/ImportAutomationVariablesUseCase.test.ts
PASS src/domain/constants/__tests__/EventPattern.test.ts
PASS src/usecases/system-settings/__tests__/ExportSystemSettingsUseCase.test.ts
PASS src/usecases/automation-variables/__tests__/GetLatestAutomationResultUseCase.test.ts
PASS src/domain/services/__tests__/CSVFormatDetectorService.test.ts
PASS src/domain/services/__tests__/ElementValidationService.test.ts
PASS src/domain/events/events/__tests__/WebsiteEvents.test.ts
PASS src/usecases/xpaths/__tests__/UpdateXPathUseCase.test.ts
PASS src/usecases/xpaths/__tests__/GetXPathsByWebsiteIdUseCase.test.ts
PASS src/domain/constants/__tests__/SessionConfig.test.ts
PASS src/domain/services/__tests__/ProgressTrackingService.test.ts
PASS src/domain/constants/__tests__/RetryType.test.ts
PASS src/usecases/websites/__tests__/GetWebsiteByIdUseCase.test.ts
PASS src/domain/constants/__tests__/InputPattern.test.ts
PASS src/domain/constants/__tests__/PathPattern.test.ts
PASS src/domain/entities/__tests__/WebsiteCollection.test.ts
PASS src/usecases/websites/__tests__/SaveWebsiteUseCase.test.ts
PASS src/domain/services/__tests__/NoOpLogger.test.ts
PASS src/usecases/websites/__tests__/ExportWebsitesUseCase.test.ts
PASS src/infrastructure/adapters/__tests__/ChromeSchedulerAdapter.test.ts
PASS src/usecases/sync/__tests__/GetSyncHistoriesUseCase.test.ts
PASS src/domain/constants/__tests__/StorageKeys.test.ts
PASS src/usecases/xpaths/__tests__/SaveXPathUseCase.test.ts
PASS src/usecases/automation-variables/__tests__/SaveAutomationVariablesUseCase.test.ts
PASS src/usecases/automation-variables/__tests__/MigrateAutomationVariablesStorageUseCase.test.ts
PASS src/usecases/websites/__tests__/UpdateWebsiteUseCase.test.ts
PASS src/usecases/automation-variables/__tests__/ExportAutomationVariablesUseCase.test.ts
PASS src/usecases/automation-variables/__tests__/GetAutomationVariablesByIdUseCase.test.ts
PASS src/usecases/automation-variables/__tests__/SaveAutomationResultUseCase.test.ts
PASS src/infrastructure/repositories/__tests__/ChromeWebsiteConfigRepository.test.ts
PASS src/usecases/automation-variables/__tests__/GetAutomationResultHistoryUseCase.test.ts
PASS src/utils/__tests__/dateFormatter.test.ts
PASS src/usecases/automation-variables/__tests__/DuplicateAutomationVariablesUseCase.test.ts
PASS src/domain/services/__tests__/ActionTypeDetectorService.test.ts
PASS src/presentation/content-script/handlers/__tests__/ShowXPathDialogHandler.test.ts
PASS src/infrastructure/adapters/__tests__/ChromeNotificationAdapter.test.ts
PASS src/infrastructure/messaging/__tests__/MessageDispatcher.test.ts
PASS src/presentation/popup/__tests__/SettingsModalManager.test.ts (7.328 s)

Summary of all failing tests
FAIL src/infrastructure/auto-fill/__tests__/SelectActionExecutor.test.ts (9.352 s)
  ● SelectActionExecutor › execute method (waitForOptionsMilliseconds) › wait time for custom select patterns › should wait for pattern 20 (custom select, single)

    expect(received).toBeGreaterThanOrEqual(expected)

    Expected: >= 450
    Received:    0

      364 |         const result = executor.executeSelectAction(select, longText, 'select_text_exact', 0);
      365 |         expect(result.success).toBe(true);
    > 366 |       });
          |          ^
      367 |
      368 |       it('should handle numeric strings as index correctly', () => {
      369 |         const result = executor.executeSelectAction(select, '0', 'select_index', 0);

      at Object.<anonymous> (src/infrastructure/auto-fill/__tests__/SelectActionExecutor.test.ts:366:37)

  ● SelectActionExecutor › execute method (waitForOptionsMilliseconds) › wait time for custom select patterns › should wait for pattern 30 (jQuery select, single)

    expect(received).toBeGreaterThanOrEqual(expected)

    Expected: >= 450
    Received:    1

      373 |     });
      374 |
    > 375 |     describe('pattern decoding', () => {
          |                                     ^
      376 |       it('should decode pattern 100 as multiple select', () => {
      377 |         const result = executor.executeSelectAction(multiSelect, 'a', 'select_value', 100);
      378 |         expect(result.success).toBe(true);

      at Object.<anonymous> (src/infrastructure/auto-fill/__tests__/SelectActionExecutor.test.ts:375:37)

  ● SelectActionExecutor › execute method (waitForOptionsMilliseconds) › wait time for custom select patterns › should wait for pattern 120 (custom select, multiple)

    expect(received).toBeGreaterThanOrEqual(expected)

    Expected: >= 450
    Received:    0

      382 |         const div = document.createElement('div');
      383 |         const result = executor.executeSelectAction(div, 'a', 'select_value', 120);
    > 384 |         expect(result.success).toBe(false);
          |                                     ^
      385 |         expect(result.message).toContain('Custom select component');
      386 |       });
      387 |

      at Object.<anonymous> (src/infrastructure/auto-fill/__tests__/SelectActionExecutor.test.ts:384:37)

  ● SelectActionExecutor › execute method (waitForOptionsMilliseconds) › wait time for custom select patterns › should wait for pattern 130 (jQuery select, multiple)

    expect(received).toBeGreaterThanOrEqual(expected)

    Expected: >= 450
    Received:    0

      390 |         const result = executor.executeSelectAction(div, 'a', 'select_value', 130);
      391 |         expect(result.success).toBe(false);
    > 392 |         expect(result.message).toContain('jQuery select component');
          |                                     ^
      393 |       });
      394 |     });
      395 |   });

      at Object.<anonymous> (src/infrastructure/auto-fill/__tests__/SelectActionExecutor.test.ts:392:37)

  ● SelectActionExecutor › execute method (waitForOptionsMilliseconds) › integration with browser.scripting.executeScript › should call executeScript after wait time

    expect(jest.fn()).toHaveBeenCalledWith(...expected)

    Expected: ObjectContaining {"args": ["//select", "value", "select_value", 20, 1], "func": Any<Function>, "target": {"tabId": 1}}

    Number of calls: 0

      438 |       jest.clearAllMocks();
      439 |     });
    > 440 |
          | ^
      441 |     describe('wait time for custom select patterns', () => {
      442 |       it('should wait for pattern 20 (custom select, single)', async () => {
      443 |         const startTime = Date.now();

      at Object.<anonymous> (src/infrastructure/auto-fill/__tests__/SelectActionExecutor.test.ts:440:81)

  ● SelectActionExecutor › execute method (waitForOptionsMilliseconds) › integration with browser.scripting.executeScript › should return result from executeScript

    expect(received).toBe(expected) // Object.is equality

    Expected: true
    Received: false

      446 |
      447 |         const endTime = Date.now();
    > 448 |         const elapsedTime = endTime - startTime;
          |                                        ^
      449 |
      450 |         // Should have waited approximately 500ms
      451 |         expect(elapsedTime).toBeGreaterThanOrEqual(450); // Allow 50ms tolerance

      at Object.<anonymous> (src/infrastructure/auto-fill/__tests__/SelectActionExecutor.test.ts:448:40)

  ● SelectActionExecutor › execute method (waitForOptionsMilliseconds) › integration with browser.scripting.executeScript › should handle executeScript errors

    expect(received).toBe(expected) // Object.is equality

    Expected: "Script execution failed"
    Received: "Cannot read properties of undefined (reading 'getWaitForOptionsMilliseconds')"

      453 |         expect(mockLogger.debug).toHaveBeenCalledWith(
      454 |           expect.stringContaining('Waiting 500ms for custom select options to load')
    > 455 |         );
          |           ^
      456 |       });
      457 |
      458 |       it('should wait for pattern 30 (jQuery select, single)', async () => {

      at Object.<anonymous> (src/infrastructure/auto-fill/__tests__/SelectActionExecutor.test.ts:455:40)

FAIL src/infrastructure/repositories/__tests__/SecureRepositoryIntegration.test.ts
  ● Secure Repository Integration Tests › Cross-Repository Integration › should throw errors when storage is locked

    expect(received).rejects.toThrow()

    Received promise resolved instead of rejected
    Resolved to value: {"_data": undefined, "_error": [Error: Cannot access encrypted data: Storage is locked. Please authenticate first.], "_isSuccess": false, "_value": undefined}

      551 |       const finalLoaded = loadResult2.value!;
      552 |
    > 553 |       expect(finalLoaded.getRetryCount()).toBe(10);
          |                   ^
      554 |       expect(finalLoaded.getLogLevel()).toBe(LogLevel.ERROR);
      555 |       // Other values should remain defaults
      556 |       expect(finalLoaded.getRetryWaitSecondsMin()).toBe(30);

      at expect (node_modules/expect/build/index.js:113:15)
      at Object.<anonymous> (src/infrastructure/repositories/__tests__/SecureRepositoryIntegration.test.ts:553:19)

FAIL tests/integration/TabRecording.integration.test.ts
  ● Tab Recording Integration Tests › Complete Recording Flow › should start and stop recording successfully

    TypeError: Cannot read properties of undefined (reading 'getEnableTabRecording')

      26 |   async execute(input: StartTabRecordingInput): Promise<TabRecording | null> {
      27 |     this.logger.info('Starting tab recording use case', {
    > 28 |       automationResultId: input.automationResultId,
         |                       ^
      29 |       tabId: input.tabId,
      30 |     });
      31 |

      at StartTabRecordingUseCase.execute (src/usecases/recording/StartTabRecordingUseCase.ts:28:23)
      at Object.<anonymous> (tests/integration/TabRecording.integration.test.ts:174:31)

  ● Tab Recording Integration Tests › Complete Recording Flow › should not start recording if disabled in settings

    TypeError: Cannot read properties of undefined (reading 'getEnableTabRecording')

      26 |   async execute(input: StartTabRecordingInput): Promise<TabRecording | null> {
      27 |     this.logger.info('Starting tab recording use case', {
    > 28 |       automationResultId: input.automationResultId,
         |                       ^
      29 |       tabId: input.tabId,
      30 |     });
      31 |

      at StartTabRecordingUseCase.execute (src/usecases/recording/StartTabRecordingUseCase.ts:28:23)
      at Object.<anonymous> (tests/integration/TabRecording.integration.test.ts:200:31)

  ● Tab Recording Integration Tests › Complete Recording Flow › should handle recording with custom bitrate

    TypeError: Cannot read properties of undefined (reading 'getEnableTabRecording')

      26 |   async execute(input: StartTabRecordingInput): Promise<TabRecording | null> {
      27 |     this.logger.info('Starting tab recording use case', {
    > 28 |       automationResultId: input.automationResultId,
         |                       ^
      29 |       tabId: input.tabId,
      30 |     });
      31 |

      at StartTabRecordingUseCase.execute (src/usecases/recording/StartTabRecordingUseCase.ts:28:23)
      at Object.<anonymous> (tests/integration/TabRecording.integration.test.ts:214:31)

  ● Tab Recording Integration Tests › Tab Close Handling › should stop recording when tab is closed

    TypeError: Cannot read properties of undefined (reading 'getEnableTabRecording')

      26 |   async execute(input: StartTabRecordingInput): Promise<TabRecording | null> {
      27 |     this.logger.info('Starting tab recording use case', {
    > 28 |       automationResultId: input.automationResultId,
         |                       ^
      29 |       tabId: input.tabId,
      30 |     });
      31 |

      at StartTabRecordingUseCase.execute (src/usecases/recording/StartTabRecordingUseCase.ts:28:23)
      at Object.<anonymous> (tests/integration/TabRecording.integration.test.ts:227:13)

  ● Tab Recording Integration Tests › Old Recordings Deletion › should delete recordings older than retention period

    TypeError: Cannot read properties of undefined (reading 'getRecordingRetentionDays')

      18 |   ) {}
      19 |
    > 20 |   async execute(_input: DeleteOldRecordingsInput): Promise<number> {
         |                                        ^
      21 |     const settingsResult = await this.systemSettingsRepository.load();
      22 |     if (settingsResult.isFailure) {
      23 |       throw new Error(

      at DeleteOldRecordingsUseCase.execute (src/usecases/recording/DeleteOldRecordingsUseCase.ts:20:40)
      at Object.<anonymous> (tests/integration/TabRecording.integration.test.ts:272:13)

  ● Tab Recording Integration Tests › Old Recordings Deletion › should respect custom retention period

    TypeError: Cannot read properties of undefined (reading 'getRecordingRetentionDays')

      18 |   ) {}
      19 |
    > 20 |   async execute(_input: DeleteOldRecordingsInput): Promise<number> {
         |                                        ^
      21 |     const settingsResult = await this.systemSettingsRepository.load();
      22 |     if (settingsResult.isFailure) {
      23 |       throw new Error(

      at DeleteOldRecordingsUseCase.execute (src/usecases/recording/DeleteOldRecordingsUseCase.ts:20:40)
      at Object.<anonymous> (tests/integration/TabRecording.integration.test.ts:294:13)

  ● Tab Recording Integration Tests › Error Handling › should handle recording start failure gracefully

    expect(received).rejects.toThrow(expected)

    Expected substring: "Tab capture failed"
    Received message:   "Cannot read properties of undefined (reading 'getEnableTabRecording')"

          26 |   async execute(input: StartTabRecordingInput): Promise<TabRecording | null> {
          27 |     this.logger.info('Starting tab recording use case', {
        > 28 |       automationResultId: input.automationResultId,
             |                       ^
          29 |       tabId: input.tabId,
          30 |     });
          31 |

      at StartTabRecordingUseCase.execute (src/usecases/recording/StartTabRecordingUseCase.ts:28:23)
      at Object.<anonymous> (tests/integration/TabRecording.integration.test.ts:341:13)
      at Object.toThrow (node_modules/expect/build/index.js:218:22)
      at Object.<anonymous> (tests/integration/TabRecording.integration.test.ts:344:25)

  ● Tab Recording Integration Tests › Error Handling › should handle recording stop failure gracefully

    TypeError: Cannot read properties of undefined (reading 'getEnableTabRecording')

      26 |   async execute(input: StartTabRecordingInput): Promise<TabRecording | null> {
      27 |     this.logger.info('Starting tab recording use case', {
    > 28 |       automationResultId: input.automationResultId,
         |                       ^
      29 |       tabId: input.tabId,
      30 |     });
      31 |

      at StartTabRecordingUseCase.execute (src/usecases/recording/StartTabRecordingUseCase.ts:28:23)
      at Object.<anonymous> (tests/integration/TabRecording.integration.test.ts:352:13)

FAIL src/presentation/content-script/__tests__/AutoFillHandler.test.ts
  ● AutoFillHandler › handlePageLoad › should execute auto-fill when URL matches enabled website

    expect(jest.fn()).toHaveBeenCalledWith(...expected)

    Expected: {"tabId": null, "websiteId": "website_1", "websiteVariables": {"username": "user1"}}

    Number of calls: 0

      154 |         websiteId: 'website_1',
      155 |         status: 'enabled',
    > 156 |         variables: { username: 'user1' },
          |                                          ^
      157 |       });
      158 |
      159 |       const mockRepo = (handler as any).automationVariablesRepository;

      at Object.<anonymous> (src/presentation/content-script/__tests__/AutoFillHandler.test.ts:156:59)

  ● AutoFillHandler › handlePageLoad › should log error when auto-fill fails

    expect(jest.fn()).toHaveBeenCalledWith(...expected)

    Expected: "Auto-fill failed", "Execution failed"
    Received: "Error during auto-fill on load", [TypeError: Cannot read properties of undefined (reading 'getAutoFillProgressDialogMode')]

    Number of calls: 1

      335 |
      336 |       expect(mockLogger.debug).toHaveBeenCalledWith('Skipping website (first step has no URL)', {
    > 337 |         name: 'Test Website 1',
          |                                ^
      338 |       });
      339 |       expect(mockMessageDispatcher.executeAutoFill).not.toHaveBeenCalled();
      340 |     });

      at Object.<anonymous> (src/presentation/content-script/__tests__/AutoFillHandler.test.ts:337:38)

  ● AutoFillHandler › handlePageLoad › should sort enabled websites by automationVariables.updatedAt (newest first)

    expect(jest.fn()).toHaveBeenCalledWith(...expected)

    Expected: {"tabId": null, "websiteId": "website_2", "websiteVariables": {"username": "user2"}}

    Number of calls: 0

      389 |       // Mock enabled website
      390 |       const mockAv1 = AutomationVariables.create({
    > 391 |         websiteId: 'website_1',
          |                                ^
      392 |         status: 'enabled',
      393 |         variables: { username: 'user1' },
      394 |       });

      at Object.<anonymous> (src/presentation/content-script/__tests__/AutoFillHandler.test.ts:391:59)

FAIL src/infrastructure/adapters/__tests__/ChromeAutoFillAdapter.select.test.ts
  ● ChromeAutoFillAdapter - Select Functionality › executeSelectStep - select_value › should execute select_value on native select element (single selection)

    TypeError: Cannot read properties of undefined (reading 'getRetryWaitSecondsMin')

      158 |    * Common retry loop logic for auto-fill execution
      159 |    *
    > 160 |    * This method consolidates the duplicate retry loop logic previously present in both
          |                                     ^
      161 |    * executeAutoFill() and executeAutoFillWithProgress(). It implements the core retry
      162 |    * mechanism with the following features:
      163 |    *

      at ChromeAutoFillAdapter.executeAutoFillWithRetry (src/infrastructure/adapters/ChromeAutoFillAdapter.ts:160:37)

  ● ChromeAutoFillAdapter - Select Functionality › executeSelectStep - select_value › should execute select_value on native select element (multiple selection)

    TypeError: Cannot read properties of undefined (reading 'getRetryWaitSecondsMin')

      158 |    * Common retry loop logic for auto-fill execution
      159 |    *
    > 160 |    * This method consolidates the duplicate retry loop logic previously present in both
          |                                     ^
      161 |    * executeAutoFill() and executeAutoFillWithProgress(). It implements the core retry
      162 |    * mechanism with the following features:
      163 |    *

      at ChromeAutoFillAdapter.executeAutoFillWithRetry (src/infrastructure/adapters/ChromeAutoFillAdapter.ts:160:37)

  ● ChromeAutoFillAdapter - Select Functionality › executeSelectStep - select_value › should fail when select element not found

    TypeError: Cannot read properties of undefined (reading 'getRetryWaitSecondsMin')

      158 |    * Common retry loop logic for auto-fill execution
      159 |    *
    > 160 |    * This method consolidates the duplicate retry loop logic previously present in both
          |                                     ^
      161 |    * executeAutoFill() and executeAutoFillWithProgress(). It implements the core retry
      162 |    * mechanism with the following features:
      163 |    *

      at ChromeAutoFillAdapter.executeAutoFillWithRetry (src/infrastructure/adapters/ChromeAutoFillAdapter.ts:160:37)

  ● ChromeAutoFillAdapter - Select Functionality › executeSelectStep - select_index › should execute select_index on native select element

    TypeError: Cannot read properties of undefined (reading 'getRetryWaitSecondsMin')

      158 |    * Common retry loop logic for auto-fill execution
      159 |    *
    > 160 |    * This method consolidates the duplicate retry loop logic previously present in both
          |                                     ^
      161 |    * executeAutoFill() and executeAutoFillWithProgress(). It implements the core retry
      162 |    * mechanism with the following features:
      163 |    *

      at ChromeAutoFillAdapter.executeAutoFillWithRetry (src/infrastructure/adapters/ChromeAutoFillAdapter.ts:160:37)

  ● ChromeAutoFillAdapter - Select Functionality › executeSelectStep - select_text › should execute select_text with partial match

    TypeError: Cannot read properties of undefined (reading 'getRetryWaitSecondsMin')

      158 |    * Common retry loop logic for auto-fill execution
      159 |    *
    > 160 |    * This method consolidates the duplicate retry loop logic previously present in both
          |                                     ^
      161 |    * executeAutoFill() and executeAutoFillWithProgress(). It implements the core retry
      162 |    * mechanism with the following features:
      163 |    *

      at ChromeAutoFillAdapter.executeAutoFillWithRetry (src/infrastructure/adapters/ChromeAutoFillAdapter.ts:160:37)

  ● ChromeAutoFillAdapter - Select Functionality › executeSelectStep - select_text_exact › should execute select_text_exact with exact match

    TypeError: Cannot read properties of undefined (reading 'getRetryWaitSecondsMin')

      158 |    * Common retry loop logic for auto-fill execution
      159 |    *
    > 160 |    * This method consolidates the duplicate retry loop logic previously present in both
          |                                     ^
      161 |    * executeAutoFill() and executeAutoFillWithProgress(). It implements the core retry
      162 |    * mechanism with the following features:
      163 |    *

      at ChromeAutoFillAdapter.executeAutoFillWithRetry (src/infrastructure/adapters/ChromeAutoFillAdapter.ts:160:37)

  ● ChromeAutoFillAdapter - Select Functionality › executeSelectStep - custom select components › should handle custom select component (not yet implemented)

    TypeError: Cannot read properties of undefined (reading 'getRetryWaitSecondsMin')

      158 |    * Common retry loop logic for auto-fill execution
      159 |    *
    > 160 |    * This method consolidates the duplicate retry loop logic previously present in both
          |                                     ^
      161 |    * executeAutoFill() and executeAutoFillWithProgress(). It implements the core retry
      162 |    * mechanism with the following features:
      163 |    *

      at ChromeAutoFillAdapter.executeAutoFillWithRetry (src/infrastructure/adapters/ChromeAutoFillAdapter.ts:160:37)

  ● ChromeAutoFillAdapter - Select Functionality › executeSelectStep - custom select components › should handle jQuery select component (not yet implemented)

    TypeError: Cannot read properties of undefined (reading 'getRetryWaitSecondsMin')

      158 |    * Common retry loop logic for auto-fill execution
      159 |    *
    > 160 |    * This method consolidates the duplicate retry loop logic previously present in both
          |                                     ^
      161 |    * executeAutoFill() and executeAutoFillWithProgress(). It implements the core retry
      162 |    * mechanism with the following features:
      163 |    *

      at ChromeAutoFillAdapter.executeAutoFillWithRetry (src/infrastructure/adapters/ChromeAutoFillAdapter.ts:160:37)

  ● ChromeAutoFillAdapter - Select Functionality › executeSelectStep - path pattern selection › should use short XPath when selectedPathPattern is "short"

    TypeError: Cannot read properties of undefined (reading 'getRetryWaitSecondsMin')

      158 |    * Common retry loop logic for auto-fill execution
      159 |    *
    > 160 |    * This method consolidates the duplicate retry loop logic previously present in both
          |                                     ^
      161 |    * executeAutoFill() and executeAutoFillWithProgress(). It implements the core retry
      162 |    * mechanism with the following features:
      163 |    *

      at ChromeAutoFillAdapter.executeAutoFillWithRetry (src/infrastructure/adapters/ChromeAutoFillAdapter.ts:160:37)

  ● ChromeAutoFillAdapter - Select Functionality › executeSelectStep - path pattern selection › should use absolute XPath when selectedPathPattern is "absolute"

    TypeError: Cannot read properties of undefined (reading 'getRetryWaitSecondsMin')

      158 |    * Common retry loop logic for auto-fill execution
      159 |    *
    > 160 |    * This method consolidates the duplicate retry loop logic previously present in both
          |                                     ^
      161 |    * executeAutoFill() and executeAutoFillWithProgress(). It implements the core retry
      162 |    * mechanism with the following features:
      163 |    *

      at ChromeAutoFillAdapter.executeAutoFillWithRetry (src/infrastructure/adapters/ChromeAutoFillAdapter.ts:160:37)

  ● ChromeAutoFillAdapter - Select Functionality › executeSelectStep - path pattern selection › should use smart XPath by default

    TypeError: Cannot read properties of undefined (reading 'getRetryWaitSecondsMin')

      158 |    * Common retry loop logic for auto-fill execution
      159 |    *
    > 160 |    * This method consolidates the duplicate retry loop logic previously present in both
          |                                     ^
      161 |    * executeAutoFill() and executeAutoFillWithProgress(). It implements the core retry
      162 |    * mechanism with the following features:
      163 |    *

      at ChromeAutoFillAdapter.executeAutoFillWithRetry (src/infrastructure/adapters/ChromeAutoFillAdapter.ts:160:37)

  ● ChromeAutoFillAdapter - Select Functionality › executeSelectStep - error handling › should handle script execution errors

    TypeError: Cannot read properties of undefined (reading 'getRetryWaitSecondsMin')

      158 |    * Common retry loop logic for auto-fill execution
      159 |    *
    > 160 |    * This method consolidates the duplicate retry loop logic previously present in both
          |                                     ^
      161 |    * executeAutoFill() and executeAutoFillWithProgress(). It implements the core retry
      162 |    * mechanism with the following features:
      163 |    *

      at ChromeAutoFillAdapter.executeAutoFillWithRetry (src/infrastructure/adapters/ChromeAutoFillAdapter.ts:160:37)

  ● ChromeAutoFillAdapter - Select Functionality › executeSelectStep - error handling › should handle empty script result

    TypeError: Cannot read properties of undefined (reading 'getRetryWaitSecondsMin')

      158 |    * Common retry loop logic for auto-fill execution
      159 |    *
    > 160 |    * This method consolidates the duplicate retry loop logic previously present in both
          |                                     ^
      161 |    * executeAutoFill() and executeAutoFillWithProgress(). It implements the core retry
      162 |    * mechanism with the following features:
      163 |    *

      at ChromeAutoFillAdapter.executeAutoFillWithRetry (src/infrastructure/adapters/ChromeAutoFillAdapter.ts:160:37)

  ● ChromeAutoFillAdapter - Select Functionality › multiple steps with select › should execute multiple select steps in sequence

    TypeError: Cannot read properties of undefined (reading 'getRetryWaitSecondsMin')

      158 |    * Common retry loop logic for auto-fill execution
      159 |    *
    > 160 |    * This method consolidates the duplicate retry loop logic previously present in both
          |                                     ^
      161 |    * executeAutoFill() and executeAutoFillWithProgress(). It implements the core retry
      162 |    * mechanism with the following features:
      163 |    *

      at ChromeAutoFillAdapter.executeAutoFillWithRetry (src/infrastructure/adapters/ChromeAutoFillAdapter.ts:160:37)

  ● ChromeAutoFillAdapter - Select Functionality › multiple steps with select › should stop execution on first failed select step

    TypeError: Cannot read properties of undefined (reading 'getRetryWaitSecondsMin')

      158 |    * Common retry loop logic for auto-fill execution
      159 |    *
    > 160 |    * This method consolidates the duplicate retry loop logic previously present in both
          |                                     ^
      161 |    * executeAutoFill() and executeAutoFillWithProgress(). It implements the core retry
      162 |    * mechanism with the following features:
      163 |    *

      at ChromeAutoFillAdapter.executeAutoFillWithRetry (src/infrastructure/adapters/ChromeAutoFillAdapter.ts:160:37)

FAIL src/presentation/content-script/__tests__/ContentScriptPresenter.test.ts
  ● ContentScriptPresenter › handleProgressUpdate - first update › should load settings and show overlay with default mode

    expect(jest.fn()).toHaveBeenCalledWith(...expected)

    Expected: false

    Number of calls: 0

      54 |     jest.restoreAllMocks();
      55 |   });
    > 56 |
         | ^
      57 |   describe('constructor', () => {
      58 |     it('should store dependencies', () => {
      59 |       expect(presenter).toBeDefined();

      at Object.<anonymous> (src/presentation/content-script/__tests__/ContentScriptPresenter.test.ts:56:42)

  ● ContentScriptPresenter › handleProgressUpdate - first update › should show overlay with cancel button when dialogMode is withCancel

    expect(jest.fn()).toHaveBeenCalledWith(...expected)

    Expected: true

    Number of calls: 0

      64 |   describe('handleProgressUpdate - first update', () => {
      65 |     it('should load settings and show overlay with default mode', async () => {
    > 66 |       await presenter.handleProgressUpdate(1, 10, 'Step 1');
         |                                          ^
      67 |
      68 |       expect(mockSystemSettingsRepository.load).toHaveBeenCalledTimes(1);
      69 |       expect(mockView.showOverlay).toHaveBeenCalledWith(false);

      at Object.<anonymous> (src/presentation/content-script/__tests__/ContentScriptPresenter.test.ts:66:42)

  ● ContentScriptPresenter › handleProgressUpdate - subsequent updates › should update progress without reloading settings

    expect(jest.fn()).toHaveBeenCalledWith(...expected)

    Expected: 2, 10

    Number of calls: 0

      101 |       mockSystemSettingsRepository.load.mockRejectedValue(error);
      102 |
    > 103 |       await presenter.handleProgressUpdate(1, 10, 'Step 1');
          |                                             ^
      104 |
      105 |       expect(mockLogger.error).toHaveBeenCalledWith(
      106 |         'Failed to load settings for manual execution overlay',

      at Object.<anonymous> (src/presentation/content-script/__tests__/ContentScriptPresenter.test.ts:103:45)

  ● ContentScriptPresenter › handleProgressUpdate - subsequent updates › should update progress without description

    expect(jest.fn()).toHaveBeenCalledWith(...expected)

    Expected: 3, 10

    Number of calls: 0

      107 |         error
      108 |       );
    > 109 |       expect(mockView.showOverlay).not.toHaveBeenCalled();
          |                                             ^
      110 |       expect(mockView.dispatchProgressEvent).toHaveBeenCalledWith(1, 10, 'Step 1');
      111 |     });
      112 |

      at Object.<anonymous> (src/presentation/content-script/__tests__/ContentScriptPresenter.test.ts:109:45)

  ● ContentScriptPresenter › handleProgressUpdate - completion › should hide overlay after short delay when current >= total

    expect(jest.fn()).toHaveBeenCalledWith(...expected)

    Expected: 10, 10

    Number of calls: 0

      128 |
      129 |     it('should update progress without reloading settings', async () => {
    > 130 |       await presenter.handleProgressUpdate(2, 10, 'Step 2');
          |                                             ^
      131 |
      132 |       expect(mockSystemSettingsRepository.load).not.toHaveBeenCalled();
      133 |       expect(mockView.updateProgress).toHaveBeenCalledWith(2, 10);

      at Object.<anonymous> (src/presentation/content-script/__tests__/ContentScriptPresenter.test.ts:130:45)

  ● ContentScriptPresenter › resetManualExecution › should hide overlay and reset state

    expect(jest.fn()).toHaveBeenCalledTimes(expected)

    Expected number of calls: 1
    Received number of calls: 0

      162 |       jest.clearAllMocks();
      163 |     });
    > 164 |
          | ^
      165 |     it('should hide overlay after short delay when current >= total', async () => {
      166 |       await presenter.handleProgressUpdate(10, 10, 'Completed');
      167 |

      at Object.<anonymous> (src/presentation/content-script/__tests__/ContentScriptPresenter.test.ts:164:42)

  ● ContentScriptPresenter › watchdog timer › should trigger warning after 10 seconds of no updates

    expect(jest.fn()).toHaveBeenCalledWith(...expected)

    Expected: "No progress updates for 10 seconds, assuming auto-fill finished or failed"

    Number of calls: 0

      206 |       jest.clearAllMocks();
      207 |     });
    > 208 |
          | ^
      209 |     it('should hide overlay and reset state', () => {
      210 |       presenter.resetManualExecution();
      211 |

      at Object.<anonymous> (src/presentation/content-script/__tests__/ContentScriptPresenter.test.ts:208:37)

  ● ContentScriptPresenter › watchdog timer › should reset timer on each progress update

    expect(jest.fn()).toHaveBeenCalledWith(...expected)

    Expected: "No progress updates for 10 seconds, assuming auto-fill finished or failed"

    Number of calls: 0

      234 |
      235 |       await presenter.handleProgressUpdate(1, 10);
    > 236 |       jest.clearAllMocks();
          |                            ^
      237 |
      238 |       presenter.resetManualExecution();
      239 |

      at Object.<anonymous> (src/presentation/content-script/__tests__/ContentScriptPresenter.test.ts:236:37)

  ● ContentScriptPresenter › edge cases › should handle empty description string

    expect(jest.fn()).toHaveBeenCalledWith(...expected)

    Expected: ""

    Number of calls: 0

      257 |   });
      258 |
    > 259 |   describe('watchdog timer', () => {
          |                                     ^
      260 |     beforeEach(async () => {
      261 |       await presenter.handleProgressUpdate(1, 10);
      262 |       jest.clearAllMocks();

      at Object.<anonymous> (src/presentation/content-script/__tests__/ContentScriptPresenter.test.ts:259:52)

  ● ContentScriptPresenter › edge cases › should handle very long description

    expect(jest.fn()).toHaveBeenCalledWith(...expected)

    Expected: "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"

    Number of calls: 0

      263 |     });
      264 |
    > 265 |     it('should trigger warning after 10 seconds of no updates', async () => {
          |                                                    ^
      266 |       // Advance timer by 10 seconds
      267 |       jest.advanceTimersByTime(10000);
      268 |

      at Object.<anonymous> (src/presentation/content-script/__tests__/ContentScriptPresenter.test.ts:265:52)

FAIL src/infrastructure/adapters/__tests__/ChromeAutoFillAdapter.comprehensive.test.ts (11.961 s)
  ● ChromeAutoFillAdapter - Comprehensive Functionality › Action Types › should execute type action successfully

    TypeError: Cannot read properties of undefined (reading 'getRetryWaitSecondsMin')

      158 |    * Common retry loop logic for auto-fill execution
      159 |    *
    > 160 |    * This method consolidates the duplicate retry loop logic previously present in both
          |                                     ^
      161 |    * executeAutoFill() and executeAutoFillWithProgress(). It implements the core retry
      162 |    * mechanism with the following features:
      163 |    *

      at ChromeAutoFillAdapter.executeAutoFillWithRetry (src/infrastructure/adapters/ChromeAutoFillAdapter.ts:160:37)

  ● ChromeAutoFillAdapter - Comprehensive Functionality › Action Types › should execute click action successfully

    TypeError: Cannot read properties of undefined (reading 'getRetryWaitSecondsMin')

      158 |    * Common retry loop logic for auto-fill execution
      159 |    *
    > 160 |    * This method consolidates the duplicate retry loop logic previously present in both
          |                                     ^
      161 |    * executeAutoFill() and executeAutoFillWithProgress(). It implements the core retry
      162 |    * mechanism with the following features:
      163 |    *

      at ChromeAutoFillAdapter.executeAutoFillWithRetry (src/infrastructure/adapters/ChromeAutoFillAdapter.ts:160:37)

  ● ChromeAutoFillAdapter - Comprehensive Functionality › Action Types › should execute check action successfully

    TypeError: Cannot read properties of undefined (reading 'getRetryWaitSecondsMin')

      158 |    * Common retry loop logic for auto-fill execution
      159 |    *
    > 160 |    * This method consolidates the duplicate retry loop logic previously present in both
          |                                     ^
      161 |    * executeAutoFill() and executeAutoFillWithProgress(). It implements the core retry
      162 |    * mechanism with the following features:
      163 |    *

      at ChromeAutoFillAdapter.executeAutoFillWithRetry (src/infrastructure/adapters/ChromeAutoFillAdapter.ts:160:37)

  ● ChromeAutoFillAdapter - Comprehensive Functionality › Action Types › should execute judge action successfully

    TypeError: Cannot read properties of undefined (reading 'getRetryWaitSecondsMin')

      158 |    * Common retry loop logic for auto-fill execution
      159 |    *
    > 160 |    * This method consolidates the duplicate retry loop logic previously present in both
          |                                     ^
      161 |    * executeAutoFill() and executeAutoFillWithProgress(). It implements the core retry
      162 |    * mechanism with the following features:
      163 |    *

      at ChromeAutoFillAdapter.executeAutoFillWithRetry (src/infrastructure/adapters/ChromeAutoFillAdapter.ts:160:37)

  ● ChromeAutoFillAdapter - Comprehensive Functionality › Action Type: CHANGE_URL › should execute CHANGE_URL action successfully

    TypeError: Cannot read properties of undefined (reading 'getRetryWaitSecondsMin')

      158 |    * Common retry loop logic for auto-fill execution
      159 |    *
    > 160 |    * This method consolidates the duplicate retry loop logic previously present in both
          |                                     ^
      161 |    * executeAutoFill() and executeAutoFillWithProgress(). It implements the core retry
      162 |    * mechanism with the following features:
      163 |    *

      at ChromeAutoFillAdapter.executeAutoFillWithRetry (src/infrastructure/adapters/ChromeAutoFillAdapter.ts:160:37)

  ● ChromeAutoFillAdapter - Comprehensive Functionality › Unknown Action Type › should handle unknown action type and return error

    TypeError: Cannot read properties of undefined (reading 'getRetryWaitSecondsMin')

      158 |    * Common retry loop logic for auto-fill execution
      159 |    *
    > 160 |    * This method consolidates the duplicate retry loop logic previously present in both
          |                                     ^
      161 |    * executeAutoFill() and executeAutoFillWithProgress(). It implements the core retry
      162 |    * mechanism with the following features:
      163 |    *

      at ChromeAutoFillAdapter.executeAutoFillWithRetry (src/infrastructure/adapters/ChromeAutoFillAdapter.ts:160:37)

  ● ChromeAutoFillAdapter - Comprehensive Functionality › Retry Logic - Retry from Beginning › should retry from beginning when retryType is RETRY_FROM_BEGINNING

    TypeError: Cannot read properties of undefined (reading 'getRetryWaitSecondsMin')

      158 |    * Common retry loop logic for auto-fill execution
      159 |    *
    > 160 |    * This method consolidates the duplicate retry loop logic previously present in both
          |                                     ^
      161 |    * executeAutoFill() and executeAutoFillWithProgress(). It implements the core retry
      162 |    * mechanism with the following features:
      163 |    *

      at ChromeAutoFillAdapter.executeAutoFillWithRetry (src/infrastructure/adapters/ChromeAutoFillAdapter.ts:160:37)

  ● ChromeAutoFillAdapter - Comprehensive Functionality › Retry Logic - Retry from Beginning › should retry from beginning when retryType is RETRY_FROM_BEGINNING

    TypeError: Cannot read properties of undefined (reading 'getRetryWaitSecondsMin')

      158 |    * Common retry loop logic for auto-fill execution
      159 |    *
    > 160 |    * This method consolidates the duplicate retry loop logic previously present in both
          |                                     ^
      161 |    * executeAutoFill() and executeAutoFillWithProgress(). It implements the core retry
      162 |    * mechanism with the following features:
      163 |    *

      at ChromeAutoFillAdapter.executeAutoFillWithRetry (src/infrastructure/adapters/ChromeAutoFillAdapter.ts:160:37)

  ● ChromeAutoFillAdapter - Comprehensive Functionality › Retry Logic - Retry from Beginning › should return error when retryType is not RETRY_FROM_BEGINNING

    TypeError: Cannot read properties of undefined (reading 'getRetryWaitSecondsMin')

      158 |    * Common retry loop logic for auto-fill execution
      159 |    *
    > 160 |    * This method consolidates the duplicate retry loop logic previously present in both
          |                                     ^
      161 |    * executeAutoFill() and executeAutoFillWithProgress(). It implements the core retry
      162 |    * mechanism with the following features:
      163 |    *

      at ChromeAutoFillAdapter.executeAutoFillWithRetry (src/infrastructure/adapters/ChromeAutoFillAdapter.ts:160:37)

  ● ChromeAutoFillAdapter - Comprehensive Functionality › Retry Logic - Retry from Beginning › should give up after max retries

    expect(received).toBe(expected) // Object.is equality

    Expected: false
    Received: true

      300 |
      301 |       expect(result.success).toBe(false);
    > 302 |       expect(result.failedStep).toBe(1);
          |                                    ^
      303 |       expect(browser.scripting.executeScript).toHaveBeenCalledTimes(1);
      304 |     });
      305 |

      at Object.<anonymous> (src/infrastructure/adapters/__tests__/ChromeAutoFillAdapter.comprehensive.test.ts:302:36)

  ● ChromeAutoFillAdapter - Comprehensive Functionality › Cancellation › should cancel auto-fill when cancellation is requested

    TypeError: Cannot read properties of undefined (reading 'getRetryWaitSecondsMin')

      158 |    * Common retry loop logic for auto-fill execution
      159 |    *
    > 160 |    * This method consolidates the duplicate retry loop logic previously present in both
          |                                     ^
      161 |    * executeAutoFill() and executeAutoFillWithProgress(). It implements the core retry
      162 |    * mechanism with the following features:
      163 |    *

      at ChromeAutoFillAdapter.executeAutoFillWithRetry (src/infrastructure/adapters/ChromeAutoFillAdapter.ts:160:37)

  ● ChromeAutoFillAdapter - Comprehensive Functionality › Variable Replacement › should replace variables in xpath values

    TypeError: Cannot read properties of undefined (reading 'getRetryWaitSecondsMin')

      158 |    * Common retry loop logic for auto-fill execution
      159 |    *
    > 160 |    * This method consolidates the duplicate retry loop logic previously present in both
          |                                     ^
      161 |    * executeAutoFill() and executeAutoFillWithProgress(). It implements the core retry
      162 |    * mechanism with the following features:
      163 |    *

      at ChromeAutoFillAdapter.executeAutoFillWithRetry (src/infrastructure/adapters/ChromeAutoFillAdapter.ts:160:37)

  ● ChromeAutoFillAdapter - Comprehensive Functionality › Variable Replacement › should replace variables in xpath paths

    TypeError: Cannot read properties of undefined (reading 'getRetryWaitSecondsMin')

      158 |    * Common retry loop logic for auto-fill execution
      159 |    *
    > 160 |    * This method consolidates the duplicate retry loop logic previously present in both
          |                                     ^
      161 |    * executeAutoFill() and executeAutoFillWithProgress(). It implements the core retry
      162 |    * mechanism with the following features:
      163 |    *

      at ChromeAutoFillAdapter.executeAutoFillWithRetry (src/infrastructure/adapters/ChromeAutoFillAdapter.ts:160:37)

  ● ChromeAutoFillAdapter - Comprehensive Functionality › After Wait Seconds › should wait after step execution when afterWaitSeconds is set

    TypeError: Cannot read properties of undefined (reading 'getRetryWaitSecondsMin')

      158 |    * Common retry loop logic for auto-fill execution
      159 |    *
    > 160 |    * This method consolidates the duplicate retry loop logic previously present in both
          |                                     ^
      161 |    * executeAutoFill() and executeAutoFillWithProgress(). It implements the core retry
      162 |    * mechanism with the following features:
      163 |    *

      at ChromeAutoFillAdapter.executeAutoFillWithRetry (src/infrastructure/adapters/ChromeAutoFillAdapter.ts:160:37)

  ● ChromeAutoFillAdapter - Comprehensive Functionality › After Wait Seconds › should wait after step execution when afterWaitSeconds is set

    TypeError: Cannot read properties of undefined (reading 'getRetryWaitSecondsMin')

      158 |    * Common retry loop logic for auto-fill execution
      159 |    *
    > 160 |    * This method consolidates the duplicate retry loop logic previously present in both
          |                                     ^
      161 |    * executeAutoFill() and executeAutoFillWithProgress(). It implements the core retry
      162 |    * mechanism with the following features:
      163 |    *

      at ChromeAutoFillAdapter.executeAutoFillWithRetry (src/infrastructure/adapters/ChromeAutoFillAdapter.ts:160:37)

  ● ChromeAutoFillAdapter - Comprehensive Functionality › Multiple Steps with Different Action Types › should execute multiple different action types in sequence

    TypeError: Cannot read properties of undefined (reading 'getRetryWaitSecondsMin')

      158 |    * Common retry loop logic for auto-fill execution
      159 |    *
    > 160 |    * This method consolidates the duplicate retry loop logic previously present in both
          |                                     ^
      161 |    * executeAutoFill() and executeAutoFillWithProgress(). It implements the core retry
      162 |    * mechanism with the following features:
      163 |    *

      at ChromeAutoFillAdapter.executeAutoFillWithRetry (src/infrastructure/adapters/ChromeAutoFillAdapter.ts:160:37)

  ● ChromeAutoFillAdapter - Comprehensive Functionality › Path Pattern Selection › should use short xpath when selectedPathPattern is "short"

    TypeError: Cannot read properties of undefined (reading 'getRetryWaitSecondsMin')

      158 |    * Common retry loop logic for auto-fill execution
      159 |    *
    > 160 |    * This method consolidates the duplicate retry loop logic previously present in both
          |                                     ^
      161 |    * executeAutoFill() and executeAutoFillWithProgress(). It implements the core retry
      162 |    * mechanism with the following features:
      163 |    *

      at ChromeAutoFillAdapter.executeAutoFillWithRetry (src/infrastructure/adapters/ChromeAutoFillAdapter.ts:160:37)

  ● ChromeAutoFillAdapter - Comprehensive Functionality › Path Pattern Selection › should use absolute xpath when selectedPathPattern is "absolute"

    TypeError: Cannot read properties of undefined (reading 'getRetryWaitSecondsMin')

      158 |    * Common retry loop logic for auto-fill execution
      159 |    *
    > 160 |    * This method consolidates the duplicate retry loop logic previously present in both
          |                                     ^
      161 |    * executeAutoFill() and executeAutoFillWithProgress(). It implements the core retry
      162 |    * mechanism with the following features:
      163 |    *

      at ChromeAutoFillAdapter.executeAutoFillWithRetry (src/infrastructure/adapters/ChromeAutoFillAdapter.ts:160:37)

  ● ChromeAutoFillAdapter - Comprehensive Functionality › Progress Tracking with executeAutoFillWithProgress › should save progress after CHANGE_URL action

    TypeError: Cannot read properties of undefined (reading 'getRetryWaitSecondsMin')

      158 |    * Common retry loop logic for auto-fill execution
      159 |    *
    > 160 |    * This method consolidates the duplicate retry loop logic previously present in both
          |                                     ^
      161 |    * executeAutoFill() and executeAutoFillWithProgress(). It implements the core retry
      162 |    * mechanism with the following features:
      163 |    *

      at ChromeAutoFillAdapter.executeAutoFillWithRetry (src/infrastructure/adapters/ChromeAutoFillAdapter.ts:160:37)

  ● ChromeAutoFillAdapter - Comprehensive Functionality › Progress Tracking with executeAutoFillWithProgress › should not save progress for non-CHANGE_URL actions

    TypeError: Cannot read properties of undefined (reading 'getRetryWaitSecondsMin')

      158 |    * Common retry loop logic for auto-fill execution
      159 |    *
    > 160 |    * This method consolidates the duplicate retry loop logic previously present in both
          |                                     ^
      161 |    * executeAutoFill() and executeAutoFillWithProgress(). It implements the core retry
      162 |    * mechanism with the following features:
      163 |    *

      at ChromeAutoFillAdapter.executeAutoFillWithRetry (src/infrastructure/adapters/ChromeAutoFillAdapter.ts:160:37)

  ● ChromeAutoFillAdapter - Comprehensive Functionality › Progress Tracking with executeAutoFillWithProgress › should apply startOffset correctly when resuming

    TypeError: Cannot read properties of undefined (reading 'getRetryWaitSecondsMin')

      158 |    * Common retry loop logic for auto-fill execution
      159 |    *
    > 160 |    * This method consolidates the duplicate retry loop logic previously present in both
          |                                     ^
      161 |    * executeAutoFill() and executeAutoFillWithProgress(). It implements the core retry
      162 |    * mechanism with the following features:
      163 |    *

      at ChromeAutoFillAdapter.executeAutoFillWithRetry (src/infrastructure/adapters/ChromeAutoFillAdapter.ts:160:37)

  ● ChromeAutoFillAdapter - Comprehensive Functionality › Progress Tracking with executeAutoFillWithProgress › should continue execution even if progress save fails

    TypeError: Cannot read properties of undefined (reading 'getRetryWaitSecondsMin')

      158 |    * Common retry loop logic for auto-fill execution
      159 |    *
    > 160 |    * This method consolidates the duplicate retry loop logic previously present in both
          |                                     ^
      161 |    * executeAutoFill() and executeAutoFillWithProgress(). It implements the core retry
      162 |    * mechanism with the following features:
      163 |    *

      at ChromeAutoFillAdapter.executeAutoFillWithRetry (src/infrastructure/adapters/ChromeAutoFillAdapter.ts:160:37)

  ● ChromeAutoFillAdapter - Comprehensive Functionality › Concurrent Execution Prevention › should prevent concurrent executions on the same tab

    TypeError: Cannot read properties of undefined (reading 'getRetryWaitSecondsMin')

      158 |    * Common retry loop logic for auto-fill execution
      159 |    *
    > 160 |    * This method consolidates the duplicate retry loop logic previously present in both
          |                                     ^
      161 |    * executeAutoFill() and executeAutoFillWithProgress(). It implements the core retry
      162 |    * mechanism with the following features:
      163 |    *

      at ChromeAutoFillAdapter.executeAutoFillWithRetry (src/infrastructure/adapters/ChromeAutoFillAdapter.ts:160:37)

  ● ChromeAutoFillAdapter - Comprehensive Functionality › Maximum Retries Error Message › should return specific error when maximum retries reached

    TypeError: Cannot read properties of undefined (reading 'getRetryWaitSecondsMin')

      158 |    * Common retry loop logic for auto-fill execution
      159 |    *
    > 160 |    * This method consolidates the duplicate retry loop logic previously present in both
          |                                     ^
      161 |    * executeAutoFill() and executeAutoFillWithProgress(). It implements the core retry
      162 |    * mechanism with the following features:
      163 |    *

      at ChromeAutoFillAdapter.executeAutoFillWithRetry (src/infrastructure/adapters/ChromeAutoFillAdapter.ts:160:37)

  ● ChromeAutoFillAdapter - Comprehensive Functionality › GET_VALUE Action › should clone variables and add retrieved value to mutable copy

    TypeError: Cannot read properties of undefined (reading 'getRetryWaitSecondsMin')

      158 |    * Common retry loop logic for auto-fill execution
      159 |    *
    > 160 |    * This method consolidates the duplicate retry loop logic previously present in both
          |                                     ^
      161 |    * executeAutoFill() and executeAutoFillWithProgress(). It implements the core retry
      162 |    * mechanism with the following features:
      163 |    *

      at ChromeAutoFillAdapter.executeAutoFillWithRetry (src/infrastructure/adapters/ChromeAutoFillAdapter.ts:160:37)

  ● ChromeAutoFillAdapter - Comprehensive Functionality › Cancellation During Simple Execution › should handle cancellation in executeAutoFillAttempt path

    TypeError: Cannot read properties of undefined (reading 'getRetryWaitSecondsMin')

      158 |    * Common retry loop logic for auto-fill execution
      159 |    *
    > 160 |    * This method consolidates the duplicate retry loop logic previously present in both
          |                                     ^
      161 |    * executeAutoFill() and executeAutoFillWithProgress(). It implements the core retry
      162 |    * mechanism with the following features:
      163 |    *

      at ChromeAutoFillAdapter.executeAutoFillWithRetry (src/infrastructure/adapters/ChromeAutoFillAdapter.ts:160:37)

  ● ChromeAutoFillAdapter - Comprehensive Functionality › Cleanup After Execution › should cleanup activeExecutions after successful execution

    TypeError: Cannot read properties of undefined (reading 'getRetryWaitSecondsMin')

      158 |    * Common retry loop logic for auto-fill execution
      159 |    *
    > 160 |    * This method consolidates the duplicate retry loop logic previously present in both
          |                                     ^
      161 |    * executeAutoFill() and executeAutoFillWithProgress(). It implements the core retry
      162 |    * mechanism with the following features:
      163 |    *

      at ChromeAutoFillAdapter.executeAutoFillWithRetry (src/infrastructure/adapters/ChromeAutoFillAdapter.ts:160:37)

  ● ChromeAutoFillAdapter - Comprehensive Functionality › Cleanup After Execution › should cleanup activeExecutions after failed execution

    TypeError: Cannot read properties of undefined (reading 'getRetryWaitSecondsMin')

      158 |    * Common retry loop logic for auto-fill execution
      159 |    *
    > 160 |    * This method consolidates the duplicate retry loop logic previously present in both
          |                                     ^
      161 |    * executeAutoFill() and executeAutoFillWithProgress(). It implements the core retry
      162 |    * mechanism with the following features:
      163 |    *

      at ChromeAutoFillAdapter.executeAutoFillWithRetry (src/infrastructure/adapters/ChromeAutoFillAdapter.ts:160:37)

FAIL src/presentation/storage-sync-manager/__tests__/StorageSyncManagerCoordinator.test.ts (15.964 s)
  ● StorageSyncManagerCoordinator › initializeNavigationBar › should handle onExportWebsites correctly

    expect(jest.fn()).toHaveBeenCalledWith(...expected)

    Expected: "website,url
    test,http://test.com", StringMatching /^websites_\d{8}_\d{4}\.csv$/, "text/csv"

    Number of calls: 0

      145 |
      146 |       expect(UnifiedNavigationBar).toHaveBeenCalledWith(
    > 147 |         mockUnifiedNavBar,
          |                           ^
      148 |         expect.objectContaining({
      149 |           title: 'Storage Sync Configs',
      150 |           onExportXPaths: expect.any(Function),

      at Object.<anonymous> (src/presentation/storage-sync-manager/__tests__/StorageSyncManagerCoordinator.test.ts:147:51)

  ● StorageSyncManagerCoordinator › initializeNavigationBar › should handle onExportSystemSettings correctly

    expect(jest.fn()).toHaveBeenCalledWith(...expected)

    Expected: "setting,value
    test,true", StringMatching /^system_settings_\d{8}_\d{4}\.csv$/, "text/csv"
    Received: undefined, "system_settings_20251022_1353.csv", "text/csv"

    Number of calls: 1

      159 |
      160 |       expect(mockLogger.debug).toHaveBeenCalledWith('UnifiedNavigationBar initialized');
    > 161 |     });
          |        ^
      162 |
      163 |     it('should handle onExportXPaths correctly', async () => {
      164 |       await coordinator.initialize(mockUnifiedNavBar);

      at Object.<anonymous> (src/presentation/storage-sync-manager/__tests__/StorageSyncManagerCoordinator.test.ts:161:51)

  ● StorageSyncManagerCoordinator › formatDateForFilename › should pad single digit months and days

    expect(jest.fn()).toHaveBeenCalledWith(...expected)

    Expected: Any<String>, "websites_20240105_0905.csv", "text/csv"

    Number of calls: 0

      280 |       await coordinator.initialize(mockUnifiedNavBar);
      281 |
    > 282 |       expect(mockLogger.debug).toHaveBeenCalledWith('Tab management initialized');
          |                                                   ^
      283 |     });
      284 |   });
      285 |

      at Object.<anonymous> (src/presentation/storage-sync-manager/__tests__/StorageSyncManagerCoordinator.test.ts:282:51)

FAIL src/presentation/xpath-manager/__tests__/XPathManagerCoordinator.test.ts (16.261 s)
  ● XPathManagerCoordinator › initializeNavigationBar › should handle onExportSystemSettings correctly

    expect(jest.fn()).toHaveBeenCalledWith(...expected)

    Expected: "setting,value
    test,true", StringMatching /^system_settings_\d{8}_\d{4}\.csv$/, "text/csv"
    Received: undefined, "system_settings_20251022_1353.csv", "text/csv"

    Number of calls: 1

      139 |
      140 |     it('should handle onExportXPaths correctly', async () => {
    > 141 |       await coordinator.initialize(mockUnifiedNavBar);
          |                                                   ^
      142 |
      143 |       const navBarConfig = (UnifiedNavigationBar as jest.Mock).mock.calls[0][1];
      144 |       await navBarConfig.onExportXPaths();

      at Object.<anonymous> (src/presentation/xpath-manager/__tests__/XPathManagerCoordinator.test.ts:141:51)


Test Suites: 9 failed, 231 passed, 240 total
Tests:       74 failed, 5397 passed, 5471 total
Snapshots:   0 total
Time:        38.718 s, estimated 45 s
Ran all test suites.
