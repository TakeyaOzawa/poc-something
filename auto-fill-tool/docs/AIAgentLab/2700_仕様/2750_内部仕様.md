## 🧱 1. システムアーキテクチャ概要

システムは、**マルチエージェントシステム (MAS)**、**永続データ層**、および**外部開発環境** を核として構成される。

| 層 | コンポーネント | 技術/役割 |
| :--- | :--- | :--- |
| **エージェント層 (MAS)** | Planner, Architect, Coder, Tester | 独立した役割を持ち、LLMを用いてタスクを実行するカスタムAIエージェント。 |
| **通信プロトコル** | MCP (Multi-Context Protocol) | エージェント間およびAmazon Qとの対話とタスクの受け渡しを行う。 |
| **データ永続層** | AWS EFS (クラウド) / Docker Volume (ローカル) | 開発対象のソースコード（`/project_root`）を永続的に保持・共有。 |
| **外部開発環境** | 検証環境コンテナ群 (PHP, MySQL, Redis等) | AIエージェントとは独立して起動し、統合テスト・動作検証に使用される。 |
| **オーケストレーション層** | k3s (ローカル) / Amazon EKS (AWS) | エージェントコンテナと外部環境のデプロイ、スケーリング、ネットワークを管理。 |


階層構造案
/ai-dev-project
├── .git/
├── README.md
├── requirements.txt         # Pythonライブラリ (boto3, fastapi, requestsなど)
├── docker-compose.yml       # AIエージェント用コンテナ構成
├── package.json             # CDK用依存関係
├── tsconfig.json            # CDK用TypeScript設定
│
├── /cdk
│   ├── app.ts
│   ├── lib
│   │   └── ai-dev-stack.ts  # AWSリソース定義 (EKS, EFS, IAM)
│   └── cdk.json
│
├── /k8s                     # Kubernetes マニフェスト
│   ├── ai-agents/           # AIエージェント用
│   │   ├── namespace.yaml
│   │   ├── planner-agent.yaml
│   │   ├── architect-agent.yaml
│   │   ├── coder-agent.yaml
│   │   └── tester-agent.yaml
│   └── external-env/        # 外部開発環境用
│       ├── namespace.yaml
│       ├── php-app.yaml
│       ├── mysql.yaml
│       └── redis.yaml
│
├── /agents                  # AIエージェントの実装
│   ├── /planner-agent
│   │   ├── Dockerfile       # Node.js 22 + Python
│   │   ├── logic.py         # MCPサーバー/エージェントロジック
│   │   └── config.json      # Amazon Q ルールファイル (Planner)
│   ├── /architect-agent
│   │   ├── Dockerfile
│   │   ├── logic.py
│   │   └── config.json      # Amazon Q ルールファイル (Architect)
│   ├── /coder-agent
│   │   ├── Dockerfile
│   │   ├── logic.py
│   │   └── config.json      # Amazon Q ルールファイル (Coder)
│   └── /tester-agent
│       ├── Dockerfile
│       ├── logic.py
│       └── config.json      # Amazon Q ルールファイル (Tester)
│
└── /project_root            # AIが開発対象とするコードベース (EFSマウント対象)
    ├── src/
    ├── docker-compose.yml   # 外部開発環境用（PHP, MySQL, Redis等）
    └── package.json

---

## 2. コンテナオーケストレーション仕様

### 2.1. ローカル環境: k3s + Kubernetes

調査結果に基づき、ローカル環境では軽量なk3sを採用し、AIエージェントと外部開発環境を分離して管理します。

#### k3sセットアップ
```bash
# k3sインストール (ARM64対応)
curl -sfL https://get.k3s.io | sh -

# kubectlエイリアス設定
echo 'alias kubectl="sudo k3s kubectl"' >> ~/.bashrc
source ~/.bashrc
```

#### ネームスペース分離
```yaml
# k8s/ai-agents/namespace.yaml
apiVersion: v1
kind: Namespace
metadata:
  name: ai-agents
---
# k8s/external-env/namespace.yaml
apiVersion: v1
kind: Namespace
metadata:
  name: external-env
```

### 2.2. AWS環境: Amazon EKS

AWS環境では、EKSを使用してスケーラブルなコンテナ管理を実現します。

#### CDK構成 (更新版)
```typescript
// cdk/lib/ai-dev-stack.ts
import * as eks from 'aws-cdk-lib/aws-eks';
import * as ec2 from 'aws-cdk-lib/aws-ec2';

export class AiDevStack extends Stack {
  constructor(scope: Construct, id: string, props?: StackProps) {
    super(scope, id, props);

    // VPC
    const vpc = new ec2.Vpc(this, 'AiDevVpc', {
      maxAzs: 2
    });

    // EKSクラスター (ARM64対応)
    const cluster = new eks.Cluster(this, 'AiDevCluster', {
      vpc,
      version: eks.KubernetesVersion.V1_28,
      defaultCapacity: 0
    });

    // ARM64ノードグループ (Graviton)
    cluster.addNodegroupCapacity('arm64-nodes', {
      instanceTypes: [ec2.InstanceType.of(
        ec2.InstanceClass.M6G, 
        ec2.InstanceSize.MEDIUM
      )],
      minSize: 1,
      maxSize: 5
    });

    // EFS for persistent storage
    const fileSystem = new efs.FileSystem(this, 'ProjectEFS', {
      vpc,
      performanceMode: efs.PerformanceMode.GENERAL_PURPOSE
    });
  }
}
```

## 3. エージェント間通信仕様とコマンド

エージェント間の会話は、HTTPベースのMCPサーバーを通じて行われます。外部開発環境へのアクセスはKubernetes Service Discoveryを使用します。

### 3.1. エージェント間連携コマンド体系

#### 基本コマンド構造
```python
# 標準的なエージェント間通信フォーマット
{
    "command": "COMMAND_TYPE",
    "sender": "AgentName",
    "target": "TargetAgent",
    "payload": {
        "task_id": "unique_task_id",
        "priority": "high|medium|low",
        "context": {},
        "data": {}
    },
    "callback_url": "http://sender-agent:port/callback",
    "timeout": 30
}
```

#### エージェント間連携コマンド一覧

| コマンド | 送信者 | 受信者 | 用途 | ペイロード例 |
|---------|--------|--------|------|-------------|
| **PLAN_TASK** | Planner | Architect | タスク計画の設計依頼 | `{"requirements": "ユーザー要求", "constraints": "制約条件"}` |
| **DESIGN_REVIEW** | Architect | Planner | 設計完了報告 | `{"design_doc": "設計書", "tech_stack": ["PHP", "MySQL"]}` |
| **CODE_REQUEST** | Architect | Coder | コード生成依頼 | `{"specifications": "仕様", "files": ["controller.php"]}` |
| **CODE_COMPLETE** | Coder | Tester | コード完成通知 | `{"files": ["src/app.php"], "dependencies": ["mysql", "redis"]}` |
| **TEST_REQUEST** | Coder | Tester | テスト実行依頼 | `{"test_type": "unit|integration", "target_files": []}` |
| **TEST_RESULT** | Tester | Coder | テスト結果報告 | `{"status": "pass|fail", "errors": [], "coverage": 85}` |
| **DEPLOY_REQUEST** | Tester | Coder | デプロイ依頼 | `{"environment": "staging|production", "config": {}}` |
| **TASK_COMPLETE** | Any | Planner | タスク完了報告 | `{"task_id": "xxx", "result": "success", "artifacts": []}` |

### 3.2. エージェント間通信実装例（CoderがTesterを呼び出す）

CoderAgentの`logic.py`内で、TesterAgentのMCPエンドポイントにHTTP POSTリクエストを送信することで、「会話」を実現します。

```python
# agents/coder-agent/logic.py - エージェント間通信例
import requests
import asyncio
from typing import Dict, Any

class AgentCommunicator:
    def __init__(self, agent_name: str):
        self.agent_name = agent_name
        self.endpoints = {
            "planner": "http://planner-agent.ai-agents.svc.cluster.local:8080/mcp",
            "architect": "http://architect-agent.ai-agents.svc.cluster.local:8081/mcp", 
            "coder": "http://coder-agent.ai-agents.svc.cluster.local:8082/mcp",
            "tester": "http://tester-agent.ai-agents.svc.cluster.local:8083/mcp"
        }
    
    async def send_command(self, target_agent: str, command: str, payload: Dict[Any, Any]) -> Dict[Any, Any]:
        """エージェント間コマンド送信"""
        message = {
            "command": command,
            "sender": self.agent_name,
            "target": target_agent,
            "payload": payload,
            "callback_url": f"http://{self.agent_name.lower()}-agent.ai-agents.svc.cluster.local:{self._get_port()}/callback",
            "timeout": 30
        }
        
        try:
            response = requests.post(
                self.endpoints[target_agent.lower()], 
                json=message,
                timeout=30
            )
            return response.json()
        except Exception as e:
            return {"error": str(e), "status": "failed"}
    
    def _get_port(self) -> int:
        port_map = {"planner": 8080, "architect": 8081, "coder": 8082, "tester": 8083}
        return port_map.get(self.agent_name.lower(), 8080)

# 使用例: CoderがTesterにテスト依頼
communicator = AgentCommunicator("Coder")
result = await communicator.send_command("tester", "TEST_REQUEST", {
    "task_id": "test_001",
    "test_type": "integration",
    "target_files": ["src/UserController.php", "src/AuthService.php"],
    "external_services": ["mysql", "redis"],
    "priority": "high"
})
```

| 項目 | 詳細 |
| :--- | :--- |
| **実行環境** | CoderAgentコンテナ内部 |
| **対象URL** | `http://tester-agent.ai-agents.svc.cluster.local:8083/mcp` |
| **コマンド** | `TEST_REQUEST` |
| **目的** | Coderがコード生成後、Testerに統合テスト実行を依頼し、結果を待つ（同期的な「会話」）。 |

### 3.2. エンドポイントとポート

| エージェント名 | サービス名 (Kubernetes) | MCPポート | 役割 |
| :--- | :--- | :--- | :--- |
| **PlannerAgent** | `planner-agent.ai-agents.svc.cluster.local` | 8080 | タスク指示・完了報告 |
| **ArchitectAgent** | `architect-agent.ai-agents.svc.cluster.local` | 8081 | 設計情報提供 |
| **CoderAgent** | `coder-agent.ai-agents.svc.cluster.local` | 8082 | コード生成・修正・実行 |
| **TesterAgent** | `tester-agent.ai-agents.svc.cluster.local` | 8083 | テスト実行・バグ報告 |

### 3.3. 外部開発環境へのアクセス

| サービス名 | エンドポイント | ポート | 用途 |
| :--- | :--- | :--- | :--- |
| **PHP Application** | `php-app.external-env.svc.cluster.local` | 9000 | アプリケーション実行・テスト |
| **MySQL Database** | `mysql.external-env.svc.cluster.local` | 3306 | データベース操作・テスト |
| **Redis Cache** | `redis.external-env.svc.cluster.local` | 6379 | キャッシュ操作・テスト |
| **Nginx Web Server** | `nginx.external-env.svc.cluster.local` | 80 | HTTP アクセス・E2Eテスト |

### 3.4. 外部環境アクセス実装

#### 外部環境アクセスクラス
```python
# agents/common/external_env_client.py
import requests
import mysql.connector
import redis
import subprocess
from typing import Dict, Any

class ExternalEnvironmentClient:
    def __init__(self):
        self.endpoints = {
            "php": "php-app.external-env.svc.cluster.local:9000",
            "mysql": "mysql.external-env.svc.cluster.local:3306", 
            "redis": "redis.external-env.svc.cluster.local:6379",
            "nginx": "nginx.external-env.svc.cluster.local:80"
        }
        self.mysql_config = {
            "host": "mysql.external-env.svc.cluster.local",
            "port": 3306,
            "user": "testuser",
            "password": "testpass",
            "database": "testdb"
        }
    
    async def execute_php_command(self, command: str, args: Dict[str, Any] = None) -> Dict[str, Any]:
        """PHP アプリケーションでコマンド実行"""
        try:
            url = f"http://{self.endpoints['nginx']}/api/execute"
            payload = {"command": command, "args": args or {}}
            response = requests.post(url, json=payload, timeout=30)
            return {
                "success": response.status_code == 200,
                "status_code": response.status_code,
                "data": response.json() if response.status_code == 200 else None,
                "error": response.text if response.status_code != 200 else None
            }
        except Exception as e:
            return {"success": False, "error": str(e)}
    
    async def execute_mysql_query(self, query: str, params: tuple = None) -> Dict[str, Any]:
        """MySQL データベースクエリ実行"""
        try:
            conn = mysql.connector.connect(**self.mysql_config)
            cursor = conn.cursor(dictionary=True)
            cursor.execute(query, params or ())
            
            if query.strip().upper().startswith('SELECT'):
                result = cursor.fetchall()
            else:
                conn.commit()
                result = {"affected_rows": cursor.rowcount}
            
            cursor.close()
            conn.close()
            return {"success": True, "data": result}
        except Exception as e:
            return {"success": False, "error": str(e)}
    
    async def execute_redis_command(self, command: str, *args) -> Dict[str, Any]:
        """Redis コマンド実行"""
        try:
            host, port = self.endpoints['redis'].split(':')
            r = redis.Redis(host=host, port=int(port), decode_responses=True)
            result = getattr(r, command.lower())(*args)
            return {"success": True, "data": result}
        except Exception as e:
            return {"success": False, "error": str(e)}
    
    async def deploy_code(self, files: Dict[str, str]) -> Dict[str, Any]:
        """コードファイルを外部環境にデプロイ"""
        try:
            results = {}
            for file_path, content in files.items():
                deploy_result = await self._deploy_file(file_path, content)
                results[file_path] = deploy_result
            
            reload_result = await self.execute_php_command("reload")
            results["php_reload"] = reload_result
            
            return {"success": True, "deployment_results": results}
        except Exception as e:
            return {"success": False, "error": str(e)}
    
    async def _deploy_file(self, file_path: str, content: str) -> Dict[str, Any]:
        """個別ファイルのデプロイ"""
        try:
            import tempfile
            import os
            
            with tempfile.NamedTemporaryFile(mode='w', delete=False) as tmp_file:
                tmp_file.write(content)
                tmp_file_path = tmp_file.name
            
            kubectl_cmd = [
                "kubectl", "cp", tmp_file_path,
                f"external-env/php-app-pod:{file_path}"
            ]
            result = subprocess.run(kubectl_cmd, capture_output=True, text=True)
            os.unlink(tmp_file_path)
            
            return {
                "success": result.returncode == 0,
                "output": result.stdout,
                "error": result.stderr if result.returncode != 0 else None
            }
        except Exception as e:
            return {"success": False, "error": str(e)}

    async def run_integration_test(self, test_suite: str) -> Dict[str, Any]:
        """統合テストスイート実行"""
        try:
            test_result = await self.execute_php_command("run_tests", {"suite": test_suite})
            db_test = await self.execute_mysql_query("SELECT 1 as test")
            redis_test = await self.execute_redis_command("ping")
            
            return {
                "success": True,
                "test_results": {
                    "application": test_result,
                    "database": db_test,
                    "cache": redis_test
                }
            }
        except Exception as e:
            return {"success": False, "error": str(e)}
```

### 3.5. TesterAgentの統合テスト実装

```python
# agents/tester-agent/logic.py
from common.external_env_client import ExternalEnvironmentClient

class TesterAgent:
    def __init__(self):
        self.external_client = ExternalEnvironmentClient()
        self.communicator = AgentCommunicator("Tester")
    
    async def handle_test_request(self, request_data: Dict[str, Any]):
        """テストリクエストの処理"""
        test_type = request_data.get("test_type", "unit")
        
        if test_type == "integration":
            return await self.run_integration_tests(request_data)
        elif test_type == "e2e":
            return await self.run_e2e_tests(request_data)
        else:
            return await self.run_unit_tests(request_data)
    
    async def run_integration_tests(self, request_data: Dict[str, Any]) -> Dict[str, Any]:
        """統合テスト実行"""
        try:
            # 1. 外部環境の健全性チェック
            health_check = await self.external_client.run_integration_test("health")
            
            if not health_check["success"]:
                return {"status": "environment_error", "error": health_check["error"]}
            
            # 2. デプロイされたファイルのテスト実行
            deployed_files = request_data.get("deployed_files", [])
            test_results = {}
            
            for file_path in deployed_files:
                test_name = file_path.replace("/", "_").replace(".php", "")
                test_result = await self.external_client.execute_php_command(
                    "run_phpunit", 
                    {"test_file": f"tests/{test_name}Test.php"}
                )
                test_results[file_path] = test_result
            
            # 3. データベース統合テスト
            db_tests = await self.run_database_tests()
            
            # 4. キャッシュ統合テスト
            cache_tests = await self.run_cache_tests()
            
            # 5. CoderAgentに結果報告
            await self.communicator.send_command("coder", "TEST_RESULT", {
                "task_id": request_data.get("task_id"),
                "status": "completed",
                "results": {
                    "health_check": health_check,
                    "file_tests": test_results,
                    "database_tests": db_tests,
                    "cache_tests": cache_tests
                }
            })
            
            return {"status": "test_completed", "results": test_results}
            
        except Exception as e:
            return {"status": "test_failed", "error": str(e)}
    
    async def run_database_tests(self) -> Dict[str, Any]:
        """データベーステスト"""
        tests = [
            ("connection", "SELECT 1"),
            ("create_table", "CREATE TEMPORARY TABLE test_tmp (id INT)"),
            ("insert_data", "INSERT INTO test_tmp VALUES (1)"),
            ("select_data", "SELECT * FROM test_tmp"),
            ("drop_table", "DROP TABLE test_tmp")
        ]
        
        results = {}
        for test_name, query in tests:
            result = await self.external_client.execute_mysql_query(query)
            results[test_name] = result
        
        return results
    
    async def run_cache_tests(self) -> Dict[str, Any]:
        """キャッシュテスト"""
        tests = [
            ("ping", "ping"),
            ("set_key", "set", "test_key", "test_value"),
            ("get_key", "get", "test_key"),
            ("delete_key", "delete", "test_key")
        ]
        
        results = {}
        for test_name, *args in tests:
            result = await self.external_client.execute_redis_command(*args)
            results[test_name] = result
        
        return results
```

### 3.6. エージェント間ワークフロー例

#### 完全な開発フロー
```python
# 1. PlannerAgent -> ArchitectAgent
await planner.send_command("architect", "PLAN_TASK", {
    "requirements": "ユーザー認証システムの実装",
    "constraints": ["PHP 8.2", "MySQL 8.0", "Redis"]
})

# 2. ArchitectAgent -> CoderAgent  
await architect.send_command("coder", "CODE_REQUEST", {
    "specifications": {
        "auth_controller": "JWT認証を使用したログイン機能",
        "user_model": "ユーザー情報のCRUD操作",
        "middleware": "認証チェックミドルウェア"
    },
    "files": ["AuthController.php", "User.php", "AuthMiddleware.php"]
})

# 3. CoderAgent -> TesterAgent
await coder.send_command("tester", "TEST_REQUEST", {
    "test_type": "integration",
    "deployed_files": ["AuthController.php", "User.php"],
    "external_services": ["mysql", "redis"]
})

# 4. TesterAgent -> CoderAgent (結果報告)
await tester.send_command("coder", "TEST_RESULT", {
    "status": "pass",
    "coverage": 95,
    "performance": {"response_time": "120ms"}
})

# 5. CoderAgent -> PlannerAgent (完了報告)
await coder.send_command("planner", "TASK_COMPLETE", {
    "status": "success",
    "artifacts": ["AuthController.php", "User.php", "AuthMiddleware.php"],
    "test_results": "All tests passed"
})
```

---

## 4. Kubernetes マニフェスト実装

### 4.1. AIエージェント用マニフェスト

#### CoderAgent例
```yaml
# k8s/ai-agents/coder-agent.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: coder-agent
  namespace: ai-agents
spec:
  replicas: 1
  selector:
    matchLabels:
      app: coder-agent
  template:
    metadata:
      labels:
        app: coder-agent
    spec:
      containers:
      - name: coder-agent
        image: coder-agent:latest
        ports:
        - containerPort: 8082
        env:
        - name: EXTERNAL_PHP_URL
          value: "http://php-app.external-env.svc.cluster.local:9000"
        - name: EXTERNAL_MYSQL_URL
          value: "mysql.external-env.svc.cluster.local:3306"
        - name: EXTERNAL_REDIS_URL
          value: "redis.external-env.svc.cluster.local:6379"
        volumeMounts:
        - name: project-storage
          mountPath: /app/project_root
      volumes:
      - name: project-storage
        persistentVolumeClaim:
          claimName: project-pvc
---
apiVersion: v1
kind: Service
metadata:
  name: coder-agent
  namespace: ai-agents
spec:
  selector:
    app: coder-agent
  ports:
  - port: 8082
    targetPort: 8082
```

### 4.2. 外部開発環境用マニフェスト

#### PHP + MySQL + Redis スタック
```yaml
# k8s/external-env/php-app.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: php-app
  namespace: external-env
spec:
  replicas: 1
  selector:
    matchLabels:
      app: php-app
  template:
    metadata:
      labels:
        app: php-app
    spec:
      containers:
      - name: php
        image: php:8.2-fpm-alpine
        ports:
        - containerPort: 9000
        volumeMounts:
        - name: app-code
          mountPath: /var/www/html
      volumes:
      - name: app-code
        persistentVolumeClaim:
          claimName: project-pvc
---
apiVersion: v1
kind: Service
metadata:
  name: php-app
  namespace: external-env
spec:
  selector:
    app: php-app
  ports:
  - port: 9000
    targetPort: 9000
```

```yaml
# k8s/external-env/mysql.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: mysql
  namespace: external-env
spec:
  replicas: 1
  selector:
    matchLabels:
      app: mysql
  template:
    metadata:
      labels:
        app: mysql
    spec:
      containers:
      - name: mysql
        image: mysql:8.0
        env:
        - name: MYSQL_ROOT_PASSWORD
          value: "password"
        - name: MYSQL_DATABASE
          value: "testdb"
        ports:
        - containerPort: 3306
        volumeMounts:
        - name: mysql-storage
          mountPath: /var/lib/mysql
      volumes:
      - name: mysql-storage
        emptyDir: {}
---
apiVersion: v1
kind: Service
metadata:
  name: mysql
  namespace: external-env
spec:
  selector:
    app: mysql
  ports:
  - port: 3306
    targetPort: 3306
```

### 4.3. 管理スクリプト

```bash
#!/bin/bash
# manage-k8s.sh

case $1 in
  "start-agents")
    kubectl apply -f k8s/ai-agents/
    echo "AIエージェントを起動しました"
    ;;
  "start-external")
    kubectl apply -f k8s/external-env/
    echo "外部開発環境を起動しました"
    ;;
  "start-all")
    kubectl apply -f k8s/ai-agents/
    kubectl apply -f k8s/external-env/
    echo "全環境を起動しました"
    ;;
  "stop-agents")
    kubectl delete -f k8s/ai-agents/
    echo "AIエージェントを停止しました"
    ;;
  "stop-external")
    kubectl delete -f k8s/external-env/
    echo "外部開発環境を停止しました"
    ;;
  "stop-all")
    kubectl delete -f k8s/ai-agents/
    kubectl delete -f k8s/external-env/
    echo "全環境を停止しました"
    ;;
  "status")
    echo "=== AIエージェント ==="
    kubectl get pods -n ai-agents
    echo "=== 外部開発環境 ==="
    kubectl get pods -n external-env
    ;;
  "logs")
    kubectl logs -n $2 -l app=$3 -f
    ;;
  *)
    echo "使用方法: $0 {start-agents|start-external|start-all|stop-agents|stop-external|stop-all|status|logs <namespace> <app>}"
    ;;
esac
```

## 6. 外部開発環境との統合

### 6.1. project_root/docker-compose.yml (外部開発環境用)

AIエージェントとは独立して起動する開発環境の構成です。

```yaml
# project_root/docker-compose.yml
version: '3.8'
services:
  php-app:
    image: php:8.2-fpm-alpine
    container_name: external-php-app
    volumes:
      - ./src:/var/www/html
    ports:
      - "9000:9000"
    depends_on:
      - mysql
      - redis
    networks:
      - external-dev-net

  nginx:
    image: nginx:alpine
    container_name: external-nginx
    ports:
      - "8080:80"
    volumes:
      - ./nginx.conf:/etc/nginx/nginx.conf
      - ./src:/var/www/html
    depends_on:
      - php-app
    networks:
      - external-dev-net

  mysql:
    image: mysql:8.0
    container_name: external-mysql
    environment:
      MYSQL_ROOT_PASSWORD: password
      MYSQL_DATABASE: testdb
      MYSQL_USER: testuser
      MYSQL_PASSWORD: testpass
    ports:
      - "3306:3306"
    volumes:
      - mysql_data:/var/lib/mysql
    networks:
      - external-dev-net

  redis:
    image: redis:alpine
    container_name: external-redis
    ports:
      - "6379:6379"
    networks:
      - external-dev-net

volumes:
  mysql_data:

networks:
  external-dev-net:
    driver: bridge
```

### 6.2. 統合テストシナリオ

```python
# agents/tester-agent/integration_tests.py
import requests
import mysql.connector
import redis
import json

class IntegrationTestSuite:
    def __init__(self, php_url, mysql_url, redis_url):
        self.php_url = php_url
        self.mysql_url = mysql_url
        self.redis_url = redis_url
    
    async def run_full_test_suite(self):
        """完全な統合テストスイートを実行"""
        results = {
            "database_tests": await self.test_database_operations(),
            "cache_tests": await self.test_cache_operations(),
            "application_tests": await self.test_application_endpoints(),
            "integration_tests": await self.test_full_integration()
        }
        return results
    
    async def test_database_operations(self):
        """データベース操作テスト"""
        try:
            host, port = self.mysql_url.split(':')
            conn = mysql.connector.connect(
                host=host, port=int(port),
                user='testuser', password='testpass',
                database='testdb'
            )
            cursor = conn.cursor()
            
            # テストデータの挿入・取得・削除
            cursor.execute("CREATE TABLE IF NOT EXISTS test_table (id INT PRIMARY KEY, name VARCHAR(100))")
            cursor.execute("INSERT INTO test_table (id, name) VALUES (1, 'test')")
            cursor.execute("SELECT * FROM test_table WHERE id = 1")
            result = cursor.fetchone()
            cursor.execute("DELETE FROM test_table WHERE id = 1")
            
            conn.commit()
            conn.close()
            
            return {"success": True, "data": result}
        except Exception as e:
            return {"success": False, "error": str(e)}
    
    async def test_cache_operations(self):
        """キャッシュ操作テスト"""
        try:
            host, port = self.redis_url.split(':')
            r = redis.Redis(host=host, port=int(port), decode_responses=True)
            
            # テストデータの設定・取得・削除
            r.set('test_key', 'test_value')
            value = r.get('test_key')
            r.delete('test_key')
            
            return {"success": True, "value": value}
        except Exception as e:
            return {"success": False, "error": str(e)}
    
    async def test_application_endpoints(self):
        """アプリケーションエンドポイントテスト"""
        try:
            # ヘルスチェック
            health_response = requests.get(f"http://{self.php_url}/health")
            
            # API エンドポイントテスト
            api_response = requests.post(f"http://{self.php_url}/api/test", 
                                       json={"test": "data"})
            
            return {
                "success": True,
                "health_status": health_response.status_code,
                "api_status": api_response.status_code,
                "api_response": api_response.json() if api_response.status_code == 200 else None
            }
        except Exception as e:
            return {"success": False, "error": str(e)}
```

### 6.3. 環境管理スクリプト

```bash
#!/bin/bash
# project_root/manage-external-env.sh

case $1 in
  "start")
    echo "外部開発環境を起動中..."
    docker-compose -f docker-compose.yml up -d
    echo "起動完了: http://localhost:8080"
    ;;
  "stop")
    echo "外部開発環境を停止中..."
    docker-compose -f docker-compose.yml down
    ;;
  "restart")
    echo "外部開発環境を再起動中..."
    docker-compose -f docker-compose.yml restart
    ;;
  "logs")
    docker-compose -f docker-compose.yml logs -f $2
    ;;
  "status")
    docker-compose -f docker-compose.yml ps
    ;;
  "clean")
    echo "外部開発環境をクリーンアップ中..."
    docker-compose -f docker-compose.yml down -v
    docker system prune -f
    ;;
  *)
    echo "使用方法: $0 {start|stop|restart|logs <service>|status|clean}"
    ;;
esac
```

## 7. セキュリティとネットワーク分離

### 7.1. Kubernetes NetworkPolicy

```yaml
# k8s/network-policies/ai-agents-policy.yaml
apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: ai-agents-policy
  namespace: ai-agents
spec:
  podSelector: {}
  policyTypes:
  - Ingress
  - Egress
  ingress:
  - from:
    - namespaceSelector:
        matchLabels:
          name: ai-agents
  egress:
  - to:
    - namespaceSelector:
        matchLabels:
          name: ai-agents
  - to:
    - namespaceSelector:
        matchLabels:
          name: external-env
    ports:
    - protocol: TCP
      port: 9000  # PHP
    - protocol: TCP
      port: 3306  # MySQL
    - protocol: TCP
      port: 6379  # Redis
```

### 7.2. AWS EKS セキュリティグループ

```typescript
// cdk/lib/ai-dev-stack.ts (セキュリティ部分)
const agentSecurityGroup = new ec2.SecurityGroup(this, 'AgentSecurityGroup', {
  vpc,
  description: 'Security group for AI agents',
  allowAllOutbound: false
});

const externalEnvSecurityGroup = new ec2.SecurityGroup(this, 'ExternalEnvSecurityGroup', {
  vpc,
  description: 'Security group for external development environment'
});

// AIエージェント間の通信を許可
agentSecurityGroup.addIngressRule(
  agentSecurityGroup,
  ec2.Port.tcpRange(8080, 8083),
  'Allow inter-agent communication'
);

// AIエージェントから外部環境への通信を許可
agentSecurityGroup.addEgressRule(
  externalEnvSecurityGroup,
  ec2.Port.tcp(9000),
  'Allow access to PHP application'
);

agentSecurityGroup.addEgressRule(
  externalEnvSecurityGroup,
  ec2.Port.tcp(3306),
  'Allow access to MySQL'
);

agentSecurityGroup.addEgressRule(
  externalEnvSecurityGroup,
  ec2.Port.tcp(6379),
  'Allow access to Redis'
);
```

### 5.1. agents/coder-agent/Dockerfile (Node.js 22 + Python)

```dockerfile
FROM node:22-slim

# OSパッケージのインストール: Python, pip, Git, MySQL client
RUN apt-get update && apt-get install -y \
    python3 python3-pip git \
    mysql-client redis-tools \
    && rm -rf /var/lib/apt/lists/*

WORKDIR /app

# Python依存関係のインストール
COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt

# エージェントのロジックと設定ファイルをコピー
COPY ./agents/coder-agent/logic.py /app/agent_logic/coder.py
COPY ./agents/coder-agent/config.json /app/config/coder.json

# 起動コマンド (CoderのMCPサーバーをFastAPI/Uvicornで起動)
CMD ["uvicorn", "agent_logic.coder:app", "--host", "0.0.0.0", "--port", "8082"]
```

### 5.2. agents/coder-agent/logic.py (外部環境アクセス対応版)

```python
from fastapi import FastAPI, Request
import json
import requests
import os
import subprocess

app = FastAPI()
AGENT_NAME = "CoderAgent"
TESTER_URL = "http://tester-agent.ai-agents.svc.cluster.local:8083/mcp"

# 外部開発環境のエンドポイント
EXTERNAL_PHP_URL = os.getenv("EXTERNAL_PHP_URL", "http://php-app.external-env.svc.cluster.local:9000")
EXTERNAL_MYSQL_URL = os.getenv("EXTERNAL_MYSQL_URL", "mysql.external-env.svc.cluster.local:3306")
EXTERNAL_REDIS_URL = os.getenv("EXTERNAL_REDIS_URL", "redis.external-env.svc.cluster.local:6379")

@app.post("/mcp")
async def handle_mcp_request(request: Request):
    """MCPエンドポイント: 他のエージェントからのタスクを受け取る"""
    data = await request.json()
    sender = data.get("sender", "Unknown")
    task = data.get("task", "No Task")
    
    print(f"[{AGENT_NAME}] Received task from {sender}: {task}")
    
    if "実装せよ" in task:
        # コード生成
        result_message = f"コードを生成しました。外部環境でテストを実行します。"
        
        # 外部環境での統合テスト実行
        test_result = await run_integration_test()
        
        # TesterAgentに結果を報告
        response = requests.post(TESTER_URL, json={
            "sender": AGENT_NAME,
            "task": "統合テストの結果を検証せよ",
            "test_result": test_result,
            "external_env": {
                "php_url": EXTERNAL_PHP_URL,
                "mysql_url": EXTERNAL_MYSQL_URL,
                "redis_url": EXTERNAL_REDIS_URL
            }
        })
        
        return {
            "status": "processing", 
            "message": result_message, 
            "integration_test": test_result,
            "tester_response": response.json()
        }
        
    return {"status": "success", "result": f"{AGENT_NAME}がタスクを完了しました。", "received_task": task}

async def run_integration_test():
    """外部開発環境での統合テスト実行"""
    try:
        # MySQL接続テスト
        mysql_result = subprocess.run([
            "mysql", "-h", EXTERNAL_MYSQL_URL.split(':')[0], 
            "-P", EXTERNAL_MYSQL_URL.split(':')[1],
            "-u", "root", "-ppassword", "-e", "SELECT 1;"
        ], capture_output=True, text=True)
        
        # Redis接続テスト
        redis_result = subprocess.run([
            "redis-cli", "-h", EXTERNAL_REDIS_URL.split(':')[0],
            "-p", EXTERNAL_REDIS_URL.split(':')[1], "ping"
        ], capture_output=True, text=True)
        
        # PHP アプリケーションテスト (HTTP リクエスト)
        php_response = requests.get(f"http://{EXTERNAL_PHP_URL}/health")
        
        return {
            "mysql_connection": mysql_result.returncode == 0,
            "redis_connection": "PONG" in redis_result.stdout,
            "php_application": php_response.status_code == 200,
            "details": {
                "mysql_output": mysql_result.stdout,
                "redis_output": redis_result.stdout,
                "php_status": php_response.status_code
            }
        }
    except Exception as e:
        return {
            "error": str(e),
            "mysql_connection": False,
            "redis_connection": False,
            "php_application": False
        }

if __name__ == "__main__":
    pass
```

