/**
 * Infrastructure Layer: Automation Variables Mapper
 * Handles serialization/deserialization of AutomationVariables
 * Uses CSV format with JSON-stringified variables field
 * Implements AutomationVariablesCSVConverter interface for dependency inversion
 */

import { AutomationVariablesData } from '@domain/entities/AutomationVariables';
import { Logger } from '@domain/types/logger.types';
import { AutomationVariablesCSVConverter } from '@domain/types/csv-converter.types';
import { NoOpLogger } from '@domain/services/NoOpLogger';
import { isAutomationStatus } from '@domain/constants/AutomationStatus';

export class AutomationVariablesMapper implements AutomationVariablesCSVConverter {
  constructor(private logger: Logger = new NoOpLogger()) {}
  /**
   * Convert array of AutomationVariablesData to CSV string
   * Format: "id","status","updatedAt","variables","websiteId"
   */
  static toCSV(automationVariables: AutomationVariablesData[]): string {
    // CSV Header with quoted field names
    const header = '"id","status","updatedAt","variables","websiteId"';

    // CSV Rows - all fields are quoted
    const rows = automationVariables.map((av) => {
      const id = av.id;
      const status = av.status || '';
      const updatedAt = av.updatedAt;
      const variables = JSON.stringify(av.variables || {});
      const websiteId = av.websiteId;

      return [
        this.escapeCSV(id),
        this.escapeCSV(status),
        this.escapeCSV(updatedAt),
        this.escapeCSV(variables),
        this.escapeCSV(websiteId),
      ].join(',');
    });

    return [header, ...rows].join('\n');
  }

  /**
   * Create array of AutomationVariablesData from CSV string
   */
  static fromCSV(csv: string, logger: Logger = new NoOpLogger()): AutomationVariablesData[] {
    const lines = csv.split('\n').filter((line) => line.trim());

    if (lines.length < 2) {
      throw new Error('Invalid CSV format: no data rows');
    }

    // Skip header and parse each data line
    const dataLines = lines.slice(1);
    const automationVariables: AutomationVariablesData[] = [];

    dataLines.forEach((line, index) => {
      const result = this.parseAutomationVariableLine(line, index, logger);
      if (result) {
        automationVariables.push(result);
      }
    });

    return automationVariables;
  }

  // eslint-disable-next-line max-lines-per-function, complexity
  private static parseAutomationVariableLine(
    line: string,
    index: number,
    logger: Logger
  ): AutomationVariablesData | null {
    try {
      const values = this.parseCSVLine(line);

      if (values.length < 4) {
        logger.warn(
          `Skipping line ${index + 2}: insufficient columns (expected 4 or 5, got ${values.length})`
        );
        return null;
      }

      // Support both old format (4 columns) and new format (5 columns)
      let id: string;
      let status: string | undefined;
      let updatedAt: string;
      let variablesStr: string;
      let websiteId: string;

      if (values.length >= 5) {
        // New format: "id","status","updatedAt","variables","websiteId"
        id = values[0];
        status = values[1] || undefined;
        updatedAt = values[2];
        variablesStr = values[3];
        websiteId = values[4];
      } else {
        // Old format: "status","updatedAt","variables","websiteId"
        id = '';
        status = values[0] || undefined;
        updatedAt = values[1];
        variablesStr = values[2];
        websiteId = values[3];
      }

      if (!websiteId) {
        logger.warn(`Skipping line ${index + 2}: missing websiteId`);
        return null;
      }

      if (status && !isAutomationStatus(status)) {
        logger.warn(`Invalid status on line ${index + 2}: ${status}, skipping`);
        return null;
      }

      const variables = this.parseVariablesJSON(variablesStr, index, logger);

      return {
        id: id || '', // Will be auto-generated by fromExisting if empty
        websiteId,
        variables,
        status: status as 'enabled' | 'disabled' | 'once' | undefined,
        updatedAt: updatedAt || new Date().toISOString(),
      };
    } catch (error) {
      logger.error(`Error parsing CSV line ${index + 2}`, error);
      return null;
    }
  }

  private static parseVariablesJSON(
    variablesStr: string,
    index: number,
    logger: Logger
  ): Record<string, string> {
    if (!variablesStr) {
      return {};
    }

    try {
      const variables = JSON.parse(variablesStr);
      if (typeof variables !== 'object' || Array.isArray(variables)) {
        logger.warn(`Invalid variables format on line ${index + 2}, using empty object`);
        return {};
      }
      return variables;
    } catch (error) {
      logger.warn(`Failed to parse variables JSON on line ${index + 2}, using empty object`);
      return {};
    }
  }

  /**
   * Instance method: Convert Automation Variables array to CSV string
   * Implements AutomationVariablesCSVConverter interface
   */
  toCSV(variables: AutomationVariablesData[]): string {
    return AutomationVariablesMapper.toCSV(variables);
  }

  /**
   * Instance method: Convert CSV string to Automation Variables array
   * Implements AutomationVariablesCSVConverter interface
   */
  fromCSV(csv: string): AutomationVariablesData[] {
    return AutomationVariablesMapper.fromCSV(csv, this.logger);
  }

  // Private helper methods

  private static escapeCSV(value: string): string {
    if (!value) return '""';

    // Always wrap in quotes and escape internal quotes
    const escaped = value.replace(/"/g, '""');
    return `"${escaped}"`;
  }

  private static parseCSVLine(line: string): string[] {
    const result: string[] = [];
    let current = '';
    let inQuotes = false;

    for (let i = 0; i < line.length; i++) {
      const char = line[i];
      const nextChar = line[i + 1];

      if (char === '"') {
        if (inQuotes && nextChar === '"') {
          // Escaped quote
          current += '"';
          i++; // Skip next quote
        } else {
          // Toggle quote mode
          inQuotes = !inQuotes;
        }
      } else if (char === ',' && !inQuotes) {
        // End of field
        result.push(current);
        current = '';
      } else {
        current += char;
      }
    }

    // Add last field
    result.push(current);

    return result;
  }
}
